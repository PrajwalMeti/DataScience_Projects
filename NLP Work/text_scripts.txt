|******************************************************************************
|* txboddll9002  B61O_a_ext
|* Handling BOD's
|* kbommana
|* 2022-11-29 [05:00] 
|******************************************************************************
|* Script Type: Library
|******************************************************************************
	table	ttcemm170	|* Companies
	table	ttsmdm000	|* General Service Parameters
	table	ttcbod000	|* BOD Parameters
	table	ttdcms000	|* Commissions/Rebates Parameters
	table	ttdcms010	|* Relations
	table	ttdcms050	|* Commissions/Rebates
	table	ttccom000	|* Implemented Software Components (Companies)
	table	tbobod100	|* BOD Metadata and Parameters
	table	tttadv111	|* Package VRC's
	table	ttirou000	|* Job Shop Master Data Parameters
	table	ttcuef005	|* Exceptions
	table	ttxbod001	|* Logistic Interface Parameters
	 
 	   	      
	#include <bic_dam> 
	#include  "itxmcs2000"	|* General defnies used for Valmet (similar to
                                |* tcmcs2000)
	#include "itxbod0006"	|* Function Used for Publish Data (initila Load)
|	#include <bic_desktop>
	#include <bic_interface>
|	#include "itxbod0004"	|* General Defines
	
	 
|	#include "ibomcs2000"	|* BOD implementation macro's
|	#include "ibobod1008" 
                                 
        #include "itxbod0001"	|* Macros for Custom BOD implementation (similar
                                |* to tcbod0001)
        
       #include "itxcom0000"	|* Multicurrency declarations
|       #include "icpcom0001"	|* In include  we have req APIs
        #include <bic_ext>	|* For Process Extensions  
          
      #pragma used dll "otlbctdll1000"
      #pragma used dll "otcextbodapi"
      #pragma used dll "otcextextapi"
      #pragma used dll "otcextcomapi"
      #pragma used dll "otcextbdeapi"
      #pragma used dll otxmdmdll9001
      #pragma used dll otcextbodapi  
      

  
   
	long		txbod9001.dll.id
	long		txbod9001.function.id
	long		txbod9001.retval
	string		txbod9001.object(15)
	boolean		g.tpbod.dll0010.status.updated

|* Return type: long
	#define	CALL_FUNCTION( i_FUNCTION )
^		TXBOD9001_EXECUTE_FUNCTION( "", "##i_FUNCTION##", true )

	|* Return type: long
	#define	CALL_FUNCTION( i_FUNCTION, ... )
^		TXBOD9001_EXECUTE_FUNCTION( "", "##i_FUNCTION##", true, ... )

|* Return type: long
	#define	TRY_FUNCTION( i_FUNCTION )
^		TXBOD9001_EXECUTE_FUNCTION( "", "##i_FUNCTION##", false )

	|* Return type: long
	#define	TRY_FUNCTION( i_FUNCTION, ... )
^		TXBOD9001_EXECUTE_FUNCTION( "", "##i_FUNCTION##", false, ... )

|* Return type: long
	#define	TXBOD9001_EXECUTE_FUNCTION( i_SCRIPT, i_FUNCTION, i_SET_ERRORS )
^		( txbod9001.handle.before.execute.function(
^			i_SCRIPT,
^			i_FUNCTION,
^			i_SET_ERRORS,	|* Do not set an error if DLL/function
^					|* is not found.
^			txbod9001.dll.id,		|* Ref
^			txbod9001.function.id,		|* Ref
^			txbod9001.object,		|* Ref
^			txbod9001.retval ) = 0 AND	|* Ref
^		  txbod.dll9002.handle.after.execute.function(
^			txbod9001.object,
^			i_FUNCTION,
^			exec_function(
^				txbod9001.dll.id,
^				txbod9001.function.id,
^				txbod9001.retval ),
^			txbod9001.retval ) = 0 ) ? 0 : txbod9001.retval

	|* Return type: long
	#define	TXBOD9001_EXECUTE_FUNCTION( i_SCRIPT, i_FUNCTION, i_SET_ERRORS, ... )
^		( txbod9001.handle.before.execute.function(
^			i_SCRIPT,
^			i_FUNCTION,
^			i_SET_ERRORS,	|* Do not set an error if DLL/function
^					|* is not found.
^			txbod9001.dll.id,		|* Ref
^			txbod9001.function.id,		|* Ref
^			txbod9001.object,		|* Ref
^			txbod9001.retval ) = 0 AND	|* Ref
^		  txbod.dll9002.handle.after.execute.function(
^			txbod9001.object,
^			i_FUNCTION,
^			exec_function(
^				txbod9001.dll.id,
^				txbod9001.function.id,
^				txbod9001.retval,
^				##...## ),
^			txbod9001.retval ) = 0 ) ? 0 : txbod9001.retval


      

	#define	LENGTH_FIELD		18
	#define	ALLOCATE_SIZE	10
	#define	MAX_CACHE	100
	
	#define	DB.MODE.INSERT		1
	#define	DB.MODE.UPDATE		2
	#define	DB.MODE.DELETE		3
	
	#define	TAG_DATALANG		"datalang"
	#define	ATTR_STATUS		"status"
	
	#define	GET_ELEMENT	"GetElement"
	#define	GET_ATTRIBUTE	"GetAttribute"
	
	#define	NOUN_WORKFLOW	"Workflow"
	
	#define	VERB_SHOW			"Show"
	
	#define	TAG_NAME_CLASSIFICATON	"Classification"
	#define	TAG_NAME_CODES		"Codes"
	#define	TAG_NAME_CODE		"Code"
	#define	TAG_PROPERTY		"Property"
	#define	TAG_NAME_VALUE		"NameValue"
	#define	TAG_DESCRIPTION		"Description"
	#define	TAG_EFF_TIME_PERIOD	"EffectiveTimePeriod"
	#define	TAG_START_DATE_TIME	"StartDateTime"
	#define	TAG_END_DATE_TIME	"EndDateTime"
	#define	TAG_USER_AREA		"UserArea"
	
	#define CODE_ABCCODE			"ABC Codes"
	#define	CODE_COMMODITYCODE		"Commodity Codes"
	#define	CODE_ITEMCONTROLCODE		"Item Control Codes"
	#define	CODE_ITEMGROUP			"Item Groups"
	#define CODE_ITEMSIGNAL			"Item Signals"
	#define CODE_ITEMTYPE			"Item Types"
	#define CODE_MATERIAL			"Materials"
	#define	CODE_ORDERPOLICY		"Order Policy"
	#define CODE_MROCLASS			"MRO Classes"
	#define	CODE_PRODUCTCLASS		"Item Classes"
	#define	CODE_PRODUCTLINE		"Product Lines"
	#define	CODE_PRODUCTSELECTIONCODE	"Product Selection Codes"
	#define	CODE_PRODUCTTYPE		"Product Types"
	#define	CODE_REBATEGROUP		"Item Rebate Groups"
	#define	CODE_ROUTETYPE			"Route Types"
	#define	CODE_SIZE			"Sizes"
	#define	CODE_SERVICEITEMGROUPS		"LN Service Item Groups"	
	#define	CODE_STANDARD			"Standards"
	#define	CODE_TSMDM_CCTR_CONFIGURATIONCONTROLLED	"LN Configuration Controlled"	
	
	#define	OCM_ACTIVE( i_TABLE )
^		txgen.dll9001.ocm.active( i_TABLE )	
	
	#define CLIENT_DOWNLOAD_ZIP_FILE	|* True/false
^		use.client.download.for.zipped.log.file()

		#define	ERROR_ROUTINE_SET_MAINTAINABILITY_BODS
^		while dal.get.error.message( error.message ) <> - 1
^			mess( "tcgenstring", 1, error.message )
^			|* %1$s
^		endwhile
^
^		return	|* Early return!

	#define	LABEL_PUBLIC_BOD_NAME	"PUBLIC BOD NAME"
	#define	PREFIX_PB_FIELD		"pb."

	#define	BODS_ALL	1
	#define	BODS_STANDARD	2
	#define	BODS_CUSTOM	3
	
	#define	PUBLIC_BOD			1		|#1487223.sn
	#define	PROTECTED_BOD			2
	
	#define	B_GET				1
	#define B_LOAD				2
	#define B_PROCESS			4
	#define B_SYNC				8
	#define B_UPDATE			16
	
	#define	INCREASE_SIZE_STACK	10
	
	#define	ALLOCATION_SIZE	10
	
	#define	LENGTH_FIELD		18
	#define LENGTH_DLL_CODE		14
	#define	LENGTH_OBJECT_CODE	15
	#define LENGTH_FUNCTION_NAME	500
	#define	LENGTH_IMPL_METHOD	15
	#define	LENGTH_FILE_NAME	150
	
	#define	GET_VALUE	1
	#define	SET_VALUE	2
	#define	RESET_VALUE	7
	#define	INIT_VALUE	3
	#define	NEXT_VALUE	4
	#define	STORE_VALUE	5
	#define	RESTORE_VALUE	6
	
	#define	RETURN_0_IMPLEMENTATION	"Return(0) Implementation"
	
		#define	LENGTH_FIELD		18
		#define CLIENT_DOWNLOAD_ZIP_FILE	|* True/false
^		use.client.download.for.zipped.log.file()
	|* Defines related to name of business object.
	#define	PREFIX_PB_FIELD		"pb."
	#define	LABEL_PUBLIC_BOD_NAME	"PUBLIC BOD NAME"
	#define	PARM_STRING		9	
	#define	BODS_ALL	1
	#define	BODS_STANDARD	2
	#define	BODS_CUSTOM	3
	#define	INCREASE_SIZE_STACK	10
	#define	FIXED_STACK_SIZE	200
	#define	SUPPORTING_DLL		2
	#define ROUTING_DLL		3
	#define	MAX_LEVELS		100
	#define	LENGTH_LINE		2048
	
	#define	INTEGER_LENGTH	6	| For all the datatypes, one space
	#define	LONG_LENGTH	13	| is reserved for the minus sign
	#define	DOUBLE_LENGTH	21
	#define	BYTE_LENGTH	4
	#define	INDEX_NR	1
	
	#define	MAX.VALUE 	99999999
	
	#define	ON_SYNC			"OnSync"
	#define	ON_LOAD			"OnLoad"
	#define	ON_PROCESS		"OnProcess"
	#define	ON_GET			"OnGet"
	#define	ON_SHOW			"OnShow"
	#define	ON_UPDATE		"OnUpdate"
	#define	ON_POST			"OnPost"
	#define	ON_ACKNOWLEDGE		"OnAcknowledge"
	
	#define	PARM_STAGING		"STAGING"
	#define	PARM_SYNC_PROCESSING	"SYNC_PROCESSING"
	#define	PARM_SPLIT_SIZE		"SPLIT_SIZE"		|#1544708.n
	#define	PARM_STAGING_CONDITION	"STAGING_CONDITION"
	
	#define	LENGTH_IMPL_METHOD	15
	#define	LENGTH_DLL_CODE		14
	#define	LENGTH_OBJECT_CODE	15
	#define	LENGTH_BOD_NAME		70
	#define	LENGTH_FILE_NAME	150
	#define	LENGTH_FUNCTION_NAME	500
	
	#define	YES boyesno.yes
	#define	NO boyesno.no
	
	#define ITEM.NODE.ITEM			1
	#define ITEM.NODE.PACKINGMATERIAL	3
	#define ITEM.NODE.SHIPPINGMATERIAL	2
	
	#define	VERB_SHOW			"Show"
	#define	VERB_SYNC			"Sync"
	#define VERB_PROCESS			"Process"	|#1487223.en
	#define	VERB_ACKNOWLEDGE		"Acknowledge"	|#1668244.sn
	#define	VERB_GET			"Get"
	#define	VERB_LOAD			"Load"
	#define	VERB_POST			"Post"
	#define	VERB_UPDATE			"Update"
	
	#define	LEDGER_UNIT_DIM_1		"Ledger Unit Dimension 1"	|#1651332.n
	#define	LEDGER_UNIT_DIM_2		"Ledger Unit Dimension 2"	|#1651332.n
	#define	ELEMENT_CODE	"Code"
	
	|* Item Types
	#define COST				"Cost"
	#define ENGINEERING			"Engineering Module"
	#define EQUIPMENT			"Equipment"
	#define GENERIC				"Generic"
	#define LIST				"List"
	#define TOOL				"Tool"
	#define MANUFACTURED			"Manufactured"
	#define PURCHASED			"Purchased"
	#define SERVICE				"Service"
	#define SUBCONTRACTING			"Subcontracted Service"
	
	
	|* Attribute names					|#1682808.sn
	#define	ATTR_ACCOUNTING_ENTITY		"accountingEntity"
	#define	ATTR_CURRENCY_ID		"currencyID"
	#define	ATTR_LIST_ID			"listID"
	#define	ATTR_NAME			"name"
	#define	ATTR_NOUN_NAME			"nounName"
	#define	ATTR_REVISION_ID		"revisionID"
	#define	ATTR_SEQUENCE			"sequence"
	#define	ATTR_TYPE			"type"
	#define	ATTR_UNIT_CODE			"unitCode"
	#define	ATTR_LANGUAGE_ID		"languageID"
	
	#define	PROP_TYPE_AMOUNT		"AmountType"	|#1682808.n
	#define	PROP_TYPE_CODE			"CodeType"	|#1682808.n
	#define	PROP_TYPE_DATE			"DateType"	|#1668244.sn
	#define	PROP_TYPE_DATETIME		"DateTimeType"
	#define	PROP_TYPE_INDICATOR		"IndicatorType"
	#define	PROP_TYPE_INTEGER_NUMERIC	"IntegerNumericType"
	#define	PROP_TYPE_MASTERDATA_REFERENCE	"MasterDataReferenceType"	|#1682808.n
	#define	PROP_TYPE_NUMERIC		"NumericType"
	#define	PROP_TYPE_QUANTITY		"QuantityType"	|#1682808.n
	#define	PROP_TYPE_STRING		"StringType"
	#define	PROP_TYPE_TIME			"TimeType"	|#1668244.en
	
						|# tcbod0001
	#define	SET_MINIMUM_DATE		1
	#define	SET_MAXIMUM_DATE		2
	#define	SET_CURRENT_DATE		3
	#define	SET_NO_DATE			4
	#define SET_CURRENT_DATE_NO_TIME 	5
	#define	KEEP_TIME_FORMAT	0
	|* Defines for UserArea
	#define	UA_ATTR_NAME			"UserAreaAttributeName"
	#define	UA_ATTR_VALUE			"UserAreaAttributeValue"
	#define	UA_DESC				"UserAreaDescription"
	#define	UA_ENDDATE			"UserAreaEndDate"
	#define	UA_NAME				"UserAreaName"
	#define	UA_STARTDATE			"UserAreaStartDate"
	#define	UA_TYPE				"UserAreaType"
	#define	UA_VALUE			"UserAreaValue"
	
	#define	SCHEME_NAME_SUPPLIER		"Supplier"
	
	#define	ASTERISK			"*"
	
|* A new group node with name 'i_node_name' is build.
|* When io_parent_node > 0 then the new node is linked to parent node
|* 'io_parent_node'.
|* The new group node is called 'o_node'.
	#define	NEW_NODE(i_node_name, io_parent_node, o_node)
^		##o_node = xmlNewNode(	trim$(##i_node_name##),
^					XML_ELEMENT,
^					##io_parent_node##)
^		if ##o_node## = 0 then
^			dal.set.error.message(	"tcgens0025",
^						trim$(##i_node_name##))
^			return(DALHOOKERROR)
^		endif
	
|* Only used in exceptional cases:
|* Same as NEW_ELEMENT, except that the value is not trimmed.
	#define	NEW_ELEMENT_NOT_TRIMMED(i_elem_name, i_elem_value, i_parent_node, o_elem)
^		##o_elem## = xmlNewDataElement(
^					trim$(##i_elem_name##),
^					strip$(##i_elem_value##),
^					##i_parent_node##)
^		if ##o_elem## = 0 then
^			dal.set.error.message(	"tcgens0025",
^						trim$(##i_elem_name##))
^			return(DALHOOKERROR)
^		endif
	
	#define	ASSERT(CONDITION, INFO)
^	if not asserts.initialized then
^		init.asserts()
^	endif
^	if asserts.active then
^		|* check condition and log failure
^		if not (##CONDITION##) then
^			assert.failed(##INFO##, __FILE__, __LINE__)
^		endif
^	endif

	#define	RETURN.IF.OBJECT.KEY.NOT.OK
^	if not object.key.ok then
^		return(i.stcf = tcyesno.yes)
^	endif

	#define		RETURN_IF_ALREADY_READ
^
^			static	domain	tcncmp	hold.company
^
^			curr.company = get.compnr()
^			if curr.company <> hold.company
^			then
^				hold.company = curr.company
^			else
^				return
^			endif

#define	CHECK.OBJECT.FLAGS.AND.UNIT
^	check.object.flags(i.stcf, i.unef, i.effn, object.valid, return.now)
^	if return.now then
^		return(object.valid)
^	endif

#define	RETURN.IF.OBJECT.KEY.NOT.OK
^	if not object.key.ok then
^		return(i.stcf = tcyesno.yes)
^	endif

#define	PLAN_ITEM_FIELD_DEFINITION
^	domain	cpitem		plan.item
^	domain	cpcom.plvl	plan.level
^	domain	cprpd.plit	plan.item.type
^	domain	tccwar		warehouse
^	domain	cpcom.yeno	has.masterplan
^	domain	tcemno		planner
^	domain	tcitem		item
^	domain	tcyesno		planned.by.planner
^	domain	cpcom.rpun	master.plan.unit
^	domain	cpcom.calh	forecast.time.fence
^	domain	cpcom.hori	order.horizon
^	domain	cpvmi.role	vmi.role			|#800-155923.n
^	domain	cprpd.sour	default.source			|#BODtcibd501.sn
^	domain	tcdate		planning.horizon
^	domain	tcwttm		time.fence			|#LND-703.sn
^	domain	tctope		time.fence.unit
^	domain	tcyesno		use.time.fence			|#LND-703.en
^	domain	cpcom.cato	extra.lead.time
^	domain	tctope		extra.lead.time.unit		|#BODtcibd501.en
^	domain	cpcom.hori	fixed.lead.time
^	domain	cpcom.yeno	critical.in.ctp			|#1454537.n
^	domain	cpcom.yeno	online.atp.update		|#1828637.n
^	domain	cpcom.yeno	channel.atp
^	domain	cpcom.yeno	family.atp
^	domain	cpcom.yeno	component.atp
^	domain	cpcom.yeno	capacity.atp
^	domain	cpcom.hori	ctp.horizon			|#234723.n
^	domain	cpcom.hori	ctp.timefence			|#234723.n
^	domain	tcncmp		family.site			|#1641634.sn
^	domain	cpitem		family.item
^	domain	cpcom.hori	family.ctp.horizon		|#1641634.en
^	domain	cprpd.uatt	use.att.lead.time		|#lnd-1978.sn
^	domain	cpcom.ldtm	att.lead.time
^	domain	tcwttm		att.multiplier			|#lnd-1978.en
^	domain	cpcom.yeno	dependent.demand.fcst
^	domain	cpcom.phnu	order.phase.no
^	domain	cpcom.phnu	master.phase.no			|#1486608.n
^	domain	cpcom.hori	g.psho				|#LND2-809.n
^	domain 	tccdsc		fixed.delivery.code		|#LND-2761.n
|^	domain	tcmcs.long	plan.item.code			|#LND-5897.o

#define STORE_PLAN_ITEM_DATA
^	last.index = ( last.index >= MAX_CACHE ? 1 : last.index + 1 )
^	last.company = i.company
^	g.companies( last.index ) = i.company
^	g.plan.items( 1, last.index ) = plan.item
^	g.plan.levels( last.index ) = plan.level
^	g.plan.item.types( last.index ) = plan.item.type
^	g.warehouses( 1, last.index ) = warehouse
^	g.has.masterplans( last.index ) = has.masterplan
^	g.planners( 1, last.index ) = planner
^	g.items( 1, last.index ) = item
^	g.planned.by.planners( last.index ) = planned.by.planner
^	g.master.plan.units( 1, last.index ) = master.plan.unit
^	g.forecast.time.fences( last.index ) = forecast.time.fence
^	g.order.horizons( last.index ) = order.horizon
^	g.vmi.role(last.index) = vmi.role			|#800-155923.n
^	g.critical.in.ctp(last.index) = critical.in.ctp		|#1454537.n
^	g.online.atp.update(last.index) = online.atp.update	|#1828637.n
^	g.channel.atp(last.index) = channel.atp
^	g.component.atp( last.index ) = component.atp
^	g.capacity.atp( last.index ) = capacity.atp
^	g.family.atp( last.index ) = family.atp
^	g.default.source(last.index) = default.source		|#BODtcibd501.sn
^	g.planning.horizon(last.index) = planning.horizon
^	g.time.fences( last.index ) = time.fence		|#LND-703.sn
^	g.time.fence.units( last.index ) = time.fence.unit
^	g.use.time.fences( last.index ) = use.time.fence	|#LND-703.en
^	g.extra.lead.time(last.index) = extra.lead.time
^	g.extra.lead.time.unit(last.index) = extra.lead.time.unit |#BODtcibd501.en
^	g.fixed.lead.times(last.index) = fixed.lead.time
^	g.ctp.horizons(last.index) = ctp.horizon		|#234723.n
^	g.ctp.timefences(last.index) = ctp.timefence		|#234723.n
^	g.family.ctp.horizons(last.index) = family.ctp.horizon	|#1641634.sn
^	g.family.sites(last.index) = family.site
^	g.family.items(1, last.index) = family.item		|#1641634.en
^	g.use.att.lead.time( last.index ) = use.att.lead.time	|#lnd-1978.sn
^	g.att.lead.time( last.index ) = att.lead.time
^	g.att.multiplier( last.index ) = att.multiplier		|#lnd-1978.en
^	g.dependent.demand.fcst(last.index) = dependent.demand.fcst
^	g.order.phase.no(last.index) = order.phase.no
^	g.cache.psho(last.index) = g.psho			|#LND2-809.n
^	g.fixed.delivery.code(1, last.index) = fixed.delivery.code

	#define	CACHE_BODS( A,B,C,D,E,F,G,H,I )
^		CACHE_BOD( A,B,C,D,E,F,G,H,I )

	#define	CACHE_BODS( A,B,C,D,E,F,G,H,I, ... )
^		CACHE_BOD( A,B,C,D,E,F,G,H,I )
^		CACHE_BODS( ... )
	
	#define	CACHE_BOD( A,B,C,D,E,F,G,H,I )
^		if (isspace(i.name) or trim$(i.name) = trim$(A)) and
^		    BOD_SUPPORTED( A ) then
^			position = position + 1
^
^			fill.parameter.string(A, false, parm.string)
^
^			cache.metadata(
^				A,
^				B,
^				C,
^				D,
^				E,
^				F,
^				G,
^				H,
^				I,
^				parm.string,
^				position,
^				s.g.name.stack,		|* ref
^				s.g.identifier.stack,	|* ref
^				s.g.visibility.stack,	|* ref
^				s.g.type.stack,		|* ref
^				s.g.parent.bod.stack,	|* ref
^				s.g.support.ae.stack,	|* ref
^				s.g.parm.stack,		|* ref
^				s.g.receive.verbs.stack,|* ref
^				s.g.send.verbs.stack,	|* ref
^				s.g.bod.release.stack)	|* ref
^		endif

	#define	BOD_SUPPORTED( A )
^		bod.supported( A, false )

#define		RETURN_IF_ALREADY_READ
^
^			static	domain	tcncmp	hold.company
^
^			curr.company = get.compnr()
^			if curr.company <> hold.company
^			then
^				hold.company = curr.company
^			else
^				return
^			endif

	#define	CHECK.OBJECT.FLAGS.AND.UNIT
^	check.object.flags(i.stcf, i.unef, i.effn, object.valid, return.now)
^	if return.now then
^		return(object.valid)
^	endif


	#define	SET_BASED_VARIABLE( i_VALUE, o_VALUE )
|^		tcbod.dll0038.set.based.variable( i_VALUE, o_VALUE )
^		txbod.dll9002.set.based.variable( i_VALUE, o_VALUE )

#define	SELECT_PLAN_ITEM_DATA
^	cprpd100.plni:plan.item,
^	cprpd100.plvl:plan.level,
^	cprpd100.plit:plan.item.type,
^	cprpd100.cwar:warehouse,
^	cprpd100.osys:has.masterplan,
^	cprpd100.plid:planner,
^	cprpd100.item:item,
^	cprpd100.pbpl:planned.by.planner,
^	cprpd100.mrpu:master.plan.unit,
^	cprpd100.fctf:forecast.time.fence,
^	cprpd100.otmf:order.horizon,
^	cprpd100.vmir:vmi.role,					|#800-155923.n
^	cprpd100.sour:default.source,				|#BODtcibd501.sn
^	cprpd100.ptmf:planning.horizon,
^	cprpd100.tmfc:time.fence,				|#LND-703.sn
^	cprpd100.tmfu:time.fence.unit,
^	cprpd100.utmf:use.time.fence,				|#LND-703.en
^	cprpd100.eltm:extra.lead.time,
^	cprpd100.eltu:extra.lead.time.unit,			|#BODtcibd501.en
^	cprpd100.fltm:fixed.lead.time,
^	cprpd100.cria:critical.in.ctp,				|#1454537.n
^	cprpd100.onat:online.atp.update,			|#1828637.n
^	cprpd100.chat:channel.atp,
^	cprpd100.coat:component.atp,
^	cprpd100.catp:capacity.atp,
^	cprpd100.fatp:family.atp,
^	cprpd100.hoat:ctp.horizon,				|#234723.n
^	cprpd100.tfat:ctp.timefence,				|#234723.n
^	cprpd100.fasi:family.site,				|#1641634.sn
^	cprpd100.fite:family.item,
^	cprpd100.atho:family.ctp.horizon,			|#1641634.en
^	cprpd100.uatt:use.att.lead.time,			|#lnd-1978.sn
^	cprpd100.atta:att.lead.time,
^	cprpd100.attm:att.multiplier,				|#lnd-1978.en
^	cprpd100.depd:dependent.demand.fcst,
^	cprpd100.mrph:order.phase.no,
^	cprpd100.phnu:master.phase.no,				|#1486608.n
^	cprpd100.psho:g.psho,					|#LND2-809.n
^	cprpd100.fide:fixed.delivery.code	

	
	#define RETIFNOK.SWITCH.COMP(COMP,...)
^		txmcs2000.e = ...
^		if txmcs2000.e <> 0 then
^			if COMP <> 0 then
^				e = txcom.dll9001.switch.back.to.company(
^						COMP)
^			endif
^			return(txmcs2000.e)
^		endif

	#define RETIFNOK.DYN.SQL(DYN_SQL_ID, ...)
^		txmcs2000.e = ...
^		if txmcs2000.e <> 0 then
^			if DYN_SQL_ID <> 0 then
^				e = sql.close(DYN_SQL_ID)
^				DYN_SQL_ID = 0
^			endif
^			return(txmcs2000.e)
^		endif

	#define	RETIFNOK.DYN.SQL.COMP(COMP,DYN_SQL_ID,...)
^		txmcs2000.e = ...
^		if txmcs2000.e <> 0 then
^			if COMP <> 0 and DYN_SQL_ID <> 0 then
^				sql.close(DYN_SQL_ID)
^				DYN_SQL_ID = 0
^				e = txcom.dll9001.switch.back.to.company(
^						COMP)
^			endif
^			return(txmcs2000.e)
^		endif								

#define	PROP_NAME_SALESPRICE_AMOUNT			"ln.SalesPriceAmount"	
#define	PROP_NAME_SAFETY_LEAD_TIME			"ln.SafetyLeadTime"	
#define PROP_NAME_SERVICE_LEVEL_PERCENTAGE		"ln.ServiceLevelPercentage"

#define UNIT_CASE(X)	case "##X##":
^		if hold.##X## = tcpeun.no or
^		   (i.update.status = add.set and hold.##X## = tcpeun.stop) then
^		   	error.occur = true
^		endif
^		break

|* Get the cluster segment
#define GET.PLAN.ITEM.CLUSTER( plan.item )
^	txcom.dll9001.get.plan.item.cluster( plan.item )

	#define	CHECK_EFFECTIVE_DATE(ref.start.date, ref.finish.date )
^	cprpd730.effd <= :ref.finish.date and
^	(cprpd730.expd > :ref.start.date or cprpd730.expd = 0)

	#define IS.EQ(VALUE1,VALUE2)
^		(txmcs.dll9001.double.cmp.equal.to(
^					domainof(##VALUE1##),
^					"",
^					##VALUE1##,
^					##VALUE2##))

	#define IS.NEQ(VALUE1,VALUE2)
^		(not txmcs.dll9001.double.cmp.equal.to(
^					domainof(##VALUE1##),
^					"",
^					##VALUE1##,
^					##VALUE2##))

	#define LESS.EQ(VALUE1,VALUE2)
^		(txmcs.dll9001.double.cmp.less.equal(
^					domainof(##VALUE1##),
^					"",
^					##VALUE1##,
^					##VALUE2##)) 

|* Convert time, in tctmhs format, to seconds
	#define TMHS_TO_SECONDS( i.time )
^ 		txccp.dll9001.tmhs.to.seconds(i.time)

#define	LOGIC_ERR	-1
	         extern	domain	tcmcs.st30m	zoom.start.method	
	extern	domain	tcmcs.st30m	zoom.start.filter	
	extern	domain	tcncmp		zoom.company
	extern	domain	tcemm.ctyp	zoom.company.type.stack(1) based
	extern		long		zoom.nr.company.types.in.stack
	extern		boolean		zoom.hide.archive.companies
|	extern		string		e.line(LENGTH_LINE)
	boolean				g.reshuffle.cache
|	string			dummy.parm.string(PARM_STRING)
	extern	boolean 	asserts.initialized
	extern	boolean		asserts.active
	extern	boolean		asserts.display
	extern  string		assert.error.file(32)	|* for tracing
	extern	long		assert.error.line	|* for tracing
	static	domain	tcncmp		g.company
	static	domain	tcccty		g.country
	static	domain	tcict2		g.iso.code.alpha2
	boolean		force.description.read
	domain	tcdsca			g.description
	domain	tcncmp		cache.comp(MAX_CACHE)
	domain	tcdesc		cache.desc(MAX_CACHE)
	long		last.index
	
	domain	tcbool		object.valid
	domain	tcbool		return.now
	domain	tcuef.obje  	object.key
	domain	tcbool		object.key.ok
	
	boolean		g.clear.cache.all.item.ordering.data
	domain	tcosys		g.ibd200.osys	|* Order System
	domain	tccwar		g.ibd200.cwar	|* Warehouse
	domain	tcitem		g.ibd200.item	|* Item
	domain	tcncmp		g.comp
	domain	tccwoc		g.cwoc
	domain	tcdsca		g.dsca
	boolean		g.work.center.is.valid
	
	extern	domain	tcmcs.long	pd.sequence.no
	
	long		last.company

	extern	domain	tcncmp		pd.company
	extern	domain	tcyesno		pd.box.msg.flag
	extern	domain	tcyesno		pd.box.msg.hd
	extern	domain	tcyesno		pd.box.msg.ft
		extern	domain	tcyesno		pd.error.flag
	extern	domain	tcyesno		pd.error.header
	extern	domain	tcyesno		pd.error.field
	extern	domain	tcyesno		pd.error.more.fld
	extern	domain	tcyesno		pd.error.id
	extern	domain	tcyesno		pd.error.more.id
	extern	domain	tcyesno		pd.error.text.hd
	extern	domain	tcyesno		pd.error.text
	extern	domain	tcyesno		pd.error.empty.ln
	extern	domain	tcmcs.str70m	pd.report.desc
	extern	domain	tcbod.mode	pd.mode
	extern	domain	tcmcs.str4	pd.bod.pack.vers
	extern	domain	tcbod.svrs	pd.schema.version
	domain tcncmp	curr.company
	
static		long		s.g.bods.in.stack
static		boolean		s.g.metadata.cached

static	domain	bobod.name	s.g.name.stack(1)	based
	static	domain	bobod.impl	s.g.identifier.stack(1) based
	static		long		s.g.visibility.stack(1) based
	static	domain	bobod.type	s.g.type.stack(1)	based
	static	domain	boyesno		s.g.support.ae.stack(1) based
	static	domain	bobod.name	s.g.parent.bod.stack(1)	based
	static	string			s.g.parm.stack(1,1)	based
								|#2043711.sn
	static		long		s.g.receive.verbs.stack(1)	based
	static		long		s.g.send.verbs.stack(1)		based
	static	domain	boyesno		s.g.bod.release.stack(1) 	based
								
	static		long		s.g.position
	static		long		s.g.cust.position
	
|	static	domain	boncmp		s.g.company	

long		g.companies( MAX_CACHE )
	domain	cpitem		g.plan.items( MAX_CACHE )
	domain	cpcom.plvl	g.plan.levels( MAX_CACHE )
	domain	cprpd.plit	g.plan.item.types( MAX_CACHE )
	domain	tccwar		g.warehouses( MAX_CACHE )		fixed
	domain	tcemno		g.planners( MAX_CACHE )			fixed
	domain	tcitem		g.items( MAX_CACHE )			fixed
	domain	tcyesno		g.planned.by.planners( MAX_CACHE )
	domain	cpcom.rpun	g.master.plan.units( MAX_CACHE )
	domain	cpcom.calh	g.forecast.time.fences( MAX_CACHE )
	domain	cpcom.hori	g.order.horizons( MAX_CACHE )
	domain	cpvmi.role	g.vmi.role(MAX_CACHE)		|#800-155923.n
	domain	cprpd.sour	g.default.source(MAX_CACHE)	|#BODtcibd501.sn
	domain	cpcom.hori	g.planning.horizon(MAX_CACHE)
	domain	tcwttm		g.time.fences( MAX_CACHE )	|#LND-703.sn
	domain	tctope		g.time.fence.units( MAX_CACHE )
	domain	tcyesno		g.use.time.fences( MAX_CACHE )	|#LND-703.en
	domain	cpcom.cato	g.extra.lead.time(MAX_CACHE)
	domain	tctope		g.extra.lead.time.unit(MAX_CACHE)
	domain	cpcom.yeno	g.has.masterplans( MAX_CACHE )
	domain	cpcom.hori	g.fixed.lead.times(MAX_CACHE)
	domain	cpcom.yeno	g.critical.in.ctp(MAX_CACHE)	|#1454537.n
	domain	cpcom.yeno	g.online.atp.update(MAX_CACHE)	|#1828637.n
	domain	cpcom.yeno	g.channel.atp( MAX_CACHE )
	domain	cpcom.yeno	g.family.atp( MAX_CACHE )
	domain	cpcom.yeno	g.component.atp( MAX_CACHE )
	domain	cpcom.yeno	g.capacity.atp( MAX_CACHE )

	domain	cpcom.hori	g.ctp.horizons( MAX_CACHE )	|#234723.n
	domain	cpcom.hori	g.ctp.timefences( MAX_CACHE )	|#234723.n
								|#1641634.sn
	domain	tcncmp		g.family.sites(MAX_CACHE)
	domain	cpitem		g.family.items(MAX_CACHE)
	domain	cpcom.hori	g.family.ctp.horizons(MAX_CACHE)
								|#1641634.en
	domain	cprpd.uatt	g.use.att.lead.time( MAX_CACHE )|#lnd-1978.sn
	domain	cpcom.ldtm	g.att.lead.time( MAX_CACHE )
	domain	tcwttm		g.att.multiplier( MAX_CACHE)	|#lnd-1978.en
	domain	cpcom.yeno	g.dependent.demand.fcst( MAX_CACHE )
	domain	cpcom.phnu	g.order.phase.no( MAX_CACHE )
	domain	cpcom.phnu	g.master.phase.no( MAX_CACHE )	|#1486608.n
	domain	cpcom.hori	g.cache.psho( MAX_CACHE )	|#LND2-809.n
	domain 	tccdsc		g.fixed.delivery.code( MAX_CACHE )|#LND-2761.n

	long		tcuefdll0001.eopt.nr.rows
		long		tcuefdll0001.eopt.nr.rows.allocated
	domain	tcuef.eopt	tcuefdll0001.eopt(1)		based
		long		tcuefdll0001.nr.eff.units(1)	based

	
|********************************External Functions*****************************

function extern long txbod.dll9002.xml.get.node.value(	long	i.node,
					domain	tcmcs.s512m	i.path.name,
				ref	domain	tcmcs.s512m	o.node.value)
{
	DllUsage
	Expl:	This function gets the data from i.node.name
	Pre:	n.a.
	Post:	n.a.
	Input:	i.node		- the xml node to search in
		i.path.name	- the xml node path e.g.
				  "<Shipment><ShipmentHeader><DocumentID><ID>"
	Output:	o.node.value	- value of this node
	Return:	0		- Err, data is not found
		> 0		- OK, data is found and stored
	OLD DLL : tcbod.dll0001.xml.get.node.value
	EndDllUsage

|*OBSOLETE

	long	l.node
	long	l.retval
	
	l.node = 0
	l.retval = 0

	if	i.path.name(1;1) <> "?" then
		i.path.name = "?" & i.path.name
	endif

	o.node.value = ""

	|* Find the node which matches the pattern "i.path.name"
	l.node = xmlFindFirstMatch(i.path.name, i.node)

	|* Get the value of this node
	l.retval = xmlGetData(l.node, o.node.value)

	return(l.retval)
}

function extern long txbod.dll9002.convert.from.iso.date.to.erp(
				domain	tcmcs.str20	i.iso.date,
			ref	domain	tcdate		o.erp.date)
{
	DllUsage
	Expl	: This function converts the ISO date to an ERP date.
	Pre:	: -
	Post:	: -
	Input:	: i.iso.date
	Output	: o.erp.date
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0031.convert.from.iso.date.to.erp
	EndDllUsage
	
	domain	tcdate 	l.utc
	 long 	l.yearno  
	 long 	l.monthno  
	 long 	l.month_dayno  
	 long 	l.hours  
	 long 	l.minutes  
	 long 	l.seconds 
	 long	l.ret
	
	if pos(i.iso.date, "T") > 0 then
		|* VAL_RETIFNOK(tlbct.interface.string.to.utc(	i.iso.date,
		|*					o.erp.date))
		o.erp.date = iso.to.utc(i.iso.date)  					
	else
		|* VAL_RETIFNOK(tlbct.interface.string.to.date(i.iso.date,
		|* 					o.erp.date))
		l.utc = iso.to.utc(i.iso.date) 
		l.ret = utc.to.date  (l.utc,l.yearno,l.monthno,l.month_dayno,l.hours,l.minutes, l.seconds)
		o.erp.date = date.to.num  (l.yearno, l.monthno, l.month_dayno)				
	endif

	return(0)
}

function extern long txbod.dll9002.new.data.element(
				const	string	i.tag,
				const	string	i.data,
				ref	long	o.node,
      			 [	long	i.parent.node] )
{
	DllUsage
	Expl:	The purpose of this function is to create a new data node.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.tag
		i.data
	Output:	o.node
	Input:	i.parent.node	- Optional
	Return:	0/DALHOOKERROR
	OldDLLUsed: bobod.dll1043.new.data.element
	EndDllUsage

	if get.argc() = 4 then
		i.parent.node = get.long.arg(4)
	else
		i.parent.node = 0
	endif

	o.node = xmlNewDataElement( i.tag, i.data, i.parent.node )

	if o.node = 0 then
		dal.set.error.message(
			"@Function xmlNewDataElement() failed for tag " & i.tag)

		return( DALHOOKERROR )
	endif

	return( 0 )
}

function extern long txbod.dll9002.new.node(
				const	string	i.tag,
				ref	long	o.node,
       			[	long	i.parent.node] )
{
	DllUsage
	Expl:	The purpose of this function is to create a new node.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.tag
	Output:	o.node
	Input:	i.parent.node	- Optional
	Return:	0/DALHOOKERROR
	OldDLLUsed: bobod.dll1043.new.node
	EndDllUsage

	if get.argc() = 3 then
		i.parent.node = get.long.arg(3)
	else
		i.parent.node = 0
	endif

	o.node = xmlNewNode( i.tag, XML_ELEMENT, i.parent.node )

	if o.node = 0 then
		dal.set.error.message(
			"@Function xmlNewNode() failed for tag " & i.tag )

		return( DALHOOKERROR )
	endif

	return( 0 )
}

function extern long txbod.dll9002.set.attribute(
				const	long	i.node,
				const	string	i.attribute,
				const	string	i.data )
{
	DllUsage
	Expl:	The purpose of this function is to add a specified attribute to
		a specified node.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.node
		i.attribute
		i.data
	Output:	N.a.
	Return:	0/DALHOOKERROR
	OldDLLUsed: bobod.dll1043.set.attribute
	EndDllUsage

	long	return.value
	string	b.tag(1) based

	#define	INIT_SET_ATTRIBUTE
^		free.mem( b.tag )

	#define	ERROR_SET_ATTRIBUTE( i_RETURN_VALUE )
^		if i_RETURN_VALUE <> 0 then
^			END_SET_ATTRIBUTE( i_RETURN_VALUE )
^		endif

	#define	END_SET_ATTRIBUTE( i_RETURN_VALUE )
^		INIT_SET_ATTRIBUTE
^		return( i_RETURN_VALUE )

	INIT_SET_ATTRIBUTE

	if xmlSetAttribute( i.node, i.attribute, i.data ) = 0 then
		return.value = alloc.name( i.node, b.tag ) |* Ref

		ERROR_SET_ATTRIBUTE( return.value )

		dal.set.error.message(
			"@Function xmlSetAttribute() failed for XML " & b.tag &
			" and attribute " & i.attribute & "=" & i.data )

		ERROR_SET_ATTRIBUTE( DALHOOKERROR )
	endif

	END_SET_ATTRIBUTE( 0 )
}


function extern txbod.dll9002.before.checks.logical.ids.field(
	const	string	i.domain.logical.ids.field,
	ref	string	io.logical.ids )
{
	DllUsage
	Expl:	This function manipulates the field 'Logical ID(s)' after input
		by the user if the input is not correct.

		A comma is added before 'lid://', if missing. If comma's are
		added and the 'Logical IDs' exceeds the maximum length, the
		last 'Logical ID(s)' are removed.
	Pre:	N.a.
	Post:	Function only applicable for program scripts, because tools
		function 'mess(...)' is used.
	Input:	i.domain.logical.ids.field
	In/Out:	io.logical.ids
	Output:	N.a.
	Return:	N.a.
	OLD DLL:tcbod.dll0006.before.checks.logical.ids.field
	EndDllusage

	long	length.domain
	long	length.logical.ids
	long	position
	long	dummy.value
	long	dummy.convert
	long	nr.logical.ids
	string	b.logical.ids(1) based
         
         length.domain = 0     
	length.logical.ids = 0 
	position = 0
	dummy.value = 0       
	dummy.convert  = 0    
	nr.logical.ids = 0    
         
	length.logical.ids = len( trim$( io.logical.ids ))

	|* Check if field 'Logical ID(s)' is filled. Further processing can be
	|* stopped if no Logical ID(s) are specified.
	if length.logical.ids = 0 then
		|* No Logical ID(s) specified.
		return	|* Early return
	endif

	|* Get the maximum length of field 'Logical ID(s), based on the domain.
	if rdi.domain.string(
			i.domain.logical.ids.field,
			length.domain,				|* Ref
			dummy.convert ) <> 0 then	|* Ref
		mess( "txbods0039", 1, i.domain.logical.ids.field )
		|* txbods0039  ???

		return
	endif

	|* Get the number of specified Logical ID(s).
	nr.logical.ids = get.number.of.logical.ids( io.logical.ids )

	|**********************************************************************
	|* Replace 'lid://' by ',lid://' (except first position).
	|**********************************************************************
	|* Allocate memory for Logical ID(s) with comma's.
	dummy.value = alloc.mem(
			b.logical.ids,
			length.logical.ids + nr.logical.ids )

	b.logical.ids = trim$( io.logical.ids )

	|* Remove all commas before 'lid://'.
	b.logical.ids = str.replace$(
				trim$( b.logical.ids ),
				"," & PD_PREFIX_LOGICAL_ID,
				PD_PREFIX_LOGICAL_ID )

	|* Insert a comma before 'lid://'.
	b.logical.ids = str.replace$(
				trim$( b.logical.ids ),
				PD_PREFIX_LOGICAL_ID,
				"," & PD_PREFIX_LOGICAL_ID )

	|* Remove comma at first position.
	if str.startswith( b.logical.ids, "," ) then
		b.logical.ids = b.logical.ids(2)
	endif

	|* If the maximum length of the domain is exceeded, remove Logical ID(s)
	|* at the end of the string.
	if len( b.logical.ids ) > length.domain then
		|* Remove Logical ID(s) if last position of the string is not
		|* last position of a Logical ID.
		if b.logical.ids( length.domain + 1) <> "," then
			 |* Remove Logical ID(s)
			position = rpos(
					b.logical.ids,
					"," & PD_PREFIX_LOGICAL_ID )

			b.logical.ids = b.logical.ids(1;position - 1)
		endif
	endif

	io.logical.ids = b.logical.ids

	free.mem( b.logical.ids )
}

function extern txbod.dll9002.before.choice.choice.cont.process(
		domain	tcbod.mode	i.mode,
	const	domain	tcyesno		i.bod.visible.stack(),
	const	domain	tcyesno		i.bod.subscription.stack(),
					... )
{
	DllUsage
	Expl:	The purpose of this function it to handle the
		'choice.cont.process' section of the UI.

		If no BOD is selected for publishing an error message is given.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.mode
		i.bod.visible.stack
		i.bod.subscription.stack
		...	- UI macro ARGUMENT_LIST_BODS
	Output:	N.a.
	Return:	0/DALHOOKERROR
	OLD DLL : tcbod.dll0006.before.choice.choice.cont.process
	EndDllusage

		long	l.bod.no
		long	l.argument.no
		long	l.argument.no.first.bod
		long	l.argument.no.select
		boolean	l.bod.selected
	domain	tcyesno	selected

	l.bod.no  = 0             
	l.argument.no  = 0        
	l.argument.no.first.bod = 0
	l.argument.no.select = 0 
	l.bod.selected = false       
	
	l.argument.no.first.bod = 4
	

	|* Check if a BOD is selected for publishing.
	for l.argument.no = l.argument.no.first.bod to get.argc()
						step PD_NR_BOD_ARGUMENTS
		INC( l.bod.no )
		l.argument.no.select = PD_ARG_NO_PB_FIELD( l.argument.no )

		txbod.dll9002.handle.pb.field(
			GET_VALUE,
			get.string.arg( l.argument.no.select ),
			selected )	|* Ref

		if txbod.dll9002.do.publish.data.bod(
				i.mode,
				i.bod.visible.stack(l.bod.no),
				i.bod.subscription.stack(l.bod.no),
				selected ) then
			l.bod.selected = true

			|* BOD selected for publishing found.
			|* Further processing can be stopped.
			break
		endif
	endfor

	if not l.bod.selected then
		mess( "tcbods0006", 1 )
		|* tcbods0006  ???

		choice.again()
	endif
}

function extern txbod.dll9002.handle.pb.field(
			long	i.method,
	const		string	i.select.field,
	ref	domain	tcyesno	io.selected )
{
	DllUsage
	Expl:	The purpose of this function is to set or read a publish select
		field.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.method	- SET_VALUE / GET_VALUE
		i.select.field
	In/out:	io.selected	- Yes/ No
	Output:	N.a.
	Return:	N.a.
	OLD DLL : tcbod.dll0006.handle.pb.field
	EndDllusage

	long	l.expression.id
	long	l.dummy.return
	
	l.dummy.return = 0
	l.expression.id = 0

	on case i.method
	case GET_VALUE:
		l.expression.id = expr.compile(
				"e.pb.field := " & trim$( i.select.field ))

		io.selected = ltoe( l.expr( l.expression.id ))

		break
	case SET_VALUE:
		l.expression.id = expr.compile(
				trim$( i.select.field ) & " := " &
				str$( io.selected ))

		l.dummy.return = l.expr( l.expression.id )

		break
	endcase

	free.mem( l.expression.id )
}

function extern boolean txbod.dll9002.do.publish.data.bod(
	domain	tcbod.mode	i.mode,
	domain	tcyesno		i.visible,
	domain	tcyesno		i.subscription,
	domain	tcyesno		i.selected )
{
	DllUsage
	Expl:	The purpose of this function is to check if based on BOD
		properties, data must be published.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.mode
		i.visible
		i.subscription
		i.selected
	Output:	N.a.
	Return:	True	- Do publish data.
		False	- Do not publish data.
	OLD DLL : tcbod.dll0006.do.publish.data.bod
	EndDllusage

	if i.visible = tcyesno.yes and
	   i.selected = tcyesno.yes then
		|* BOD is visible on screen and selected to publish.

		on case i.mode
		case PD_MODE_COUNT:
		case PD_MODE_SIMULATE:
			|* Always execute publish logic.
			return( true )
		case PD_MODE_PUBLISH:
			|* Only execute publish logic if bod is visible and
			|* subscription is present.
			if i.subscription = tcyesno.yes then
				return( true )
			endif

			break
		endcase
	endif

	return( false )
}

function extern txbod.dll9002.before.display.object(
		domain	tcbod.mode	i.mode,
		domain	tcclsv		i.log.location,
	const	domain	tcmcs.str18	i.log.subject.field.name,
	const	domain	tcmcs.str18	i.log.directory.field.name )
{
	DllUsage
	Expl:	The purpose of this function is to handle the
		'before.display.object' section of the UI.

		- Based on field 'Mode', the available options of field 'Output'
		  for BOD logging are set.
		- Based on the UI mode and the log location, field log directory
		  is visible or invisible.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.mode
		i.log.location
		i.log.subject.field.name
		i.log.directory.field.name
	Output:	N.a.
	Return:	0/DALHOOKERROR
	DLL Usage: tcbod.dll0006.before.display.object
	EndDllusage

	set.use.client.download.for.zipped.log.file( i.log.location )

	set.enum.values.for.log.subject(
		i.mode,
		i.log.subject.field.name )

	set.field.log.directory( i.log.directory.field.name )
}

function extern txbod.dll9002.before.zoom.company.field(
			boolean	i.hide.archive.companies,
	ref	domain	tcncmp	io.company )
{
	DllUsage
	Expl.:	This function can be used in the 'before.zoom' section of the
		field 'Company' (From/To) in the publish data (initial load)
		sessions.

		The function starts the session 'Companies' (tcemm1170m000) and
		the selected company will be returned.
	Pre:	N.a.
	Post:	Variable 'attr.zoom.code' is '0'.
	Input:	i.company
		i.hide.archive.companies	- True/false
	In/Out:	N.a.
	Output:	N.a.
	Return:	Selected company number
	OLD DLL: tcbod.dll0006.before.zoom.company.field
	EndDllusage

	domain	tcncmp	l.dummy.company

	attr.zoomcode = 0

	l.dummy.company = start.companies(
				io.company,	|* Ref
				i.hide.archive.companies )
}
function extern txbod.dll9002.before.zoom.log.directory(
		domain	tcclsv	i.location,
	ref		string	o.directory )
{
	DllUsage
	Expl:	The purpose of this function is to handle the 'before.zoom'
		section of the 'Directory' field.

		If 'Client' is selected as location for the output, a dialog
		box of the local system is started.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.location
	Output:	o.directory
	Return:	N.a.
	OLD DLL: tcbod.dll0006.before.zoom.log.directory
	EndDllusage

	if i.location = PD_CLIENT then
		get.directory( o.directory )	|* Ref
	endif

	input.again()
}

function extern txbod.dll9002.check.input.company.field(
	const		long		i.current.company,
	const		long		i.switch.to.company )
{
	DllUsage
	Expl:	This function can be used in the 'check.input' section of the
		field 'Company' (From and To) in the publish data (initial load)
		sessions.

		The function checks if it possible to switch to a specified
		company and back again. If not, an error will be set.
	Pre:	Function only applicable for 'check.input' section of program
		script, because tools function 'set.input.error(...)' is used.
	Post:	N.a.
	Input:	i.from.company
		i.to.company
	Output:	N.a.
	Return:	N.a.
	OLD DLL: tcbod.dll0006.check.input.company.field
	EndDllusage

	|* Check if switch to company is possible.
	if i.current.company <> i.switch.to.company then
		if txbod.dll9002.switch.to.company(
				i.switch.to.company,
				true ) <> 0 then	|* Show error message
			set.input.error( "" )
		endif

		|* Switch back to 'From' company.
		if txbod.dll9002.switch.to.company(
				i.current.company,
				true ) <> 0 then	|* Show error message
			set.input.error( "" )
		endif
	endif
}

function extern long txbod.dll9002.switch.to.company(
	domain	tcncmp	i.company,
		boolean	i.show.error.message )
{
	DllUsage
	Expl:	This function
	Pre:	N.a.
	Post:	Function only applicable for program scripts, because tools
		function 'mess(...)' is used.
	Input:	i.company
	Output:	N.a.
	Return:	0/DALHOOKERROR
	OLD DLL:tcbod.dll0006.switch.to.company
	EndDllusage

		long		l.return.value
	domain	tcmcs.s300m	l.error.message
	
		l.return.value = 0
		l.error.message = ""
		
	l.return.value = txcom.dll9001.switch.to.company( i.company )

	if l.return.value <> 0 and
	   i.show.error.message then
		|* An error occurred. Show error messages.
		while dal.get.error.message( l.error.message ) <> - 1
			mess( "tcgenstring", 1, l.error.message )
			|* tcgenstring  ???
		endwhile
	endif

	return( l.return.value )
}

function extern txbod.dll9002.check.input.simulation.size(
	domain	tcbod.mode	i.mode,
		long		i.simulation.size )
{
	DllUsage
	Expl:	This function can be used in the 'check.input' section of the
		field 'Size' in the publish data (initial load) sessions.

		If mode is 'Simulate' and variable 'i.simulation.size' is < 0,
		an error will be set.
	Pre:	Function only applicable for 'check.input' section of program
		script, because tools function 'set.input.error(...)' is used.
	Post:	N.a.
	Input:	i.mode
		i.simulation.size
	Output:	N.a.
	Return:	N.a.
	OLD DLL: tcbod.dll0006.check.input.simulation.size
	EndDllusage

	if i.mode = PD_MODE_SIMULATE and
	   i.simulation.size < 0 then
		set.input.error(
			"txgen.zero1",
			|* txgen.zero1  ???
			tt.label.desc( "tctcgen.size", ttadv.cont.general ))
			|* tctcgen.size  ???
	endif
}

function extern long txbod.dll9002.finish.publish.data(
	long	i.report.id )
{
	DllUsage
	Expl:	This function finishes the publishing of data, even if no
		companies are selected or publishing is cancelled by the user.

		1. The publishing report will be closed.
		2. If the actual company differs from the specified company, the
		   program will switch to the specified company.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.company
		i.repord.id
	Output:	N.a.
	Return:	0/DALHOOKERROR
	OLD DLL : tcbod.dll0006.finish.publish.data
	EndDllusage

	if i.report.id > 0 then
		brp.close(i.report.id )
	endif

	if get.show.progress.indicator() then
		destroy.progress.indicator()
	endif

	return( 0 )
}

function extern txbod.dll9002.set.maintainability.dependent.group(
			long		i.type,
		domain	tcbod.mode	i.mode,
	const	domain	tcyesno		i.bod.visible.stack(),
	const	domain	tcyesno		i.bod.subscription.stack(),
			long		i.group.number,
	const		string		i.pb.fields(),
					... )
{
	DllUsage
	Expl:	The purpose of this function is to disable or enable a
		specified group if publishing of a list of BOD publishing
		fields is not applicable.
		are
	Pre:	N.a.
	Post:	N.a.
	Input:	i.type
		i.mode
		i.bod.visible.stack
		i.bod.subscription.stack
		i.group.number
		i.pb.fields
		...	- Publish BOD select fields (fields with prefix 'pb.').
	Output:	N.a.
	Return:	0/DALHOOKERROR
	OLD DLL:tcbod.dll0006.set.maintainability.dependent.group
	EndDllusage

		long	l.bod.no
		long	l.argument.no
		long	l.argument.no.first.bod
		long	l.argument.no.pb.field
		string	l.pb.field(LENGTH_FIELD)
		boolean	l.do.disable.group
	domain	tcyesno	l.selected

	l.argument.no.first.bod = 7

	l.bod.no = 0
	l.do.disable.group = true

	for l.argument.no = l.argument.no.first.bod to get.argc()
						step PD_NR_BOD_ARGUMENTS
		INC( l.bod.no )
		l.argument.no.pb.field = PD_ARG_NO_PB_FIELD( l.argument.no )
		l.pb.field = trim$( get.string.arg( l.argument.no.pb.field ))

		txbod.dll9002.handle.pb.field( GET_VALUE, l.pb.field, l.selected )
			|* Ref: selected

		if pos(	i.pb.fields, l.pb.field ) > 0 and
		   txbod.dll9002.do.publish.data.bod(
				i.mode,
				i.bod.visible.stack(l.bod.no),
				i.bod.subscription.stack(l.bod.no),
				l.selected ) then
			|* - 'pb'-field is one of the specified 'pb'-fields.
			|* - BOD data must be published.

			|* Do not disable group.
			|* More checks can be skipped.
			l.do.disable.group = false

			break
		endif
	endfor

	if l.do.disable.group then
		disable.group( i.group.number, i.type )
	else
		enable.group( i.group.number )
	endif
}

function extern txbod.dll9002.set.maintainability.logging(
	domain	tcbod.mode	i.mode,
	domain	tcbod.slog	i.log.subject,
	domain	tcmcs.str18	i.logging.field.name,
	domain	tcmcs.str18	i.log.subject.field.name,
	domain	tcmcs.str18	i.log.single.xml.field.name,
	domain	tcmcs.str18	i.log.location.field.name,
	domain	tcmcs.str18	i.log.directory.field.name )
{
	DllUsage
	OLD DLL:tcbod.dll0006.set.maintainability.logging
	EndDllusage

	if logging.is.supported.by.mode( i.mode ) then
		|* Enable all logging fields, except field 'log.single.xml'.
		enable.fields(
			i.logging.field.name,
			i.log.subject.field.name,
			i.log.location.field.name,
			i.log.directory.field.name )

		|* Availability of field 'log.single.xml' is dependent of field
		|* 'log.subject'.
		|* Field 'log.single.xml' must be maintainable if field
		|* 'log.context' is set to 'BOD'.
		if i.mode = PD_MODE_SIMULATE and
		   i.log.subject = LOG_BOD then
			enable.fields( i.log.single.xml.field.name )
		else
			disable.fields( i.log.single.xml.field.name )
		endif

		|* Set list values for field 'log.subject'.
		set.enum.values.for.log.subject(
			i.mode,
			i.log.subject.field.name )
	else
		|* Disable all logging fields.
		disable.fields(
			i.logging.field.name,
			i.log.subject.field.name,
			i.log.single.xml.field.name,
			i.log.location.field.name,
			i.log.directory.field.name )
	endif
}

function extern txbod.dll9002.set.pb.select.fields(
			long		i.method,
		domain	tcbod.mode	i.mode,
	const	domain	tcyesno		i.bod.visible.stack(),
			long		i.nr.bods.in.stack,
					... )
{
	DllUsage
	Expl:	This function
	Pre:	N.a.
	Post:	N.a.
	Input:
	Output:	N.a.
	Return:	0/DALHOOKERROR
	OLD DLL:tcbod.dll0006.set.pb.select.fields
	EndDllusage

		long	l.bod.no
		long	l.argument.no.select
		long	l.nr.arguments
		long	l.argument.no
		long	l.argument.no.first.bod
	domain	tcyesno	l.selected

	l.argument.no.first.bod = 5

	l.nr.arguments = get.argc()
	l.bod.no = 0

	on case i.method
	case PD_SELECT_ALL:
		l.selected = tcyesno.yes

		break
	case PD_CLEAR_ALL:
		l.selected = tcyesno.no

		break
	endcase

	for l.argument.no = l.argument.no.first.bod to l.nr.arguments
						step PD_NR_BOD_ARGUMENTS
		INC( l.bod.no )

		|* Set field to 'Yes', if BOD is visible.
		if txbod.dll9002.do.publish.data.bod(
				i.mode,
				i.bod.visible.stack(l.bod.no),
				tcyesno.yes,		|* Subscription present
				tcyesno.yes ) then	|* Select to publish
			l.argument.no.select =
				PD_ARG_NO_PB_FIELD( l.argument.no )

			txbod.dll9002.handle.pb.field(
				SET_VALUE,
				get.string.arg( l.argument.no.select ),
				l.selected )
		endif
	endfor
}

function extern txbod.dll9002.set.settings.fields(
		domain	tcbod.mode	i.mode,
		domain	tcbod.uvrb	i.use.verb,
		domain	tcmcs.str18	i.use.verb.field,
		domain	tcmcs.str18	i.logical.ids.field,
	ref	domain	tcmcs.str215	io.logical.ids )
{
	DllUsage
	Expl:	This function sets the maintainability of the settings fields.

		- Field 'Use Verb' is available if mode is 'Simulate' or
		  'Publish'.
		- Field 'Logical ID(s)' is available if mode is 'Simulate' or
		  'Publish' and field 'Use Show Verb' is selected.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.mode
		i.use.verb
		i.use.verb.field
		i.logical.ids.field
	In/out:	o.logical.ids
	Out:	N.a.
	Return:	0/DALHOOKERROR
	OLD DLL:tcbod.dll0006.set.settings.fields
	EndDllusage

	if i.mode = PD_MODE_COUNT then
		|* Disable all settings fields if mode is 'Count'.
		disable.fields( i.use.verb.field, i.logical.ids.field )
	else
		|* Enable field 'Use Verb' if mode is 'Process' or 'Sync'.
		enable.fields( i.use.verb.field )

		if i.use.verb = PD_USE_VERB_SHOW then
			|* Enable field 'Logical IDs' if 'Use Show Verb' is
			|* selected.
			enable.fields( i.logical.ids.field )

			if isspace( io.logical.ids ) then
				io.logical.ids =
					PD_PREFIX_LOGICAL_ID &
					"," &
					PD_PREFIX_LOGICAL_ID
			endif
		else
			disable.fields( i.logical.ids.field )
		endif
	endif
}

function extern txbod.dll9002.when.field.changes.log.location(
	domain	tcclsv		i.log.location,
	domain	tcmcs.str18	i.log.directory.field.name )
{
	DllUsage
	Expl:	The purpose of this function is to handle the
		'when.field.changes' section of the 'Location' field.

		If in HTML5 UI, field 'Location' is set to 'Client', field
		'Directory' is invisible. Otherwise, the field is visible.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.log.location
		i.log.directory.field.name
	Output:	N.a.
	Return:	N.a.
	OLD DLL: tcbod.dll0006.when.field.changes.log.location
	EndDllusage

	set.use.client.download.for.zipped.log.file( i.log.location )

	set.field.log.directory( i.log.directory.field.name )
}


function extern boolean txbod.dll9002.called.from.publish.data.session()
{
	DllUsage
	Expl:	During publishing this function can be used from other scripts
		to check if the current publishing process is started from
		function 'tcbod.dll0006.publish.data(...)'.

		During publishing of data initiated by a publish data session
		the static variable 'called.from.publish.data.session' is set
		to 'true' in function 'tcbod.dll0006.publish.data(...)'.

		For example the function can be used in function
		'tcbod.dll0001.publish.bod(...)'.
	Pre:	N.a.
	Post:	N.a.
	Input:	N.a.
	Output:	N.a.
	Return:	0/DALHOOKERROR
	OLD DLL: tcbod.dll0006.called.from.publish.data.session()
	EndDllusage

	boolean	l.called.from.publish.data.session

	handle.hold.called.from.publish.data.session(
		GET_VALUE,
		l.called.from.publish.data.session )	|* Ref

	return( l.called.from.publish.data.session )
}

function extern boolean txbod.dll9002.publish.show.bods()
{
	DllUsage
	Expl:	During publishing this function can be used from other scripts
		to check if BODs must be published with verb 'Show'.

		During publishing of data initiated by a publish data session
		the static variable 'use.verb' is set in function
		'tcbod.dll0006.prepare.publish.data(...)'.

		For example the function can be used in function
		'tcbod.dll0001.publish.bod(...)'.
	Pre:	Settings are cached.
	Post:	N.a.
	Input:	N.a.
	Output:	N.a.
	Return:	True	- BODs must be published with verb 'Show'.
		False	- BODs must be published with other verb 'Process/Sync'.
	OLD DLL : tcbod.dll0006.publish.show.bods()
	EndDllusage

	domain	tcbod.uvrb	l.use.verb
	domain	tcmcs.str215	l.dummy.logical.ids

	handle.settings( GET_VALUE, l.use.verb, l.dummy.logical.ids )
		|* Ref: use.verb, dummy.logical.ids

	if l.use.verb = PD_USE_VERB_SHOW then
		return( true )
	endif

	return( false )
}
function extern boolean txbod.dll9002.publish.process.sync.bods()
{
	DllUsage
	Expl:	During publishing this function can be used from other scripts
		to check if BODs must be published with verb 'Process' or
		verb 'Sync'.

		During publishing of data initiated by a publish data session
		the static variable 'use.verb' is set in function
		'tcbod.dll0006.prepare.publish.data(...)'.

		For example the function can be used in function
		'tcbod.dll0001.publish.bod(...)'.
	Pre:	Settings are cached.
	Post:	N.a.
	Input:	N.a.
	Output:	N.a.
	Return:	True	- BODs must be published with verb 'Show'.
		False	- BODs must be published with other verb 'Process/Sync'.
	OLD DLL : tcbod.dll0006.publish.process.sync.bods
	EndDllusage

	domain	tcbod.uvrb	l.use.verb
	domain	tcmcs.str215	l.dummy.logical.ids

	handle.settings( GET_VALUE, l.use.verb, l.dummy.logical.ids )
		|* Ref: use.verb, dummy.logical.ids

	if l.use.verb = PD_USE_VERB_PROCESS_SYNC then
		return( true )
	endif

	return( false )
}
function extern txbod.dll9002.set.based.variable(
				const	string	i.value,
				ref	string	o.value() )
{
	DllUsage
	Expl	: This function fills a based variable.

		  The specified string value is not empty if:
		  - The string is allocated.
		    The number of bytes the string can contain is > 0.
		  - The string does not contain only spaces.
	Pre	: -
	Post	: Based on variable 'i.value', memory is alloced for based
		  variable and value is assigned.
	Input	: i.value
	Output	: o.value (based string)
	Return	: -
	OLD DLL : tcbod.dll0038.set.based.variable
	EndDllUsage

	long	l.length
	long	l.dummy.value
	string	l.empty.string

	l.empty.string = ""
	free.mem( o.value )

	l.length = str.sizeof( i.value )

	if l.length = 0 then
		l.dummy.value = alloc.mem( o.value, 1 )

		copy.mem( o.value, l.empty.string )
	else
		l.dummy.value = alloc.mem( o.value, l.length )

		copy.mem( o.value, i.value )
	endif
}

function extern boolean txbod.dll9002.value.is.empty(
				const	string	i.value)
{
	DllUsage
	Expl	: This function checks if a specified string value is empty.

		  The specified string value is empty if:
		  - The string is not allocated.
		    The number of bytes the string can contain is 0.
		  - The string contains only spaces.
	Pre	: -
	Post	: -
	Input	: i.value
	Output	: -
	Return	: true if empty
	OLD DLL : tcbod.dll0038.value.is.empty
	EndDllUsage

	if str.sizeof( i.value ) = 0 or
	   isspace( i.value ) then
		return( true )
	endif

	return( false )
}
function extern boolean txbod.dll9002.value.is.not.empty(
				const	string	i.value )
{
	DllUsage
	Expl	: This function checks if a specified string value is not empty.

		  The specified string value is not empty if:
		  - The string is allocated.
		    The number of bytes the string can contain is > 0.
		  - The string does not contain only spaces.
	Pre	: -
	Post	: -
	Input	: i.value
	Output	: -
	Return	: true if not empty
	OLD DLL : tcbod.dll0038.value.is.not.empty
	EndDllUsage

	if txbod.dll9002.value.is.empty( i.value ) then
		return( false )
	endif

	return( true )
}

function extern txbod.dll9002.check.input.log.directory(
	domain	tcbod.mode	i.mode,
	domain	tcyesno		i.logging,
	domain	tcclsv		i.location,
	domain	tcmcs.s512	i.directory )
{
	DllUsage
	Expl:	The purpose of this function is to handle the 'check.input'
		section of the 'Directory' field.

		If logging is supported:
		- The directory field must be filled.
		- If 'Server' is selected as location for the output, a path
		  separator is added to the directory if not entered.
		- A dummy file is created and deleted to test if the specified
		  location and directory is available.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.mode
		i.logging
		i.location
		i.directory
	Output:	N.a.
	Return:	N.a.
	Old Dll : tcbod.dll0006.check.input.log.directory
	EndDllusage

	domain	tcmcs.s512	l.directory

	if not (i.location = PD_CLIENT ) and
	   get.logging.supported(
			i.mode,
			i.logging ) then
		if isspace( i.directory ) then
			set.input.error( "txbods0133" )
			|* txbods0133  ???
		endif

		if not stp.check.input.error then
			l.directory = convert.directory( i.location, i.directory )

			if not
			   	check.file.creation.possible.in.path(
					i.location,
					l.directory,
					"" ) then
				set.input.error( "tcbods0129", l.directory )
				|* tcbods0129  ???
			endif
		endif
	endif
}



function extern txbod.dll9002.check.input.logical.ids.field(
	const	domain	tcbod.mode	i.mode,
	const	domain	tcncmp		i.company.from,
	const	domain	tcncmp		i.company.to,
	const	domain	tcbod.uvrb	i.use.verb,
	const	domain	tcmcs.str215	i.logical.ids )
{
	DllUsage
	Expl:	This function checks the input of the 'Logical ID(s) field.

		Field 'Logical ID(s) is valid if:
		- Field is filled.
		- Prefix of each 'Logical ID' is 'lid://'
		- length of 'Logical ID' is greater than prefix.
	Pre:	N.a.
	Post:	Function only applicable for program scripts, because tools
		function 'set.input.error(...)' is used.
	Input:	i.mode
		i.company.from
		i.company.to
		i.use.verb
		i.logical.ids
	Output:	N.a.
	Return:	N.a.
	Old Dll : tcbod.dll0006.check.input.logical.ids.field
	EndDllusage

		long		l.return.value
	domain	tcmcs.s300m	l.error.message
	
	l.return.value = 0
	l.error.message = ""
	on case i.mode
	case PD_MODE_COUNT:
		|* Logical ID(s) are not relevant in count mode.
		|* Check input can be skipped.

		break
	default: |* Simulate/Publish
		if check.logical.ids(
				i.company.from,
				i.company.to,
				i.use.verb,
				i.logical.ids ) <> 0 then
			l.return.value = dal.get.error.message( l.error.message )

			set.input.error( "txgenstring", l.error.message )
			|* txgenstring  ???
		endif

		break
	endcase
}

function extern long txbod.dll9002.get.logical.id.company(
			domain	tcncmp		i.company,
		ref	domain	tcbod.loid	o.logical.id)
{
	DllUsage
	Expl	: The purpose of this function is to return the Logical ID of
		  specified company.

		  An '*' is returned if a callback function is set before
		  calling this function.
	Pre	: Output variable 'o.logical.id' is declared as a based variable.
	Post	: Deallocate memory of output variable 'o.logical.id' before new
		  memory is allocated.
	Input	: i.company
	Output	: o.logical.id
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0039.get.logical.id.company
	EndDllUsage

	long				i

	static	long			s.last.position
	static	domain	tcmcs.long	s.cache.counter

	static	domain	tcncmp		s.company(1)		based
	static	domain	tcbod.loid	s.logical.id(1)		based

	static	long			s.tcbod.loid.length
	static	boolean			s.domain.read

	if not s.domain.read then
		s.tcbod.loid.length	= txbod.dll9002.domain.length(
							"tcbod.loid")
		s.domain.read = true
	endif

	for i = 1 to s.last.position
		if s.company(i)	= i.company then
			o.logical.id = s.logical.id(1,i)

			return(0)
		endif
	endfor

	if s.last.position = s.cache.counter then
		s.cache.counter = s.cache.counter + ALLOCATE_SIZE
		if alloc.mem(	s.company,
				s.cache.counter) <> 0 or
		   alloc.mem(	s.logical.id,
				s.tcbod.loid.length,
				s.cache.counter) <> 0 then
			dal.set.error.message( "txbod0001" )
			|* txbod0001  ???

			return( DALHOOKERROR )
		endif
	endif

|t	o.logical.id = esb.admin.get.logicalid.company(i.company)

	if isspace(o.logical.id) then
		dal.set.error.message( "txbods0201", i.company )
		|* txbods0201  ???

		return(DALHOOKERROR)
	endif

	inc(s.last.position)

	s.company(s.last.position)	= i.company
	s.logical.id(1,s.last.position)	= o.logical.id

	return(0)
}

function extern long txbod.dll9002.domain.length(
			string		i.domain.name(18))
{
	DllUsage
	Expl	: Determines length of domain
	Pre	: -
	Post	: -
	Input	: -
	Output	: Returns length
	Old Dll : tccom.dll0015.domain.length
	EndDllUsage

	static		string		s.domain.name(18)
	static	domain	tcmcs.long	s.length.of.domain

			long		l.result

			string		l.dummy.string(1)
			long		l.dummy.long

	if trim$(i.domain.name) = trim$(s.domain.name) then
		return(s.length.of.domain)
	endif

	s.domain.name = i.domain.name

	l.result = rdi.domain(		i.domain.name,
					l.dummy.string,
					l.dummy.string,
					l.dummy.string,
					l.dummy.long,
					l.dummy.string,
					l.dummy.long,
					s.length.of.domain)
	if l.result = -1 then
		s.length.of.domain = 0
		return(0)
	else
		return(s.length.of.domain)
	endif
}

function extern long txbod.dll9002.get.companies(		
	const	domain	tcncmp	i.company.f,
	const	domain	tcncmp	i.company.t,
	ref	domain	tcncmp	o.company.stack(),
	ref		long	o.nr.companies.in.stack )
{
	DllUsage
	Expl:	The purpose of this function is to retrieve the accessible
		companies within the specified range.
		The companies are based on table tcemm170.
		For every company a try is done to switch to the company.
		In case the switch is succesful, the concerning company will
		be added to the internal table.
		Company 000 will not be included.
	Pre:	N.a.	
	Post:	N.a.
	Input:	i.company.f
		i.company.t
	Output: o.company.stack		- List with accessible companies
		o.nr.companies.in.stack
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll0006.get.companies
	EndDllUsage

		long	l.dummy.nr.failed.companies.in.stack
	domain	tcncmp	l.dummy.failed.company.stack(1) based

	|* Get the companies within the specified range.
	if not txbod.dll9002.get.companies1(
			i.company.f,
			i.company.t,
			o.nr.companies.in.stack,
			o.company.stack,			|* Ref
			l.dummy.nr.failed.companies.in.stack,
			l.dummy.failed.company.stack ) then	|* Ref
		|* Error occurred.
		free.mem( l.dummy.failed.company.stack )

		free.mem( o.company.stack )
		o.nr.companies.in.stack = 0

		dal.set.error.message( "txspts0004" )
		|* txspts0004  ???

		return( DALHOOKERROR )
	endif

	free.mem( l.dummy.failed.company.stack )

	return( 0 )
}

function extern boolean	txbod.dll9002.get.companies1(
				domain	tcncmp	i.comp.f,
				domain	tcncmp	i.comp.t,
			ref	long		o.nr.companies,
			ref	domain	tcncmp	o.companies(),
			ref	long		o.nr.companies.err,
			ref	domain	tcncmp	o.companies.err())
{
	DllUsage
	Expl:	This function retrieves the accessible companies.
		The company table tcemm170 is read.
		For every company a try is done to switch to the company.
		In case the switch is succesful, the concerning company will
		be added to the internal table.
		Company 000 will not be included.
	Pre:	output arguments should have been allocated with size
		rdi.domain.long("tcncmp", output digits )
	Post:	-
	Input:	-
	Output: o.companies		- List with accessible companies
		o.companies.err		- List with not accessible
					  companies
	Return:	true  = succesfull, companies may be accessable
			or not accessable
		false = not able to collect companies
	Old Dll : tcbod.dll0001.get.companies
	EndDllUsage

	|* Declaration of local variables.
	long		l.ret.val			|* Return Value.
	long		l.index.comp.list		|* Index in accessible
	long		l.index.comp.list.error	|* Counter
	domain	tcncmp	l.current.company		|* Current (Original) Company.

	#define	ALLOC_SIZE	5

	free.mem(o.companies)
	free.mem(o.companies.err)

	o.nr.companies = 0
	o.nr.companies.err = 0

	l.index.comp.list = 0
	l.index.comp.list.error = 0

	|* Store current company.
	l.current.company = get.compnr()

	select	tcemm170.*
	from  	tcemm170
	where   tcemm170.comp inrange :i.comp.f and :i.comp.t
	and 	tcemm170.comp <> 0
	order by tcemm170._index1
	selectdo
		l.ret.val = switch.to.company(tcemm170.comp)

		if l.ret.val < 0 then
			if o.nr.companies.err\ALLOC_SIZE = 0 then
				alloc.mem(	o.companies.err,
						o.nr.companies.err + ALLOC_SIZE)
			endif

			inc(o.nr.companies.err)
			o.companies.err(o.nr.companies.err) = tcemm170.comp
			|* Not able to access company for various reasons
		else
			if o.nr.companies\ALLOC_SIZE = 0 then
				alloc.mem(	o.companies,
						o.nr.companies + ALLOC_SIZE)
			endif

			inc(o.nr.companies)
			o.companies(o.nr.companies) = tcemm170.comp
		endif
	selectempty
		return(false)
	endselect

	switch.to.company(l.current.company)

	return(true)
}

function extern string txbod.dll9002.get.object.name.function(
	const	string	i.function )
{
	DllUsage
	Expl:	This function returns the object name as extracted from a
		specified function name.

		For example:
		Function:	tssoc.dll1205.<...>
		Object name:	otssocdll1205
	Pre:	N.a.
	Post:	N.a.
	Input:	i.function
	Output:	N.a.
	Return:	Object name
	Old Dll : tcbod.dll0008.get.object.name.function
	EndDllusage

	long	l.first.position
	long	l.second.position

	string	object(15)

	object = "o"

	l.first.position = pos(i.function, ".")
	l.second.position = pos(i.function(l.first.position+1), ".")

	if l.first.position > 1 and
	   l.second.position > 1 then
		object = object &
			 i.function(1;l.first.position-1) &
			 i.function(l.first.position+1; l.second.position-1)
	endif

	return( object )
}

function extern long txbod.dll9002.handle.after.execute.function(
	const	string	i.object,
	const	string	i.function,
		long	i.return.value.exec.function,
	ref	long	io.return.value.function )
{
	DLLUsage
	Expl:	This function checks the return value of variable
		'i.retval.exec.function' (= return value of function
		'exec_function(...)').

		If the return value is 0, the return value of variable
		'io.retval.function' is returned,

		If the return value is not 0, an error message will be set and
		an error will be returned.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.object
		i.function
		i.return.value.exec.function
	In/out:	io.return.value.function
	Output:	N.a.
	Return:	0/DALHOOKERROR
	Old DLL : tcbod.dll0008.handle.after.execute.function
	EndDLLUsage

	long	l.return.value

	l.return.value = i.return.value.exec.function

	on case i.return.value.exec.function
	case -1:
		dal.set.error.message( "txbods0016", trim$( i.object(2) ) )
		|* No unit found for ISO Code %1$s.

		break
	case -2:
		dal.set.error.message( "txbods0017", trim$( i.function ) )
		|* txbods0017  ???

		break
	default:
		l.return.value = io.return.value.function

		break
	endcase

	return( l.return.value )
}

function extern long txbod.dll9002.convert.from.erp.business.partner(
				domain	tcmcs.str10	i.role,
				domain	tccom.bpid	i.erp.business.partner,
				domain	tccwoc		i.erp.department,
			ref	domain	tcmcs.str50	o.bod.business.partner)
{
	DllUsage
	Expl	: This function converts the ERP business partner,
		  to the external business partner used in the BODs.
		  Department is only used for Invoice and Pay roles.
	Pre	: -
	Post	: -
	Input	: i.role
		  i.erp.business.partner
		  i.erp.department
	Output	: o.bod.business.partner
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0031.convert.from.erp.business.partner
	EndDllUsage

	o.bod.business.partner = ""

	if isspace(i.erp.business.partner) then
		return(0)
	endif

	on case i.role
	case SOLD_TO:
		o.bod.business.partner = i.erp.business.partner
		break
	case SHIP_TO:
		o.bod.business.partner = i.erp.business.partner
		break
	case INVOICE_TO:
		o.bod.business.partner = i.erp.business.partner

		if not isspace(i.erp.department) then
			if valid.department(
					i.role,
					i.erp.business.partner,
					i.erp.department) then

				o.bod.business.partner =
					o.bod.business.partner &
					CONCAT_SEPARATOR &
					trim$(i.erp.department)
			endif
		endif
		break
	case PAY_BY:
		o.bod.business.partner = i.erp.business.partner

		if not isspace(i.erp.department) then
			if valid.department(
					i.role,
					i.erp.business.partner,
					i.erp.department) then

				o.bod.business.partner =
					o.bod.business.partner &
					CONCAT_SEPARATOR &
					trim$(i.erp.department)
			endif
		endif
		break
	case BUY_FROM:
		o.bod.business.partner = i.erp.business.partner
		break
	case SHIP_FROM:
		o.bod.business.partner = i.erp.business.partner
		break
	case INVOICE_FROM:
		o.bod.business.partner = i.erp.business.partner

		if not isspace(i.erp.department) then
			if valid.department(
					i.role,
					i.erp.business.partner,
					i.erp.department) then

				o.bod.business.partner =
					o.bod.business.partner &
					CONCAT_SEPARATOR &
					trim$(i.erp.department)
			endif
		endif
		break
	case PAY_TO:
		o.bod.business.partner = i.erp.business.partner

		if not isspace(i.erp.department) then
			if valid.department(
					i.role,
					i.erp.business.partner,
					i.erp.department) then

				o.bod.business.partner =
					o.bod.business.partner &
					CONCAT_SEPARATOR &
					trim$(i.erp.department)
			endif
		endif
		break
	default:
		dal.set.error.message(	"txbods0012",
		|* Business partner role %1$s not supported.
					i.role)
		return(DALHOOKERROR)
	endcase

	return(0)
}

function extern long txbod.dll9002.convert.from.erp.country.to.iso(
				domain	tcccty	i.erp.country,
				boolean		i.force.reading,
			ref	domain	tcictc	o.iso.country)
{
	DllUsage
	Expl	: This function converts the ERP country code, to the ISO
		  country code.
	Pre	: -
	Post	: -
	Input	: i.erp.country
		  i.force.reading
	Output	: o.iso.country
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0031.convert.from.erp.country.to.iso
	EndDllUsage

	long	i
	long	l.found.counter

	domain	tcncmp			l.current.company

	static	long			s.last.position
	static	long			s.cache.counter

	static	domain	tcccty		s.erp.country(1)	based
	static	domain	tcictc		s.iso.country(1)	based
	static	domain	tcncmp		s.company(1)		based

	static	long			s.erp.length
	static	long			s.iso.length
	static	boolean			s.domain.read

	o.iso.country = ""

	if isspace(i.erp.country) then
		return(0)
	endif

	l.current.company = get.compnr()

	if not s.domain.read then
		s.erp.length = txbod.dll9002.domain.length("tcccty")
		s.iso.length = txbod.dll9002.domain.length("tcictc")
		s.domain.read = true
	endif

	l.found.counter = 0

	for i = 1 to s.last.position
		if s.company(i) = l.current.company			and
		   trim$(s.erp.country(1,i)) = trim$(i.erp.country)	then
			if i.force.reading then
				l.found.counter = i
				break
			else
				o.iso.country = s.iso.country(1,i)

				return(0)
			endif
		endif
	endfor

	if l.found.counter = 0			and
	   s.last.position = s.cache.counter	then
		s.cache.counter = s.cache.counter + ALLOCATE_SIZE
		if alloc.mem(	s.company,
				s.cache.counter) <> 0 or
		   alloc.mem(	s.erp.country,
				s.erp.length,
				s.cache.counter) <> 0 or
		   alloc.mem(	s.iso.country,
				s.iso.length,
				s.cache.counter) <> 0 then
			dal.set.error.message("txbod0001")
			|* txbod0001  ???
			return( DALHOOKERROR )
		endif
	endif

	RETIFNOK(get.iso.alpha2.code.by.country(
				i.erp.country,
				o.iso.country))

	if isspace(o.iso.country) then
		dal.set.error.message(	"txbods0017",
		|* txbods0017  ???
					trim$(i.erp.country))
		return(DALHOOKERROR)
	endif

	if l.found.counter > 0 then
		s.company(l.found.counter)		= l.current.company
		s.erp.country(1,l.found.counter)		= i.erp.country
		s.iso.country(1,l.found.counter)		= o.iso.country
	else
		inc(s.last.position)
		s.company(s.last.position)		= l.current.company
		s.erp.country(1,s.last.position)	= i.erp.country
		s.iso.country(1,s.last.position)	= o.iso.country
	endif

	return(0)
}

function extern long txbod.dll9002.convert.from.erp.currency.to.iso(
				domain	tcccur	i.erp.currency,
				boolean		i.force.reading,
			ref	domain	tciccc	o.iso.currency)
{
	DllUsage
	Expl	: This function converts the ERP currency code, to the ISO
		  currency code.
	Pre	: -
	Post	: -
	Input	: i.erp.currency
		  i.force.reading
	Output	: o.iso.currency
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old DLL : tcbod.dll0031.convert.from.erp.currency.to.iso
	EndDllUsage

	long	i
	long	l.ret
	long	l.found.counter

	domain	tcncmp			l.current.company

	static	long			s.last.position
	static	long			s.cache.counter

	static	domain	tcccur		s.erp.currency(1)	based
	static	domain	tciccc		s.iso.currency(1)	based
	static	domain	tcncmp		s.company(1)		based

	static	long			s.erp.length
	static	long			s.iso.length
	static	boolean			s.domain.read

	o.iso.currency = ""

	if isspace(i.erp.currency) then
		return(0)
	endif

	l.current.company = get.compnr()

	if not s.domain.read then
		s.erp.length = txbod.dll9002.domain.length("tcccur")
		s.iso.length = txbod.dll9002.domain.length("tciccc")
		s.domain.read = true
	endif

	l.found.counter = 0

	for i = 1 to s.last.position
		if s.company(i) = l.current.company			and
		   trim$(s.erp.currency(1,i)) = trim$(i.erp.currency)	then
			if i.force.reading then
				l.found.counter = i
				break
			else
				o.iso.currency = s.iso.currency(1,i)

				return(0)
			endif
		endif
	endfor

	if l.found.counter = 0			and
	   s.last.position = s.cache.counter	then
		s.cache.counter = s.cache.counter + ALLOCATE_SIZE
		if alloc.mem(	s.company,
				s.cache.counter) <> 0 or
		   alloc.mem(	s.erp.currency,
				s.erp.length,
				s.cache.counter) <> 0 or
		   alloc.mem(	s.iso.currency,
				s.iso.length,
				s.cache.counter) <> 0 then
			dal.set.error.message( "txbod0001" )
			|* txbod0001  ???

			return( DALHOOKERROR )
		endif
	endif

	l.ret = get.iso.code.by.currency(
					i.erp.currency,
					i.force.reading,
					o.iso.currency)

	if l.ret <> 0 or isspace(o.iso.currency) then
		dal.set.error.message(	"txbods0020",
		|* txbods0020  ???
					trim$(i.erp.currency))
		return(DALHOOKERROR)
	else
		if not is.valid.iso.currency.code(o.iso.currency) then
			dal.set.error.message(
				"txbods0081",
				|* txbods0081  ???
				tt.field.desc("tcmcs002.ccur"),
				i.erp.currency,
				trim$( o.iso.currency ))
				|* '%1$s' ISO code '%2$s' does not exist in the ISO code
				|* validation list.
			return(DALHOOKERROR)
		endif
	endif

	if l.found.counter > 0 then
		s.company(l.found.counter)		= l.current.company
		s.erp.currency(1,l.found.counter) 	= i.erp.currency
		s.iso.currency(1,l.found.counter) 	= o.iso.currency
	else
		inc(s.last.position)
		s.company(s.last.position)		= l.current.company
		s.erp.currency(1,s.last.position) 	= i.erp.currency
		s.iso.currency(1,s.last.position) 	= o.iso.currency
	endif

	return(0)
}

function extern long txbod.dll9002.convert.from.erp.language.to.iso(
				domain	tcclan	i.erp.language,
				boolean		i.force.reading,
			ref	domain	tcilng	o.iso.language)
{
	DllUsage
	Expl	: This function converts the ERP language code, to the ISO
		  language code.
	Pre	: -
	Post	: -
	Input	: i.erp.language
		  i.force.reading
	Output	: o.iso.language
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0031.convert.from.erp.language.to.iso
	EndDllUsage

	long	i
	long	l.found.counter

	domain	tcncmp			l.current.company

	static	long			s.last.position
	static	long			s.cache.counter

	static	domain	tcclan		s.erp.language(1)	based
	static	domain	tcilng		s.iso.language(1)	based
	static	domain	tcncmp		s.company(1)		based

	static	long			s.erp.length
	static	long			s.iso.length
	static	boolean			s.domain.read

	o.iso.language = ""

	if isspace(i.erp.language) then
		return(0)
	endif

	l.current.company = get.compnr()

	if not s.domain.read then
		s.erp.length = txbod.dll9002.domain.length("tcclan")
		s.iso.length = txbod.dll9002.domain.length("tcilng")
		s.domain.read = true
	endif

	l.found.counter = 0

	for i = 1 to s.last.position
		if s.company(i) = l.current.company			and
		   trim$(s.erp.language(1,i)) = trim$(i.erp.language)	then
			if i.force.reading then
				l.found.counter = i
				break
			else
				o.iso.language = s.iso.language(1,i)

				return(0)
			endif
		endif
	endfor

	if l.found.counter = 0			and
	   s.last.position = s.cache.counter	then
		s.cache.counter = s.cache.counter + ALLOCATE_SIZE
		if alloc.mem(	s.company,
				s.cache.counter) <> 0 or
		   alloc.mem(	s.erp.language,
				s.erp.length,
				s.cache.counter) <> 0 or
		   alloc.mem(	s.iso.language,
				s.iso.length,
				s.cache.counter) <> 0 then
			dal.set.error.message( "txbod0001" )
			|* txbod0001  ???

			return( DALHOOKERROR )
		endif
	endif

	RETIFNOK( get.iso.code.by.language(
				i.erp.language,
				o.iso.language))
	if isspace(o.iso.language) then
		dal.set.error.message(	"txbods0021",
		|* txbods0021  ???
					trim$(i.erp.language))
		return(DALHOOKERROR)
	else
		o.iso.language = tolower$( o.iso.language (1;2)) &
				o.iso.language(3)
	endif

	if l.found.counter > 0 then
		s.company(l.found.counter)		= l.current.company
		s.erp.language(1,l.found.counter)		= i.erp.language
		s.iso.language(1,l.found.counter)		= o.iso.language
	else
		inc(s.last.position)
		s.company(s.last.position)		= l.current.company
		s.erp.language(1,s.last.position)	= i.erp.language
		s.iso.language(1,s.last.position)	= o.iso.language
	endif

	return(0)
}

function extern long txbod.dll9002.convert.from.erp.order.method(
				domain	tcomth		i.erp.order.method,
			ref	domain	tcmcs.str25	o.bod.order.method)
{
	DllUsage
	Expl	: This function converts the ERP order method to the external
		  order method used in the BODs.
	Pre	: -
	Post	: -
	Input	: i.erp.order.method
	Output	: o.bod.order.method
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0031.convert.from.erp.order.method
	EndDllUsage

	o.bod.order.method = ""

	if i.erp.order.method = empty then
		return(0)
	endif

	on case i.erp.order.method
	case tcomth.lfl:
		o.bod.order.method = ORDER_METHOD_LOT
		break
	case tcomth.eoq:
		o.bod.order.method = ORDER_METHOD_ECONOMIC
		break
	case tcomth.foq:
		o.bod.order.method = ORDER_METHOD_FIXED
		break
	case tcomth.max:
		o.bod.order.method = ORDER_METHOD_MAX
		break
	default:
		dal.set.error.message(
			"txbods0040",
			|* txbods0040  ???
			tt.label.desc( "tctcibd200.omth", ttadv.cont.general ),
			|* tctcibd200.omth  ???
			enum.descr$("tcomth", i.erp.order.method))
			|* tcomth  ???

		return(DALHOOKERROR)
	endcase

	return(0)
}

function extern long txbod.dll9002.convert.from.erp.unit.to.iso(
				domain	tccuni	i.erp.unit,
				boolean		i.force.reading,
			ref	domain	tcictc	o.iso.unit)
{
	DllUsage
	Expl	: This function converts the ERP unit code, to the ISO
		  unit code.
	Pre	: -
	Post	: -
	Input	: i.erp.unit
		  i.force.reading
	Output	: o.iso.unit
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0031.convert.from.erp.unit.to.iso
	EndDllUsage

	long				i
	long				l.found.counter

	domain	tcncmp			l.current.company

	static	long			s.last.position
	static	long			s.cache.counter

	static	domain	tccuni		s.erp.unit(1)		based
	static	domain	tcictc		s.iso.unit(1)		based
	static	domain	tcncmp		s.company(1)		based

	static	long			s.erp.length
	static	long			s.iso.length
	static	boolean			s.domain.read

	o.iso.unit = ""

	if isspace(i.erp.unit) then
		return(0)
	endif

	l.current.company = get.compnr()

	if not s.domain.read then
		s.erp.length = txbod.dll9002.domain.length("tccuni")
		s.iso.length = txbod.dll9002.domain.length("tcictc")
		s.domain.read = true
	endif

	l.found.counter = 0

	for i = 1 to s.last.position
		if s.company(i) = l.current.company		and
		   trim$(s.erp.unit(1,i)) = trim$(i.erp.unit)	then
			if i.force.reading then
				l.found.counter = i
				break
			else
				o.iso.unit = s.iso.unit(1,i)

				return(0)
			endif
		endif
	endfor

	if l.found.counter = 0			and
	   s.last.position = s.cache.counter	then
		s.cache.counter = s.cache.counter + ALLOCATE_SIZE
		if alloc.mem(	s.company,
				s.cache.counter) <> 0 or
		   alloc.mem(	s.erp.unit,
				s.erp.length,
				s.cache.counter) <> 0 or
		   alloc.mem(	s.iso.unit,
				s.iso.length,
				s.cache.counter) <> 0 then
			dal.set.error.message( "txbod0001" )
			|* txbod0001  ???

			return( DALHOOKERROR )
		endif
	endif

	RETIFNOK(txmcs.dll9001.get.iso.code.by.unit(	i.erp.unit,
							o.iso.unit))

	if isspace(o.iso.unit) then
		o.iso.unit = toupper$(trim$(i.erp.unit))
	endif

	if l.found.counter > 0 then
		s.company(l.found.counter)	= l.current.company
		s.erp.unit(1,l.found.counter)	= i.erp.unit
		s.iso.unit(1,l.found.counter)	= o.iso.unit
	else
		inc(s.last.position)
		s.company(s.last.position)	= l.current.company
		s.erp.unit(1,s.last.position)	= i.erp.unit
		s.iso.unit(1,s.last.position)	= o.iso.unit
	endif

	return(0)
}

function extern long txbod.dll9002.convert.from.iso.country.to.erp(
				domain	tcictc	i.iso.country,
				boolean		i.force.reading,
			ref	domain	tcccty	o.erp.country)
{
	DllUsage
	Expl	: This function converts the ISO country code, to the ERP
		  country code.
	Pre	: -
	Post	: -
	Input	: i.iso.country
		  i.force.reading
	Output	: o.erp.country
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0031.convert.from.iso.country.to.erp
	EndDllUsage

	long	i
	long	l.found.counter

	domain	tcncmp			l.current.company

	static	long			s.last.position
	static	long			s.cache.counter

	static	domain	tcccty		s.erp.country(1)	based
	static	domain	tcictc		s.iso.country(1)	based
	static	domain	tcncmp		s.company(1)		based

	static	long			s.erp.length
	static	long			s.iso.length
	static	boolean			s.domain.read

	boolean	l.country.exists

	o.erp.country = ""

	if isspace(i.iso.country) then
		return(0)
	endif

	l.current.company = get.compnr()

	if not s.domain.read then
		s.erp.length = txbod.dll9002.domain.length("tcccty")
		s.iso.length = txbod.dll9002.domain.length("tcictc")
		s.domain.read = true
	endif

	l.found.counter = 0

	for i = 1 to s.last.position
		if s.company(i) = l.current.company			and
		   trim$(s.iso.country(1,i)) = trim$(i.iso.country)	then
			if i.force.reading then
				l.found.counter = i
				break
			else
				o.erp.country = s.erp.country(1,i)

				return(0)
			endif
		endif
	endfor

	if l.found.counter = 0			and
	   s.last.position = s.cache.counter	then
		s.cache.counter = s.cache.counter + ALLOCATE_SIZE
		if alloc.mem(	s.company,
				s.cache.counter) <> 0 or
		   alloc.mem(	s.erp.country,
				s.erp.length,
				s.cache.counter) <> 0 or
		   alloc.mem(	s.iso.country,
				s.iso.length,
				s.cache.counter) <> 0 then
			dal.set.error.message("txbod0001")
			|* txbod0001  ???
			return( DALHOOKERROR )
		endif
	endif

	l.country.exists = get.country.by.iso.alpha2.code(
					i.iso.country,
					o.erp.country)
	if l.country.exists = false or isspace(o.erp.country) then
		dal.set.error.message(	"tcbods0013",
		|* tcbods0013  ???
					i.iso.country)
		return(DALHOOKERROR)
	endif

	if l.found.counter > 0 then
		s.company(l.found.counter)		= l.current.company
		s.iso.country(1,l.found.counter)		= i.iso.country
		s.erp.country(1,l.found.counter)		= o.erp.country
	else
		inc(s.last.position)
		s.company(s.last.position)		= l.current.company
		s.iso.country(1,s.last.position)	= i.iso.country
		s.erp.country(1,s.last.position)	= o.erp.country
	endif

	return(0)
}

function extern long txbod.dll9002.convert.from.iso.language.to.erp(
				domain	tcilng	i.iso.language,
				boolean		i.force.reading,
			ref	domain	tcclan	o.erp.language)
{
	DllUsage
	Expl	: This function converts the ISO language code, to the ERP
		  language code.
	Pre	: -
	Post	: -
	Input	: i.iso.language
		  i.force.reading
	Output	: o.erp.language
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0031.convert.from.iso.language.to.erp
	EndDllUsage

	long	i
	long	l.found.counter

	domain	tcncmp			l.current.company
	domain	tcilng			l.iso.language		|#2048001.n

	static	long			s.last.position
	static	long			s.cache.counter
		
	static	domain	tcclan		s.erp.language(1)	based
	static	domain	tcilng		s.iso.language(1)	based
	static	domain	tcncmp		s.company(1)		based

	static	long			s.erp.length
	static	long			s.iso.length
	static	boolean			s.domain.read

	o.erp.language = ""

	if isspace(i.iso.language) then
		return(0)
	endif

	|* Within table Languages (tcmcs046) the ISO Languages can only be
	|* written with a minus sign.
	l.iso.language = str.replace$( i.iso.language, "_", "-" )
	l.current.company = get.compnr()

	if not s.domain.read then
		s.erp.length = txbod.dll9002.domain.length("tcclan")
		s.iso.length = txbod.dll9002.domain.length("tcilng")
		s.domain.read = true
	endif

	l.found.counter = 0

	for i = 1 to s.last.position
		if s.company(i) = l.current.company			and
		   trim$(s.iso.language(1,i)) = trim$(l.iso.language)	then
			if i.force.reading then
				l.found.counter = i
				break
			else
				o.erp.language = s.erp.language(1,i)

				return(0)
			endif
		endif
	endfor

	if l.found.counter = 0			and
	   s.last.position = s.cache.counter	then
		s.cache.counter = s.cache.counter + ALLOCATE_SIZE
		if alloc.mem(	s.company,
				s.cache.counter) <> 0 or
		   alloc.mem(	s.erp.language,
				s.erp.length,
				s.cache.counter) <> 0 or
		   alloc.mem(	s.iso.language,
				s.iso.length,
				s.cache.counter) <> 0 then
			dal.set.error.message( "txbod0001" )
			|* txbod0001  ???

			return( DALHOOKERROR )
		endif
	endif

	RETIFNOK(get.language.by.iso.code(
				toupper$(l.iso.language),	
					o.erp.language))
	if isspace(o.erp.language) then
		dal.set.error.message(	"txbods0018",
		|* No language found for ISO Code %1$s.
					i.iso.language)
		return(DALHOOKERROR)
	endif

	if l.found.counter > 0 then
		s.company(l.found.counter)		= l.current.company
								
		s.iso.language(1,l.found.counter)		= l.iso.language
								
		s.erp.language(1,l.found.counter)		= o.erp.language
	else
		inc(s.last.position)
		s.company(s.last.position)		= l.current.company
								
		s.iso.language(1,s.last.position)	= l.iso.language
								
		s.erp.language(1,s.last.position)	= o.erp.language
	endif

	return(0)
}

function extern long txbod.dll9002.get.location.description(
			const	string		i.location,
			const	string		i.location.type,
		ref	domain	tcdsca		o.description,
		ref		boolean		o.description.is.set)
{
	DllUsage
	Expl	: This function will retrieve the description of a location. This
		  location can either be a department, warehouse or site.
	Pre	: -
	Post	: -
	Input	: i.location	- Location
		  i.location.type - Type of location; Department, warehouse or
		  		    site
	Output	: o.description	- Description of the location
		  o.description.is.set
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0035.get.location.description
	EndDllUsage

	o.description = ""
	o.description.is.set = false

	if isspace(i.location) then
		return(0)
	endif

	on case strip$(i.location.type)
	case LOCATION_TYPE_OFFICE :
		select	tcmcs065.dsca:o.description
		from	tcmcs065
		where	tcmcs065._index1 = {:i.location}
		as set with 1 rows
		selectdo
			o.description.is.set = true
		selectempty
			dal.set.error.message("txemms0113",
			|* txemms0113  ???
						i.location,
						get.compnr())
		endselect
		break
	case LOCATION_TYPE_WAREHOUSE :
		RETIFNOK(txmcs.dll9001.get.description.of.warehouse.by.company(
				i.location,
				get.compnr(),
				o.description))

		o.description.is.set = true
		break
	case LOCATION_TYPE_PROJECT:
		if get.project.description(
				i.location,
				o.description) then
			o.description.is.set = true
		endif
		break
	case LOCATION_TYPE_SITE:
		if get.company.description(
				lval(i.location),	|* Company
				o.description) then	|* Ref
			o.description.is.set = true
		endif

		break
	endcase

	return(0)
}

function extern long txbod.dll9002.compose.location.identifier(
				const	string		i.type,
				const	string		i.location,
			ref	domain	tcmcs.str50	o.location.identifier)
{
	DllUsage
	Expl	: This function converts the ERP location
		  to the external location used in the BODs.
	Pre	: -
	Post	: -
	Input	: i.type
		  i.location
	Output  : o.location.identifier
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0036.compose.location.identifier
	EndDllUsage

	o.location.identifier = ""

	if isspace(i.location) then
		return(0)
	endif

	on case i.type
	case LOCATION_TYPE_WAREHOUSE:
		o.location.identifier = concat$(	CONCAT_SEPARATOR,
							"W",
							trim$(i.location))
		break
	case LOCATION_TYPE_OFFICE:
		o.location.identifier = concat$(	CONCAT_SEPARATOR,
							"D",
							trim$(i.location))
		break
	case LOCATION_TYPE_SITE:
		o.location.identifier = concat$(	CONCAT_SEPARATOR,
							"S",
							trim$(i.location))
		break
	case LOCATION_TYPE_PROJECT:
		o.location.identifier = concat$(	CONCAT_SEPARATOR,
							"P",
							trim$(i.location))
		break
	default:
		dal.set.error.message( "txbods0040", "Location Type ", i.type )
		|* txbods0040  ???

		return( DALHOOKERROR )
	endcase

	return(0)
}

function extern long txbod.dll9002.Hook.BeforeExecute.ItemMasterCommonBOD.Show(
		domain	tcitem	i.ItemMasterHeader_ItemID_ID,
	ref	domain	tcncmp	o.financial.company,
	ref	domain	tcccur	o.reference.currency,
	ref	domain	tciccc	o.iso.reference.currency,
	ref	domain	tcccur	o.local.currency,
	ref	domain	tciccc	o.iso.local.currency,
	ref	domain	tcdate	o.rate.date,
	ref	domain	tcrtyp	o.source.rate.type,
	ref	domain	tcrtyp	o.target.rate.type )
{
	DllUsage
	Old Dll : tcbod.dll2505.hook.beforeexecute.itemmastercommonbod.show
	EndDllusage
	

		boolean	l.dummy.is.set
	domain	tcrtyp	l.internal.exchange.rate

	o.financial.company = get.compnr()
	o.reference.currency = ""
	o.iso.reference.currency = ""
	o.local.currency = ""
	o.iso.local.currency = ""
	o.rate.date = utc.num()
	o.source.rate.type = ""
	o.target.rate.type = ""

	RETIFNOK( txbod.dll9002.get.local.and.reference.currency(
			o.financial.company,
			o.reference.currency,		|* Ref
			o.iso.reference.currency,	|* Ref
			o.local.currency,		|* Ref
			o.iso.local.currency ))		|* Ref

	RETIFNOK( txbod.dll9002.get.company.internal.exchange.rate.type(
			o.financial.company,
			false,			|* Force reading
			l.internal.exchange.rate,	|* Ref
			l.dummy.is.set ))		|* Ref

	o.source.rate.type = l.internal.exchange.rate
	o.target.rate.type = l.internal.exchange.rate

	return( 0 )
}


function extern long txbod.dll9002.get.local.and.reference.currency(
			domain	tcncmp		i.company,
		ref	domain	tcccur		o.reference.currency,
		ref	domain	tciccc		o.iso.reference.currency,
		ref	domain	tcccur		o.local.currency,
		ref	domain	tciccc		o.iso.local.currency)
{
	DllUsage
	Expl	: Reads the reference and local currency of the
		  financial company.
	Pre	: -
	Post	: -
	Input	: i.company
	Output	: o.reference.currency
		  o.iso.reference.currency
		  o.local.currency
		  o.iso.local.currency
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0035.get.local.and.reference.currency
	EndDllUsage

		boolean		l.dummy.euro.compliant
	domain	tcemm.ctyp	l.dummy.company.type
	domain	tcdesc		l.dummy.description
	domain	tcemm.depe	l.dummy.currency.system
	domain	tcccur		l.dummy.reporting.currency1
	domain	tcccur		l.dummy.reporting.currency2
	domain	tcccur		l.dummy.euro.currency
	domain	tcemm.expu   	l.dummy.exchange.rate.pur
	domain	tcemm.expu	l.dummy.exchange.rate.sls
	domain	tcemm.expu	l.dummy.exchange.rate.eu
	domain	tcemm.expu	l.dummy.exchange.rate.rep.curr1
	domain	tcemm.expu	l.dummy.exchange.rate.rep.curr2
	domain	tcemm.tmrc	l.dummy.transaction.method.rep.curr1
	domain	tcemm.tmrc	l.dummy.transaction.method.rep.curr2

	static	domain	tcncmp	s.company
	static	domain	tcccur	s.reference.currency
	static	domain	tcccur	s.local.currency
	static	domain	tciccc	s.iso.reference.currency
	static	domain	tciccc	s.iso.local.currency

	if s.company = i.company then
		o.reference.currency		= s.reference.currency
		o.iso.reference.currency	= s.iso.reference.currency
		o.local.currency		= s.local.currency
		o.iso.local.currency		= s.iso.local.currency

		return(0)
	endif
	if not txemm.dll9001.get.company.data(
			i.company,
			l.dummy.company.type,
			l.dummy.description,
			l.dummy.currency.system,
			o.reference.currency,
			o.local.currency,
			l.dummy.reporting.currency1,
			l.dummy.reporting.currency2,
			l.dummy.euro.currency,
			l.dummy.exchange.rate.pur,
			l.dummy.exchange.rate.sls,
			l.dummy.exchange.rate.eu,
			l.dummy.euro.compliant,
			l.dummy.exchange.rate.rep.curr1,
			l.dummy.exchange.rate.rep.curr2,
			l.dummy.transaction.method.rep.curr1,
			l.dummy.transaction.method.rep.curr2) then
		dal.set.error.message("txemms0040", i.company)
		|* txemms0040  ???
		return(DALHOOKERROR)
	endif

	RETIFNOK(txbod.dll9002.convert.from.erp.currency.to.iso(
			o.reference.currency,
			false,
			o.iso.reference.currency))

	RETIFNOK(txbod.dll9002.convert.from.erp.currency.to.iso(
			o.local.currency,
			false,
			o.iso.local.currency))

	s.company			= i.company
	s.reference.currency		= o.reference.currency
	s.iso.reference.currency	= o.iso.reference.currency
	s.local.currency		= o.local.currency
	s.iso.local.currency		= o.iso.local.currency

	return(0)
}

function extern long txbod.dll9002.get.company.internal.exchange.rate.type(
		domain	tcncmp		i.company,
		boolean			i.force.reading,
	ref	domain	tcemm.expu	o.internal.exchange.rate.type,
	ref		boolean		o.internal.exchange.rate.type.is.set)
{
	DLLUsage
	Expl	: The purpose of this function is to read the company internal
		  exchange rate type for a specified company.

		  Use of statics is optional. So a new datebase read can be
		  forced.
	Pre	: -
	Post	: -
	Input	: i.company
		  i.force.reading
	Output	: o.internal.exchange.rate.type
		  o.internal.exchange.rate.type.is.set
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old DLL : tcbod.dll0035.get.company.internal.exchange.rate.type
	EndDLLUsage

	static		boolean		s.record.found
	static	domain	tcemm.expu	s.internal.exchange.rate.type
	static	domain	tcncmp		s.current.company
	static	domain	tcncmp		s.company

	o.internal.exchange.rate.type = ""
	o.internal.exchange.rate.type.is.set = false

	if i.force.reading = true or
	   s.current.company <> get.compnr() or
	   s.company <> i.company then
		s.current.company = get.compnr()
		s.company = i.company

		select	tcemm170.exeu:s.internal.exchange.rate.type
		from	tcemm170
		where	tcemm170._index1 = {:s.company}
		as set with 1 rows
		selectdo
			s.record.found = true
		selectempty
			s.internal.exchange.rate.type = ""
		endselect
	endif

	o.internal.exchange.rate.type = s.internal.exchange.rate.type

	if not s.record.found then
		dal.set.error.message("txemms0054", i.company)
		|* Company %1$@C@ not found.

		return(DALHOOKERROR)
	endif

	o.internal.exchange.rate.type.is.set = true

	return(0)
}


function extern long txbod.dll9002.Hook.ConversionGet.ItemLocation_ItemPlanning_PlanItemType(
		domain	cprpd.plit	i.PlanItemType,
	ref		string		o.PlanItemType,
	ref		boolean		io.PlanItemType.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to return attribute
		ItemPlanning_PlanItemType of the main component.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.PlanItemType
	Output:	o.PlanItemType
	In/out:	io.PlanItemType.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.hook.conversionget.itemlocation_itemplanning_planitemtype
	EndDllUsage

	o.PlanItemType = ""
	io.PlanItemType.isSet = false

	if i.PlanItemType = empty then
		return( 0 )
	endif

	on case i.PlanItemType
	case cprpd.plit.productfamily:
		o.PlanItemType = PLAN_ITEM_TYPE_FAMILY
		break
	case cprpd.plit.mpsitem:
		o.PlanItemType = PLAN_ITEM_TYPE_ITEM
		break
	default:
		dal.set.error.message(
			"txbods0040",
			|* txbods0040  ???
			tt.label.desc( "cpcprpd100.plit", ttadv.cont.general ),
			|* cpcprpd100.plit  ???
			enum.descr$( "cprpd.plit", i.PlanItemType ) )
			|* cprpd.plit  ???

		return( DALHOOKERROR )
	endcase
	
	if not isspace( o.PlanItemType ) then
		io.PlanItemType.isSet = true
	endif

	return( 0 )
}

function extern long txbod.dll9002.Hook.ConversionGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID(
		domain tcmcs.str50	i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID,
	ref		string		o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID,
	ref		boolean		io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.txbod.dll9002.Hook.ConversionGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID
	EndDllusage

	io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID.isSet = false

	if not isspace( i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID ) then
		RETIFNOK( txbod.dll9002.compose.location.identifier(
				LOCATION_TYPE_OFFICE,
				i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID,
				o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID ))	|* Ref

		if not isspace( o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID ) then
			io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID.isSet = true
		endif
	endif

	return( 0 )
}

function extern long txbod.dll9002.Hook.ConversionGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID(
		domain tcmcs.str50	i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID,
	ref		string		o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID,
	ref		boolean		io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.hook.conversionget.itemmastercommonbod.itemmasterheader_procurementparameters_defaultsource_warehouselocation_id
	EndDllusage

	io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID.isSet = false

	if not isspace( i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID ) then
		RETIFNOK( txbod.dll9002.compose.location.identifier(
				LOCATION_TYPE_WAREHOUSE,
				i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID,
				o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID ))	|* Ref

		if not isspace( o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID ) then
			io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID.isSet = true
		endif
	endif

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemLocation.ERPLengthUnit(
	ref	domain	tccuni	o.ERPLengthUnit,
	ref		boolean	io.ERPLengthUnit.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to return protected attribute
		ERPLengthUnit of the main component.
	Pre:	N.a.
	Post:	N.a.
	Input:	N.a.
	Output:	o.ERPLengthUnit
	In/out:	io.ERPLengthUnit.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.hook.onget.itemlocation.erplengthunit
	EndDllUsage

	o.ERPLengthUnit = ""
	io.ERPLengthUnit.isSet = false

	RETIFNOK(txwmd.dll9001.get.length.unit(o.ERPLengthUnit))|* Ref

	if not isspace(o.ERPLengthUnit) then
		io.ERPLengthUnit.isSet = true
	endif

	return( 0 )
}

function extern long txbod.dll9002.get.line.currency.data(
			domain tccono		i.project.contract,
			domain tpctm.cnln	i.project.contract.line,
		ref	domain tcncmp		o.line.financial.company)
{
	DllUsage
	Expl	: Executed before publishing a ProjectContractLine, to retrieve
		  non-volatile table fields.
		  
	Pre.	:
	Post	:
	Input	: i.project.contract
		  i.project.contract.line	
	Output	: o.line.financial.company
	Return	: 0 / DALHOOKERROR
	Old Dll : tpbod.dll5010.get.line.currency.data
	EndDllUsage

		domain	tccwoc	l.department

	static	domain tccono		s.project.contract	
	static	domain tpctm.cnln	s.project.contract.line
	static	domain tcncmp		s.line.financial.company

	if s.project.contract = i.project.contract and
		s.project.contract.line = i.project.contract.line then
			o.line.financial.company =
				s.line.financial.company
			return(0)
	endif							


	select	tpctm110.cofc:l.department				
	from	tpctm110
	where	tpctm110._index1 = {:i.project.contract,
					:i.project.contract.line}
	as set with 1 rows
	selectdo
	selectempty
		return(DALHOOKERROR)					
	endselect						
	if not txmcs.dll9001.read.financial.company.of.department(
			get.compnr(),
			l.department,
			o.line.financial.company) then
				return(DALHOOKERROR)
	endif							
	
	s.project.contract = 	i.project.contract		
	s.project.contract.line	= i.project.contract.line
	s.line.financial.company = o.line.financial.company
								
	return(0)						
}

function extern void txbod.dll9002.determine.report.discount.fields(
	ref	domain	tcdisc		i.discount.percentage(),
	ref	domain	tddiam		i.discount.amount(),
	ref	domain	tddmth		i.discount.method(),
		domain	tcccur		i.currency,
			long		i.discount.index,
	ref	domain	tcmcs.str3	o.discount.type,
	ref	domain	tcbool		o.discount.is.percentage,
	ref	domain	tcpric		o.discount,
	ref	domain	tcmcs.str12	o.discount.expr fixed,
	ref	domain	tddmth		o.discount.method,
	ref	domain	tcbool		o.discount.last)
{
	DllUsage
	Expl.:	Use the function to determine report discount fields.
		o.discount.expr is filled with dicount amount or
		discount percentage in the right format.
		If o.discount.expr is a amount then o.discount.type is filled
		with the currency provided in i.cuurency.
		If o.dicsount.expr is a percentage then .discount.type is filled
		with the "%" sign.
	Pre:	N.A.
	Post:	N.A.
	Input:	i.discount.percentage() - Array of discount percentages
					(like tdsls401.disc)
		i.discount.amount() - Array of discount amounts
					(like tdsls401.ldam)
		i.discount.method() - Array of discount methods
					(like tdsls401.dmth)
		i.currency
		i.discount.index - the index from the array to base the
					output values on.
	Output:	o.discount.type
		o.discount.is.percentage
		o.discount
		o.discount.expr
		o.discount.method
		o.discount.last - If there are no more discounts further
					down the array that are filled then
					true else false
	Return:	N.A.
	Old Dll : tdgen.dll0007.determine.report.discount.fields
	EndDllUsage
	
			long		l.array.length
			long		l.no.dims			
			long		l.dim.array(1)		
			long		i

	txgen.dll9001.determine.single.report.discount.field(	
					i.discount.percentage(i.discount.index),
					i.discount.amount(i.discount.index),
					i.discount.method(i.discount.index),
					i.currency,
					o.discount.type,		|* Ref
					o.discount.is.percentage,	|* Ref
					o.discount,			|* Ref
					o.discount.expr,		|* Ref
					o.discount.method)		|* Ref
								

	|* Check if more discounts are present down the discount array		
	array.info(	i.discount.method,			
			l.no.dims,	|* Ref
			l.dim.array)	|* Ref
	l.array.length = l.dim.array(1)				

	for i = i.discount.index + 1 to l.array.length
		if i.discount.percentage(i) <> 0 or
		   i.discount.amount(i) <> 0 then
			o.discount.last = false
			break
		endif
	endfor
}

function extern domain tcdate txbod.dll9002.add.days.to.utc.date(
		domain	tcdate		i.date,
			long		i.nr.of.days)
{
	DllUsage
	Expl:	Returns an utc date that is i.ndays later than the given
		i.utc.date (or earlier if i.ndays is negative).
	Pre:	-
	Post:	-
	Input:	i.date
		i.nr.of.days
	Output:	-
	Return:	utc date
	Old Dll : tdgen.dll0006.add.days.to.utc.date
	EndDllUsage

	return(add.date.to.utc.date(
					i.date,
					0,		|* years
					0,		|* months
					i.nr.of.days,	|* days
					0,		|* hours
					0,		|* minutes
					0 ) )		|* seconds
}
		
function extern domain tddate3 txbod.dll9002.convert.to.date.format(
		domain	tcdate		i.date)
{
	DllUsage
	Expl:	Convert UTC to Date format.
	Pre:	-
	Post:	-
	Input:	i.date - date in UTC format.
	Output:	o.date - date in Date format.
	Return:	date in Date format
	Old Dll : tdgen.dll0006.convert.to.date.format
	EndDllUsage

		domain	tddate3		l.converted.date
			long		l.yearno
			long		l.monthno
			long		l.month_dayno
			long		l.seconds
			long		l.minutes
			long		l.hours
			long		l.ret

	l.ret = utc.to.date(		i.date,
					l.yearno,
					l.monthno,
					l.month_dayno,
					l.hours,
					l.minutes,
					l.seconds)

	l.converted.date = date.to.num(	l.yearno,
					l.monthno,
					l.month_dayno)
	return(l.converted.date)
}		


function extern domain tcdate txbod.dll9002.remove.time.from.utc(
		domain	tcdate		i.date)
{
	DllUsage
	Expl:	Remove hours, minutes and seconds from UTC.
	Pre:	-
	Post:	-
	Input:	i.date - date in UTC format.
	Output:	NA
	Return:	date in UTC format at 00:00:00.
	Old Dll : tdgen.dll0006.remove.time.from.utc
	EndDllUsage

		domain	tddate3		l.converted.date
			long		l.yearno
			long		l.monthno
			long		l.month_dayno
			long		l.seconds
			long		l.minutes
			long		l.hours
			long		l.ret

	l.ret = utc.to.date(		i.date,
					l.yearno,
					l.monthno,
					l.month_dayno,
					l.hours,
					l.minutes,
					l.seconds)

	l.converted.date = date.to.utc(	l.yearno,
					l.monthno,
					l.month_dayno,
					0,
					0,
					0)
	return(l.converted.date)
}

function extern long txbod.dll9002.Hook.OnGet.QuoteHeader_ExtendedAmount(
		domain	tcqono		i.QuoteHeader_DocumentID_ID,
			boolean		i.QuoteHeader_DocumentID_ID.isSet,
		domain	tcccur		i.ERPOrderCurrency,
			boolean		i.ERPOrderCurrency.isSet,
	ref 	domain	tcamnt		o.QuoteHeader_ExtendedAmount,
	ref 		boolean		io.QuoteHeader_ExtendedAmount.isSet)
{
	DllUsage
	Expl	: Wrapper function to retrieve attribute
		  QuoteHeader_ExtendeAmount. This is the summation of the
		  quotation line amounts.
	Pre.	: NA
	Post	: NA
	Input	: i.QuoteHeader_DocumentID_ID - Sales quotation
		  i.ERPOrderCurrency	- Sales quotation currency
	Output	: o.QuoteHeader_TotalAmount
	Return	: 0
	Old Dll : tdbod.dll0011.hook.onget.quoteheader_extendedamount
	EndDllUsage

	domain	tcamnt		l.amount
	domain	tcconv		l.conv.fact.qoor
	domain	tcconv		l.conv.fact.pric
	domain	tcpric		l.price
	domain	tcqsl1		l.quantity

	o.QuoteHeader_ExtendedAmount = 0.0

	select	tdsls101.amta:l.amount,
		tdsls101.qoor:l.quantity,
		tdsls101.pric:l.price,
		tdsls101.cvqs:l.conv.fact.qoor,
		tdsls101.cvps:l.conv.fact.pric
	from 	tdsls101
	where 	tdsls101._index1 = {:i.QuoteHeader_DocumentID_ID}
	and	tdsls101.srnb = 0
	and	tdsls101.lsta <> tdsls.lsta.abandoned
	and	tdsls101.lsta <> tdsls.lsta.lost
	selectdo
		if not txmcs.dll9001.double.cmp.equal.to("tcqsl1","tcqsl1", 
					l.quantity, 0.0) then	|* NOT ZERO
			o.QuoteHeader_ExtendedAmount =
					o.QuoteHeader_ExtendedAmount +
					l.quantity * l.price *
					(l.conv.fact.qoor / l.conv.fact.pric)
		else
			|* (Additional) Cost Items
			o.QuoteHeader_ExtendedAmount =
				o.QuoteHeader_ExtendedAmount + l.amount
		endif
	endselect

	o.QuoteHeader_ExtendedAmount = txcom.dll9001.domain.round(
					o.QuoteHeader_ExtendedAmount,
					domainof(o.QuoteHeader_ExtendedAmount),
					i.ERPOrderCurrency)

	io.QuoteHeader_ExtendedAmount.isSet = true

	return(0)
}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ERPLengthUnit(
	ref	domain	tccuni	o.ERPLengthUnit,
	ref		boolean	io.ERPLengthUnit.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to return protected attribute
		ERPLengthUnit of the main component.
	Pre:	N.a.
	Post:	N.a.
	Input:	N.a.
	Output:	o.ERPLengthUnit
	In/out:	io.ERPLengthUnit.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.hook.onget.itemmastercommonbod.erplengthunit
	EndDllUsage

	static		boolean	s.is.set
	static	domain	tccuni	s.length.unit

	o.ERPLengthUnit = ""
	io.ERPLengthUnit.isSet = false

	if not s.is.set then
		RETIFNOK( txwmd.dll9001.get.length.unit( s.length.unit ))|* Ref

		s.is.set = true
	endif

	if not isspace( s.length.unit ) then
		o.ERPLengthUnit = s.length.unit
		io.ERPLengthUnit.isSet = true
	endif

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_Description(
		domain	tcdsca		i.ERPDescription,
			boolean		i.ERPDescription.isSet,
	ref	domain	tcmcs.long	o.ItemMasterHeader_Description(),
	ref		boolean		io.ItemMasterHeader_Description.isSet() )
{
	DllUsage
	Expl:	The purpose of this function is to return the a stack with the
		Item descriptions to be published.

		If multi language is enabled:
		- Publish the Item description in the base language without
		  'languageID' on the first position of the stack.
		- Publish all Item descriptions in the base language at the end
		  of the stack.

		If multi language is disabled:
		- Publish the current Item description.
	Pre:	- If multi language is enabled, the data language is set to the
		  base language, before publishing the BOD.
		- At least one position is defined for the description stacks.
	Post:	N.a.
	Args:	i.ERPDescription
		i.ERPDescription.isSet
		o.ItemMasterHeader_Description
		io.ItemMasterHeader_Description.isSet
	Output:	N.a.
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_Description
	EndDllUsage

	long	l.last.used.position

	|* Initialize stacks.
	if set.mem( o.ItemMasterHeader_Description, 0 ) <> 0 or
	   set.mem( io.ItemMasterHeader_Description.isSet, false ) <> 0 then
		dal.set.error.message( "txbods0025" )
		|* txbods0025  ???

		return( DALHOOKERROR )
	endif

	l.last.used.position = 1

	RETIFNOK( txbod.dll9002.get.description.node(
			i.ERPDescription,
			"",	|* Type
			"",	|* System language
			o.ItemMasterHeader_Description(l.last.used.position),		|* Ref
			io.ItemMasterHeader_Description.isSet(l.last.used.position) ))	|* Ref

	if ml_is_active() then
		|* Multi Language support is active.
		|* Add Item description of all languages to stack.
		RETIFNOK( add.multi.languages.to.stack(
				i.ERPDescription,
				l.last.used.position,		|* Ref (io)
				o.ItemMasterHeader_Description,	|* Ref
				io.ItemMasterHeader_Description.isSet ))|* Ref
	endif

	return( 0 )
}

function extern long txbod.dll9002.get.description.node(
			const	string		i.description,
			const	string		i.type,
			const	string		i.erp.language,
		ref	domain	tcmcs.long	o.xml.node,
		ref		boolean		o.xml.node.is.set)
{
	DllUsage
	Expl	: This function creates a Description node.

		  <Description type="xxx" languageID="NL">yyy</Description>
	Pre	: If Multi Language (mle) support is active, variable
		  'i.erp.language' is filled with an ISO language and the
		  conversion to ISO is skipped within this function.
	Post	: -
	Input	: i.description
		  i.type
		  i.erp.language
	Output	: o.xml.node
		  o.xml.node.is.set
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0033.get.description.node
	EndDllUsage

	domain	tcilng	l.iso.language

	o.xml.node = 0
	o.xml.node.is.set = false

	NEW_ELEMENT(	"Description",
			i.description,
			0,
			o.xml.node)

	if not isspace(i.type) then
		NEW_ATTRIBUTE(	o.xml.node,
				"Description",
				"type",
				i.type)
	endif

	if not isspace(i.erp.language) then
		if ml_is_active() then
			l.iso.language = i.erp.language
		else
			RETIFNOK(txbod.dll9002.convert.from.erp.language.to.iso(
					i.erp.language,
					false,		|* force reading
					l.iso.language))
		endif

		NEW_ATTRIBUTE(	o.xml.node,
				"Description",
				"languageID",
				l.iso.language)
	endif

	o.xml.node.is.set = true

	return(0)
}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ItemValue_UnitValue_Amount_currencyID(
		domain	tcccur	i.ERPCurrency,
	ref	domain	tcccur	o.ItemMasterHeader_ItemValue_UnitValue_Amount_currencyID,
	ref		boolean	io.ItemMasterHeader_ItemValue_UnitValue_Amount_currencyID.isSet )
{
	DllUsage
	Old DLL : tcbod.dll2505.hook.onget.itemmastercommonbod.itemmasterheader_itemvalue_unitvalue_amount_currencyid
	EndDllusage

	RETIFNOK(get.item.value.amount.currency(		
			i.ERPCurrency,
			o.ItemMasterHeader_ItemValue_UnitValue_Amount_currencyID,
			io.ItemMasterHeader_ItemValue_UnitValue_Amount_currencyID.isSet))
								
	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_WorkCenterReference_Description(
		domain	tccwoc		i.ItemMasterHeader_ProcurementParameters_DefaultSource_WorkCenterReference_ID,
	ref	domain	tcdsca		o.ItemMasterHeader_ProcurementParameters_DefaultSource_WorkCenterReference_Description)			
{
	DllUsage
	Old Dll : 
tcbod.dll2505.hook.onget.itemmastercommonbod.itemmasterheader_procurementparameters_defaultsource_workcenterreference_description
	EndDllusage

	RETIFNOK(get.work.center.description(
	  				i.ItemMasterHeader_ProcurementParameters_DefaultSource_WorkCenterReference_ID,
					o.ItemMasterHeader_ProcurementParameters_DefaultSource_WorkCenterReference_Description))
return(0)

}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_Horizons_HorizonDuration(
		domain	tcitem		i.ERPPlanningDataItem,
		domain	tcmcs.str25	i.ERPOrderHorizon,
		domain	tcmcs.str25	i.ERPPlanningHorizon,
	ref	domain	tcmcs.long	o.HorizonDuration(),
	ref		boolean		io.HorizonDuration.isSet() )
{
	DllUsage
	Expl:	The purpose of this function is to get attribute:
		ItemMasterHeader_ProcurementParameters_Horizons_HorizonDuration
	Pre:	- i.ERPOrderHorizon has ISO format.
		- i.ERPPlanningHorizon has ISO format.
	Post:	N.a.
	Args.:	i.ERPPlanningDataItem
		i.ERPOrderHorizon
		i.ERPPlanningHorizon
		o.HorizonDuration
		io.HorizonDuration.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.hook.onget.itemmastercommonbod.itemmasterheader_procurementparameters_horizons_horizonduration
	EndDllUsage

	RETIFNOK( get.horizon.duration(
			i.ERPPlanningDataItem,
			i.ERPOrderHorizon,
			i.ERPPlanningHorizon,
			o.HorizonDuration,		|* Ref
			io.HorizonDuration.isSet ) )	|* Ref

	return( 0 )
}								

function extern long txbod.dll9002.get.horizon.duration.node(
				domain	tcmcs.str30	i.duration.type,
				domain	tcmcs.str30	i.horizon.duration,
			ref	domain	tcmcs.long	o.xml.node,
			ref	boolean			o.xml.node.is.set)
{
	DllUsage
	Old Dll : tcbod.dll0033.get.horizon.duration.node
	EndDllusage
	o.xml.node = 0
	o.xml.node.is.set = false

	NEW_ELEMENT(	"HorizonDuration",
			i.horizon.duration,
			0,
			o.xml.node)

	NEW_ATTRIBUTE(	o.xml.node,
			"HorizonDuration",
			"durationType",
			i.duration.type)

	o.xml.node.is.set = true

	return(0)
} 

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ServiceIndicator(
		domain	tckitm			i.ERPItemType,
	ref 		boolean			o.ItemMasterHeader_ServiceIndicator,
	ref 		boolean			io.ItemMasterHeader_ServiceIndicator.isSet)
{
	DllUsage
	Old Dll : tcbod.dll2505.hook.onget.itemmastercommonbod.itemmasterheader_serviceindicator
	EndDllusage

	RETIFNOK(txbod.dll9002.get.service.indicator(
			i.ERPItemType,
			o.ItemMasterHeader_ServiceIndicator,
			io.ItemMasterHeader_ServiceIndicator.isSet))

	return(0)

}

function extern long txbod.dll9002.get.service.indicator(
		domain	tckitm	i.item.type,
	ref	domain	tcbool	o.indicator,
	ref		boolean	io.indicator.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to execute the 'On Get Hook' of
		attribute 'ServiceIndicator'.
	Pre:	N.a.
	Post:	N.a.
	Args:	i.item.type
		o.ItemMasterHeader_ServiceIndicator
		io.ItemMasterHeader_ServiceIndicator.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2501.get.service.indicator
	EndDllUsage

	on case i.item.type
	case tckitm.cost:
	case tckitm.service:
		o.indicator = INDICATOR_TRUE

		break
	default:
		o.indicator = INDICATOR_FALSE

		break
	endcase

	io.indicator.isSet  = true

	return( 0 )
}		

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_TrackingIndicator(
		domain	tckitm			i.ERPItemType,
	ref 		boolean			o.ItemMasterHeader_TrackingIndicator,
	ref 		boolean			io.ItemMasterHeader_TrackingIndicator.isSet)
{
	DllUsage
	Old Dll : tcbod.dll2505.hook.onget.itemmastercommonbod.itemmasterheader_trackingindicator
	EndDllusage

	RETIFNOK(txbod.dll9002.get.tracking.indicator(
			i.ERPItemType,
			o.ItemMasterHeader_TrackingIndicator,
			io.ItemMasterHeader_TrackingIndicator.isSet))

	return( 0 )

}

function extern long txbod.dll9002.get.tracking.indicator(
		domain	tckitm	i.item.type,
	ref	domain	tcbool	o.indicator,
	ref		boolean	io.indicator.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to execute the 'On Get Hook' of
		attribute TrackingIndicator.
	Pre:	N.a.
	Post:	N.a.
	Args:	i.item.type
		o.ItemMasterHeader_ServiceIndicator
		io.ItemMasterHeader_ServiceIndicator.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2501.get.tracking.indicator
	EndDllUsage

	on case i.item.type
	case tckitm.cost:
	case tckitm.service:
		o.indicator = INDICATOR_FALSE

		break
	default:
		o.indicator = INDICATOR_TRUE

		break
	endcase

	io.indicator.isSet  = true

	return( 0 )
}								

function extern long txbod.dll9002.prepare.publish.data(
		domain	tcbod.mode	i.mode,
		domain	tcncmp		i.company.f,
		domain	tcncmp		i.company.t,
		domain	tcmcs.str70m	i.report.description,
		domain	tcbod.uvrb	i.use.verb,
		domain	tcmcs.str215	i.logical.ids,
		domain	tcyesno		i.logging,
		domain	tcbod.slog	i.log.subject,
		domain	tcyesno		i.log.single.xml,
		domain	tcclsv		i.log.location,
		domain	tcmcs.s512	i.log.directory,
	ref	domain	tcncmp		o.company.stack(),
	ref		long		o.nr.positions.company.stack,
	ref		long		o.report.id )
{
	DllUsage
	Expl:	This function prepares the publishing of data.

		1. The available companies within the specified range will be
		   selected and confirmed by the user.
		2. If companies are confirmed, the publishing report will be
		   opened.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.mode
		i.company.f
		i.company.t
		i.report.description
		i.use.verb
		i.logical.ids
		i.logging
		i.log.subject
		i.log.single.xml	- Yes	Log single XML-files per BOD.
					- No	Log one txt-file for all BODs.
		i.log.location
		i.log.directory
	Output:	o.company.stack
		o.nr.positions.company.stack
		o.report.id
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll0006.prepare.publish.data
	EndDllusage

	domain	tcclsv		l.location
	domain	tcmcs.s512	l.directory

	free.mem( o.company.stack )
	o.nr.positions.company.stack = 0
	o.report.id = 0

	set.show.progress.indicator( false )
	dal.clear.messages( MSG.ALL )

	RETIFNOK( get.confirmed.companies(
			i.mode,
			i.company.f,
			i.company.t,
			i.use.verb,
			i.logical.ids,
			o.company.stack,		|* Ref
			o.nr.positions.company.stack ))|* Ref

	if o.nr.positions.company.stack > 0 then
		|* Disable staging.
		RETIFNOK( txbod.dll9002.disable.staging() )

		RETIFNOK( open.publishing.report(
				i.mode,
				i.report.description,
				o.report.id ))	|* Ref
		|#As we no more use the progress indicator
|		RETIFNOK( initialize.progress.indicator(
|				i.mode,
|				i.report.description ))

		|* Store fields of group settings on form.
		handle.settings( SET_VALUE, i.use.verb, i.logical.ids )

		|* Handle location/directory.
		l.location = i.log.location
		l.directory = i.log.directory

		on case i.log.location
		case PD_SERVER:
			l.directory = convert.directory(
					i.log.location,
					i.log.directory )

			break
		case PD_CLIENT:
			if CLIENT_DOWNLOAD_ZIP_FILE then
			    |* In case of CLIENT_DOWNLOAD_ZIP_FILE a zip file
			    |* has to be created on the server (for more info
			    |* see comment define).

			    |* Therefore, the location for the unzipped log
			    |* file(s) and the zipped log fiel is set to
			    |* 'Server'.
			    l.location = PD_SERVER

			    |* ... and the directory for the unzipped and
			    |* zipped log file(s) is set to:
			    |* 1. Temporary directory of the application +
			    |* 2. publish_data +
			    |* 3. [logname]_[Bshell pid]_[pid]
			    |* Note:
			    |* The directory must be unique to prevent
			    |* clashing between processes.
			    l.directory =
				bse.tmp.dir$() &
				txbod.dll9002.get.path.separator( l.location ) &
				"publish_data" &
				txbod.dll9002.get.path.separator( l.location ) &
				logname$ & "_" &
				str$( bshell.pid() ) & "_" &
				str$( pid )

			    |* At the end of the process, the unzipped log
			    |* file(s) are zipped and downloaded to the client.
			endif

			break
		endcase

		|* Store settings of group logging on form.
		handle.settings.logging(
			SET_VALUE,
			i.mode,
			i.logging,
			i.log.subject,
			i.log.single.xml,
			l.location,
			l.directory )

		initialize.report.control.variables()
	endif

	return( 0 )
}

function extern long txbod.dll9002.disable.staging()
{
	DllUsage
	Expl:	The purpose of this function is to disable staging for the
		current process.
	Pre:	N.a.
	Post:	N.a.
	Input:	N.a.
	Output:	N.a.
	Return:	0/DALHOOKERROR
	Old Dll : bobod.dll0200.disable.staging
	EndDllUsage

	boolean l.staging.disabled

	l.staging.disabled = true

	handle.variable.staging.is.disabled( SET_VALUE, l.staging.disabled )|* Ref

	return( 0 )
}

function extern domain tcbod.svrs txbod.dll9002.get.bod.schema.version()
{
	DLLUsage
	Expl:	This function returns the BOD schema version.

		The BOD schema version as defined in macro
		'LATEST_SCHEMA_VERSION' is returned if:
		- BOD parameters are not present.
		- BOD parameter 'Schema Version Mode' (tcbod000.svmd) is set
		  to 'According Latest Schema Version'.

		The BOD schema version specified in BOD parameter
		'Schema Version' (tcbod000.svrs) is returned if:
		- BOD parameter 'Schema Version Mode (tcbod00.svmd) is set to
		 'Compatible with Schema Version.
	Pre:	N.a.
	Post:	N.a.
	Input:	N.a.
	Output:	N.a
	Return:	BOD schema version
	Old Dll : tcbod.dll0000.get.bod.schema.version
	EndDLLUsage

	if txmcs.dll9001.read.parm( "tcbod000" ) = 0 then
		|* Parameters found.
		if tcbod000.svmd = tcbod.svmd.compatible then
			return( tcbod000.svrs )
		endif
	endif

	return( LATEST_SCHEMA_VERSION )
}

function extern domain tcmcs.long txbod.dll9002.open.publishing.report(
			domain	tcmcs.str15	i.report,
			domain	tcmcs.str14	i.print.device,
			domain	tcmcs.str100	i.report.path,
			domain	tcmcs.str100	i.report.name,
				boolean		i.chained.startup)
{
	DllUsage
		This function will open the prosess/error report
		for the publishing of transactional data for the
		warehousing package.
		In case of a chained startup, the directory for
		the report will be created and the report will
		be opened without user interaction.
		In case of startup from the corresponding UI
		session, the user will get the standard device
		selection screen.
	Pre:	-
	Post:	The process/error report has been opened
	Input:	i.report		Report
		i.print.device		Device for printing upgrade reports
					Mandatory argument in case argument
					i.chained.startup = true.
		i.report.path		Full pathname where upgrade reports
					must be stored. Mandatory argument in
					case argument i.chained.startup = true
		i.report.name		Pathname for storing upgrade reports
					Mandatory argument in case argument
					i.chained.startup = true.
		i.chained.startup	Activation mode true = via central
							chaining utility
							false = via corresp.
							UI session
					Mandatory argument.
	Output: -

	Return:  <= 0 not able to create directory for report or
		      not able to open report
		 > 0  directory has been created and report has
		      been opened successfully
	Old Dll : tcbod.dll0002.open.publishing.report
	EndDllUsage

	if i.chained.startup then
		if mkdir(i.report.path & PATH_SEPARATOR & edit$(get.compnr(),
			 "C")) < 0 then
			|* Not able to create directory
			return(-1)
		endif

		spool.fileout = i.report.path &
				PATH_SEPARATOR &
				edit$(get.compnr(),"C") &
				PATH_SEPARATOR &
				i.report.name

		return(brp.open(strip$(i.report),
				i.print.device,
				0))
	else
		return(brp.open(strip$(i.report),
				"",
				1))
	endif
}

function extern string txbod.dll9002.get.path.separator(
	domain	tcclsv	i.location )
{
	DllUsage
	Expl.	: This function returns the separator to be used depending on
		  the OS of the server.
	Pre	: -
	Post	: -
	Input	: -
	Output	: NA
	Return	: The path separator
	Old Dll : tcbod.dll0011.get.path.separator
	EndDllUsage

	on case i.location
	case PD_CLIENT:
		return( "\" )
	
	|* Related to Republishing Session. 
|t	case PD_SERVER:
|t		return( path.dir.separator( ostype() ) )
	endcase

	return( "" )
}
 
function extern long txbod.dll9002.xml.get.element.value(
				long		i.xml.node,
			const	string		i.path.name,
			const	string		i.domain.code,
		ref	domain	tcmcs.s512m	o.element.value,
		ref	boolean			o.element.value.is.set)
{
	DllUsage
	Expl	: This function gets the value from a node's element
	Pre	: -
	Post	: -
	Input	: i.xml.node	- the xml node to search in
		  i.path.name	- the xml node path e.g.
				  "<Shipment><ShipmentHeader><DocumentID><ID>"
	Output	: o.element.value	- value of this node
		  o.element.value.is.set
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0034.xml.get.element.value
	EndDllUsage

	VAL_RETIFNOK( CALL_FUNCTION(
		txbod.dll9002.xml.get.value.of.element,
		i.xml.node,
		i.path.name,
		"",				|* Attribute
		"",				|* Attribute value
		i.domain.code,
		o.element.value,		|* Ref
		o.element.value.is.set ))	|* Ref

	return(0)
}

function extern long txbod.dll9002.xml.get.value.of.element(
	const	long	i.node,
	const	string	i.element,
	const	string	i.attribute,
	const	string	i.attribute.value,
	const	string	i.domain,
	ref	string	o.value,
	ref	boolean	o.value.is.set,
       [	boolean	i.is.mandatory] )
{
	#define	ARG_ELEMENT_IS_MANDATORY	8

	FunctionUsage
	Expl:	The purpose of this function is to return the value of the
		first find specified element.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.node
		i.element	- <element> or ?<element>
				  Example:
				   <Shipment><ShipmentHeader><DocumentID>
				   ?<Shipment><ShipmentHeader><DocumentID>
		i.attribute	- Optional
		i.attribute.value - Optional
		i.domain	- Optional

		1. Only i.element filled:
			Return value of specified element.
		2. i.element and i.attribute filled:
			Return value of specified element with specified
			attribute.
		3. i.element, i.attribute and i.attribute.value filled.
			Return value of specified element with specified
			attribute and specified attribute value.
	Output:	o.value
		o.value.is.set
	Input:	i.is.mandatory	- Optional (default is false).
	Return:	0/DALHOOKERROR
	Old Dll : bobod.dll1034.xml.get.element.value
	EndFunctionUsage

	o.value = ""
	o.value.is.set = false

	|* Check input arguments.
	|* Return 0 if node or element name are not specified.
	if i.node = 0 or
	   isspace( i.element ) then
		|* No action.
	else
		if get.argc() = ARG_ELEMENT_IS_MANDATORY then
			i.is.mandatory =
				get.boolean.arg(ARG_ELEMENT_IS_MANDATORY)
		else
			i.is.mandatory = false
		endif

		RETIFNOK( xml.get.value(
				GET_ELEMENT,
				i.node,
				i.element,
				i.attribute,
				i.attribute.value,
				i.domain,
				i.is.mandatory,
				o.value,		|* Ref
				o.value.is.set ))	|* Ref
	endif

	return( 0 )
}

function extern long txbod.dll9002.xml.get.attribute.value(
				long		i.xml.node,
			const	string		i.path.name,
			const	string		i.attribute.name,
		ref	domain	tcmcs.s512m	o.attribute.value,
		ref	boolean			o.attribute.value.is.set,
       [	boolean	i.is.mandatory] )
{
	DllUsage
	Expl	: This function gets the value from a node's attribute
	Pre	: -
	Post	: -
	Input	: i.xml.node
		  i.path.name		- the xml node path
				  e.g. "<Shipment><ShipmentHeader><DocumentID>"
		  i.attribute.name.name	- name of the attribute
				  e.g. "agencyRole"
	Output	: o.attribute.value	- value of this attribute
		  o.attribute.value.is.set
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0034.xml.get.attribute.value
	EndDllUsage
	
	#define	ARG_ATTRIBUTE_IS_MANDATORY	6

	o.attribute.value = ""
	o.attribute.value.is.set = false

	|* Check input arguments.
	|* Return 0 if node, element name or attribute name are not specified.
	if i.xml.node = 0 or
	   isspace( i.path.name ) or
	   isspace( i.attribute.name ) then
		|* No action.
	else
		if get.argc() = ARG_ATTRIBUTE_IS_MANDATORY then
			i.is.mandatory =
				get.boolean.arg(ARG_ATTRIBUTE_IS_MANDATORY)
		else
			i.is.mandatory = false
		endif

		RETIFNOK( xml.get.value(
				GET_ATTRIBUTE,
				i.xml.node,
				i.path.name,
				i.attribute.name,
				"",			|* Attribute value
				"",			|* Domain
				i.is.mandatory,
				o.attribute.value,		|* Ref
				o.attribute.value.is.set ))	|* Ref
	endif

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterBOD.ItemMasterHeader_DisplayID(
		domain	tcitem		i.ERPItem,
			boolean		i.ERPItem.isSet,
		domain	tcmcs.str6	i.ERPRevision,
			boolean		i.ERPRevision.isSet,
	ref	domain	tcmcs.str100	o.ItemMasterHeader_DisplayID,
	ref		boolean		io.ItemMasterHeader_DisplayID.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to compose the DisplayID, based
		on the item and the revision.

		A decompose is not possible, because the DisplayID is trimmed.
		A found revision at the end of the DisplayID, can be a
		revision or part of the standard item description.
	Pre:	N.a.
	Post:	N.a.
	Args:	i.ERPItem
		i.ERPItem.isSet
		i.ERPRevision
		i.ERPRevision.isSet
		o.ItemMasterHeader_DisplayID
		io.ItemMasterHeader_DisplayID.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2501.hook.onget.itemmasterbod.itemmasterheader_displayid
	EndDllUsage

		long		l.segment.no
		long		l.nr.segments
		long		l.size.dimensions(4)
		long		l.dummy.nr.dimensions
	domain	tcmcs.byte	l.start.position.stack(1) based
	domain	tcmcs.byte	l.length.segment.stack(1) based
	domain	tcibd.apco	l.application.content.stack(1) based

	o.ItemMasterHeader_DisplayID = ""
	io.ItemMasterHeader_DisplayID.isSet = false

	|* Read the segementation data.
	txibd.dll9001.read.field.segments.by.package.and.domain(
		"tx",				|* Package
		"item",				|* Domain
		l.start.position.stack,		|* Ref
		l.length.segment.stack,		|* Ref
		l.application.content.stack )	|* Ref

    
	|* Get the array info of the segmentation data.
	array.info(
		l.application.content.stack,
		l.dummy.nr.dimensions,	|* Ref
		l.size.dimensions )	|* Ref

	l.nr.segments = l.size.dimensions(1)

	|* Add spaces between the segments.
	for l.segment.no = 1 to l.nr.segments
		o.ItemMasterHeader_DisplayID =
			o.ItemMasterHeader_DisplayID &
			i.ERPItem( l.start.position.stack(l.segment.no);
				   l.length.segment.stack(l.segment.no)) & " "
	endfor

	if not isspace( i.ERPRevision ) then
		o.ItemMasterHeader_DisplayID =
			trim$( o.ItemMasterHeader_DisplayID ) & " " &
			trim$( i.ERPRevision )
	endif

	if not isspace( o.ItemMasterHeader_DisplayID ) then
		io.ItemMasterHeader_DisplayID.isSet = true
	endif

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemLocation_ItemValue_UnitValue_Amount_currencyID(
		domain	tcccur	i.ERPCurrency,
	ref	domain	tcccur	o.ItemValue_UnitValue_Amount_currencyID,
	ref		boolean	io.ItemValue_UnitValue_Amount_currencyID.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.hook.onget.itemlocation_itemvalue_unitvalue_amount_currencyid
	EndDllusage

	RETIFNOK(get.item.value.amount.currency(
			i.ERPCurrency,
			o.ItemValue_UnitValue_Amount_currencyID,
			io.ItemValue_UnitValue_Amount_currencyID.isSet))

	return(0)
}

function extern long txbod.dll9002.calculate.cms.margin.control(
						domain tcorno orno,
						domain tcpono pono,
						domain tcqsl1 oqua,
						domain tcconv cvps,
						domain tcconv cvqs,
						domain tcccur ccur,
						domain tccrnd crnd,
					ref	domain tcpric margin.value)
{
	DllUsage
	Expl:	This method  calculates the rebate/commission value for margin
		control.
	Pre
	Post
	Input	orno	order number
		pono	position number
		oqua	order quantity
		cvps	conversion factor from price unit to inventory
		cvqs	conversion factor from sales unit to inventory
		curr	currency
		crnd	rounding factor
	Output	margin.value	is 0 if cms is not included in margin control
				if <> 0 then is this a price amount
	Return	0
	Old Dll : tdcms.dll0009.calculate.cms.margin.control
	EndDllUsage

	long		l.comm.margin
	long		l.rebt.margin
	long		l.home.ccur.position
	domain	tcamnt	l.margin.amount
	domain	tcncmp	l.finance.company
		boolean	l.first.record

	margin.value = 0.0
	l.margin.amount = 0.0
	l.first.record = true

	RETIFNOK(txmcs.dll9001.read.parm("tdcms000"))			

	if not commissions.margin.control.allowed() and
	   not rebates.margin.control.allowed() then
		return(0)
	endif							

	select	tdcms050.*
	from	tdcms050
	where	tdcms050._index4 = {:orno, :pono}
	selectdo
		if l.first.record then
			l.finance.company = txsls.dll9001.financial.company.of.department(
						tdcms050.fdpt)
			itxcom0000.get.multi.currency.data(l.finance.company)
			if STANDARD_CURR then
				l.home.ccur.position = 1
			else
				l.home.ccur.position = itxcom0000.pcur
			endif
			l.first.record = false
		endif
		select	tdcms010.calm
		from	tdcms010
		where	tdcms010._index1 = {:tdcms050.reln}
		as set with 1 rows
		selectdo
		endselect
		if tdcms010.calm = tdcms.cmcm.order and
		  ((tdcms050.type = tdcms.type.commission and l.comm.margin) or
		   (tdcms050.type = tdcms.type.rebate and l.rebt.margin)) then
			l.margin.amount = l.margin.amount +
			       tdcms050.cmam(l.home.ccur.position)
		endif
	endselect
	if oqua <> 0 and cvqs <> 0 then
		margin.value = ((l.margin.amount / oqua) * (cvps / cvqs))
		margin.value =  txmcs.dll9001.round.pric(margin.value,
						   ccur,
						   crnd)
	endif
	return(0)
}

function extern long txbod.dll9002.Hook.OnGet.ItemLocation_ProcurementParameters_Horizons_HorizonDuration(
		domain	tcitem		i.ERPPlanningDataItem,
		domain	tcmcs.str25	i.ERPOrderHorizon,
		domain	tcmcs.str25	i.ERPPlanningHorizon,
	ref	domain	tcmcs.long	o.HorizonDuration(),
	ref		boolean		io.HorizonDuration.isSet() )
{
	DllUsage
	Expl:	The purpose of this function is to get attribute:
		ItemMasterHeader_ProcurementParameters_Horizons_HorizonDuration
	Pre:	- i.ERPOrderHorizon has ISO format.
		- i.ERPPlanningHorizon has ISO format.
	Post:	N.a.
	Args.:	i.ERPPlanningDataItem
		i.ERPOrderHorizon
		i.ERPPlanningHorizon
		o.HorizonDuration
		io.HorizonDuration.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.hook.onget.itemlocation_procurementparameters_horizons_horizonduration
	EndDllUsage

	RETIFNOK( get.horizon.duration(
			i.ERPPlanningDataItem,
			i.ERPOrderHorizon,
			i.ERPPlanningHorizon,
			o.HorizonDuration,		|* Ref
			io.HorizonDuration.isSet ) )	|* Ref

	return( 0 )
}								

function extern long txbod.dll9002.db.update(
	const		string		i.table,
					...)
{
	DllUsage
	Expl.:	Function can be used to execute the db.update in combination
		with a check on Pending status for Workflow.
		When the Pending error is not handled, a BW error will occur.
	Pre:	Record must be selected for update; retry point must be set.
	Post:	Transaction must be committed / aborted.
	Input:	i.table
		... - when other error flags must be taken into account, these
			flags can be passed as variable inputargument (e.g.
			db.skip.dupl)
	Output:	NA
	Return:	0 if ok,
		<> 0 if not ok (221 if record is Pending for Workflow)
	Old Dll : tdgen.dll0100.db.update
	EndDllUsage

			long		l.number.of.arguments
			long		l.error.flag
			long		i

	l.error.flag = 0

	l.number.of.arguments = get.argc()
	for i = 2 to l.number.of.arguments
		l.error.flag = l.error.flag + get.long.arg(i)
	endfor

	return(execute.db.action(	DB.MODE.UPDATE,
					i.table,
					l.error.flag))
}

function extern boolean txbod.dll9002.procurement.is.implemented(
			boolean		i.set.message)
{
	DllUsage
	Expl:	This function checks if procurement (dsri) is implemented.
		Note that tccom000 data of current company are current after
		the function call.
		Note: Currently, only one Order Management concept parameter
		exists, but for future reasons in TD it is already split in
		three functions for Procurement, Sales and Pricing.
	Pre:	preconditions
	Post:	tccom000 data of current company are current
	Input:	i.set.message	-
	Output:
	Return:	boolean
	Old Dll : tdgen.dll0000.procurement.is.implemented
	EndDllUsage

	if not order.management.implemented() then
		if i.set.message then
			dal.set.error.message(
				"txcom00016",
				|* txcom00016  ???
	   			tt.field.desc("tccom000.dsri"),
				tt.table.desc("tccom000"))
		endif
		return(false)
	endif

	return(true)
}

function extern boolean txbod.dll9002.configurator.is.implemented(
			boolean		i.set.message)
{
	DllUsage
	Expl:	This function checks if Assembly planning (cfri) or
		Product Configurator (pcfi) is implemented.
		Note that tccom000 data of current company are current after
		the function call.
	Pre:	preconditions
	Post:	tccom000 data of current company are current
	Input:	i.set.message	-
	Output:
	Return:	boolean
	Old Dll : tdgen.dll0000.configurator.is.implemented
	EndDllUsage

	if not txgen.dll9001.assembly.is.implemented(false) and
	   not txgen.dll9001.product.configurator.is.implemented(false) and
	   not txgen.dll9001.cpq.configurator.is.implemented(false) then
		if i.set.message then
			dal.set.error.message(
				"txcom00066",
				|* Concepts '%1$s',  '%2$s' and '%3$s'  have not
				|* been implemented in %4$s.
	   			tt.field.desc("tccom000.asci"),
	   			tt.field.desc("tccom000.pcfi"),
	   			tt.field.desc("tccom000.acfg"),
	   			tt.table.desc("tccom000"))
		endif
		return(false)
	endif

	return(true)
}


function extern boolean txbod.dll9002.project.pegging.for.company.implemented(
		domain	tcncmp		i.company,
			boolean		i.set.message)		
{
	DllUsage
	Expl:	This function checks if project pegging functionality is
		implemented.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.company
	Output:	i.set.message
	Return:	True/False
	Old Dll : tdgen.dll0000.project.pegging.for.company.implemented
	EndDllUsage

	|* Declare local variables
		domain	tcncmp		l.company
		boolean			l.result
 
	|* Initialize
	l.company = 0
	l.result = false

	l.company = get.compnr()

	if not i.set.message then				
|t		STOP.MESSAGES
	endif							

	if txcom.dll9001.switch.to.company(i.company) = 0 then
		l.result = txcom.dll9001.project.pegging.implemented()
		if not l.result and				
		   i.set.message then
			dal.set.error.message(
				"txcom00016",
				|* txcom00016  ???
	   			tt.field.desc("tccom000.spsp"),
				tt.table.desc("tccom000"))
		endif						

		if txcom.dll9001.switch.back.to.company(l.company) <> 0 then
			|* error message set in function
			l.result = false
		endif
	else
		|* error message set in function
		l.result = false
	endif

	if not i.set.message then				
|t		START.MESSAGES
	endif							

	return(l.result)
}			

function extern boolean txbod.dll9002.subcontracting.with.wip.manufacturer.is.implemented(
			boolean		i.set.message)
{
	DllUsage
	Expl:	This function checks if subcontracting with wip manufacturer (smfm) is implemented.
		Note that tccom000 data of current company are current after
		the function call.
	Pre:	preconditions
	Post:	tccom000 data of current company are current
	Input:	i.set.message	-
	Output:
	Return:	boolean
	Old Dll : tdgen.dll0000.subcontracting.with.wip.manufacturer.is.implemented
	EndDllUsage

	if not subcontracting.with.wip.manufacturer.implemented() then
		if i.set.message then
			dal.set.error.message(
				"txcom00016",
				|* txcom00016  ???
	   			tt.field.desc("tccom000.smfm"),
				tt.table.desc("tccom000"))
		endif
		return(false)
	endif

	return(true)
}

function extern boolean txbod.dll9002.freight.management.is.implemented(
			boolean		i.set.message)
{
	DllUsage
	Expl:	This function checks if Freight Management (frmi) is implemented.
		Note that tccom000 data of current company are current after
		the function call.
	Pre:	preconditions
	Post:	tccom000 data of current company are current
	Input:	i.set.message	-
	Output:
	Return:	boolean
	Old Dll : tdgen.dll0000.freight.management.is.implemented
	EndDllUsage

	if not freight.management.implemented() then
		if i.set.message then
			dal.set.error.message(
				"txcom00016",
				|* txcom00016  ???
	   			tt.field.desc("tccom000.frmi"),
				tt.table.desc("tccom000"))
		endif
		return(false)
	endif

	return(true)
}		


function extern boolean txbod.dll9002.service.is.implemented(
			boolean		i.set.message)
{
	DllUsage
	Expl:	This function checks if service (srvi) is implemented.
		Note that tccom000 data of current company are current after
		the function call.
	Pre:	preconditions
	Post:	tccom000 data of current company are current
	Input:	i.set.message	-
	Output:
	Return:	boolean
	Old Dll : tdgen.dll0000.service.is.implemented
	EndDllUsage

	if not service.implemented() then
		if i.set.message then
			dal.set.error.message(
				"txcom00016",
				|* txcom00016  ???
	   			tt.field.desc("tccom000.srvi"),
				tt.table.desc("tccom000"))
		endif
		return(false)
	endif

	return(true)
}


function extern boolean txbod.dll9002.publishing.allowed()
{
	DllUsage
	Expl	: This function checks if publishing is allowed.
	pre	: NA
	post	: NA
	Input	: NA
	Output	: NA
	return	: true	if publishing is allowed
		  false	if publishing is not allowed
	Old Dll : tcbod.dll0001.publishing.allowed
	EndDllUsage

	string	env.var

	if get.skip.publishing.bods() = true then
		return(false)
	endif

	env.var = getenv$("PUBLISH_BOD")

	if env.var = "1" then
		return(true)
	endif

	if prevent.bod.publishing() = false then
		return(true)
	endif

	|* From publish data sessions, publishing must be enabled for mode
	|* 'Simulate', independent of BOD parameter 'Prevent BOD Publishing'
	|* (tcbod000.prbp).
	if txbod.dll9002.called.from.publish.data.session() then
		return( true )
	endif

	return(false)
}


function extern long txbod.dll9002.bod.metadata.exists(
			domain	tcbod.name	i.noun)
{
	DllUsage
	Expl	: This function checks if the bod is available.
		  Error message is set when no metadata found for the BOD.
	Pre	: -
	Post	: -
	Input	: i.noun	- BOD name (e.g. CodeDefinitionBOD)
	Output	: -
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : bobod.dll1000.bod.metadata.exists
	EndDllUsage

	RETIFNOK(bod.metadata.exists(i.noun))

	return(0)
}


function extern long txbod.dll9002.get.bod.public(
		domain	tcbod.name	i.noun,
	ref	domain	tcbod.name	o.public.noun)
{
	DllUsage
	Expl	: This function retrieves the public BOD.
		  Error message is set when no metadata found for the BOD.
	Pre	: -
	Post	: -
	Input	: i.noun	- BOD name (e.g. CodeDefinitionBOD)
	Output	: o.public.noun	- Public BOD name (e.g. CodeDefinitionBOD)
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0032.get.bod.public
	EndDllUsage

	domain	bobod.type	dummy.type
	domain	bobod.impl	dummy.identifier

	RETIFNOK( txbod.dll9002.get.bod.metadata.by.name(
			i.noun,
			dummy.identifier,	|* Ref: Ident. protected BOD
			o.public.noun,		|* Ref
			dummy.identifier,	|* Ref: Identifier public BOD
			dummy.type ))		|* Ref

	return( 0 )
}

 


function extern string txbod.dll9002.convert.noun.name.to.without.bod(
			domain	tcbod.name	i.noun)
{
	DllUsage
	Expl	: This function returns the business object name of a specified
		  BOD without the postfix BOD.

		  For example:
		  i.noun = InventoryAdjustmentBOD
		  return value function = InventoryAdjustment
	Pre	: -
	Post	: -
	Input	: i.noun
	Output	: -
	Return	: Busines object name
	Old Dll : tcbod.dll0031.convert.noun.name.to.without.bod
	EndDllusage

	long	position

	domain	tcbod.name	noun

	position = rpos(i.noun, "BOD")

	if position = 0 then
		noun = i.noun
	else
		noun = i.noun(1;position - 1 )
	endif
		|* CodeDefinitionMetaFlexDimensionBOD
		|* 0        1         2         3
		|* 1234567890123456789012345678901234
		|*                                |
		|*                                32
		|* 31 characters must be returned.
	return(noun)
}


 
function extern boolean txbod.dll9002.get.custom.bod.verbs(
				domain	tcbod.name	i.name,
				domain	tcbod.impl	i.identifier,
				ref	long		o.receive.verbs,
				ref	long		o.send.verbs)
{
	DllUsage
	Expl:	This function returns the implmented Verbs of a Custom BOD.
	Input:	i.name
	Output:	o.receive.verbs
		o.send.verbs
	Return:	TRUE 	- BOD found
		FALSE 	- BOD not found
	Old Dll : bobod.dll1004.get.custom.bod.verbs
	EndDllusage

		boolean		on.sync.implemented
		boolean		on.load.implemented
		boolean		on.process.implemented
		boolean		on.get.implemented
		boolean		on.show.implemented
		boolean		on.update.implemented
		boolean		on.post.implemented
		boolean		on.acknowledge.implemented
		boolean		publish.sync.implemented
		boolean		publish.load.implemented
		boolean		publish.process.implemented
		boolean		publish.get.implemented
		boolean		publish.show.implemented
		boolean		publish.update.implemented
		boolean		publish.post.implemented
		boolean		publish.acknowledge.implemented

	long	retval

	o.receive.verbs = 0
	o.send.verbs = 0

	retval = txbod.dll9002.get.custom.implemented.methods(
			i.name,
			i.identifier,
			on.sync.implemented,		|* Ref
			on.load.implemented,		|* Ref
			on.process.implemented,		|* Ref
			on.get.implemented,		|* Ref
			on.show.implemented,		|* Ref
			on.update.implemented,		|* Ref
			on.post.implemented,		|* Ref
			on.acknowledge.implemented,	|* Ref
			publish.sync.implemented,	|* Ref
			publish.load.implemented,	|* Ref
			publish.process.implemented,	|* Ref
			publish.get.implemented,	|* Ref
			publish.show.implemented,	|* Ref
			publish.update.implemented,	|* Ref
			publish.post.implemented,	|* Ref
			publish.acknowledge.implemented)|* Ref

	o.receive.verbs = 0
	if on.sync.implemented then
		o.receive.verbs = o.receive.verbs + B_SYNC
	endif
	if on.load.implemented then
		o.receive.verbs = o.receive.verbs + B_LOAD
	endif
	if on.process.implemented then
		o.receive.verbs = o.receive.verbs + B_PROCESS
	endif
	if on.get.implemented then
		o.receive.verbs = o.receive.verbs + B_GET
	endif
	if on.update.implemented then
		o.receive.verbs = o.receive.verbs + B_UPDATE
	endif

	o.send.verbs = 0
	if publish.sync.implemented then
		o.send.verbs = o.send.verbs + B_SYNC
	endif
	if publish.load.implemented then
		o.send.verbs = o.send.verbs + B_LOAD
	endif
	if publish.process.implemented then
		o.send.verbs = o.send.verbs + B_PROCESS
	endif
	if publish.get.implemented then
		o.send.verbs = o.send.verbs + B_GET
	endif
	if publish.update.implemented then
		o.send.verbs = o.send.verbs + B_UPDATE
	endif

	return(retval = 0)
}

function extern long txbod.dll9002.get.custom.implemented.methods(
		domain	tcbod.name	i.bod,
		domain	tcbod.impl	i.identifier,
	ref		boolean		o.on.sync.implemented,
	ref		boolean		o.on.load.implemented,
	ref		boolean		o.on.process.implemented,
	ref		boolean		o.on.get.implemented,
	ref		boolean		o.on.show.implemented,
	ref		boolean		o.on.update.implemented,
	ref		boolean		o.on.post.implemented,
	ref		boolean		o.on.acknowledge.implemented,
	ref		boolean		o.publish.sync.implemented,
	ref		boolean		o.publish.load.implemented,
	ref		boolean		o.publish.process.implemented,
	ref		boolean		o.publish.get.implemented,
	ref		boolean		o.publish.show.implemented,
	ref		boolean		o.publish.update.implemented,
	ref		boolean		o.publish.post.implemented,
	ref		boolean		o.publish.acknowledge.implemented )
{
	DllUsage
	Old Dll : bobod.dll1004.get.custom.implemented.methods
	EndDllUsage
	
	long	used.size.function.tree.stacks
	long	pointer.function.tree.stack(1) based
	long	return.value
	string	function.tree.stack(1,1) based
	boolean	bod.dlls.generated

	#define ERROR_ROUTINE_GET_IMPLEMENTED_METHODS
^		INITIALIZE_GET_IMPLEMENTED_METHODS
^		return( return.value )

	#define	INITIALIZE_GET_IMPLEMENTED_METHODS
^		free.mem( pointer.function.tree.stack )
^		free.mem( function.tree.stack )
^		used.size.function.tree.stacks = 0

	o.on.sync.implemented = false
	o.on.load.implemented = false
	o.on.process.implemented = false
	o.on.get.implemented = false
	o.on.show.implemented = false
	o.on.update.implemented = false
	o.on.post.implemented = false
	o.on.acknowledge.implemented = false
	o.publish.sync.implemented = false
	o.publish.load.implemented = false
	o.publish.process.implemented = false
	o.publish.get.implemented = false
	o.publish.show.implemented = false
	o.publish.update.implemented = false
	o.publish.post.implemented = false
	o.publish.acknowledge.implemented = false

	INITIALIZE_GET_IMPLEMENTED_METHODS

	|* Check if BOD DLLs (sb/st) are present.
	return.value = custom.bod.dlls.generated.on.backend(
			i.bod,
			i.identifier,
			bod.dlls.generated )	|* Ref

	if return.value <> 0 then
		ERROR_ROUTINE_GET_IMPLEMENTED_METHODS
	endif

	if not bod.dlls.generated then
		return( 0 )	|* Early return.
	endif

	|* Get all 'OnExecute'-hooks of the incoming events with the implemented
	|* function tree.
	return.value = get.implemented.function.tree.on.execute.hooks(
			i.bod,
			i.identifier,
			function.tree.stack,			|* Ref
			pointer.function.tree.stack,		|* Ref
			used.size.function.tree.stacks )	|* Ref

	if return.value <> 0 then
		ERROR_ROUTINE_GET_IMPLEMENTED_METHODS
	endif

	return.value = determine.implemented.methods.incoming.bods(
			i.bod,
			i.identifier,
			function.tree.stack,
			pointer.function.tree.stack,
			used.size.function.tree.stacks,
			o.on.sync.implemented,		|* Ref
			o.on.load.implemented,		|* Ref
			o.on.process.implemented,	|* Ref
			o.on.get.implemented,		|* Ref
			o.on.show.implemented,		|* Ref
			o.on.update.implemented,	|* Ref
			o.on.post.implemented,		|* Ref
			o.on.acknowledge.implemented)	|* Ref

	if return.value <> 0 then
		ERROR_ROUTINE_GET_IMPLEMENTED_METHODS
	endif

	|* Get the implemented publish events.
	return.value = get.implemented.methods.outgoing.bods(
			i.bod,
			i.identifier,
			o.on.process.implemented,
			o.publish.sync.implemented,		|* Ref
			o.publish.load.implemented,		|* Ref
			o.publish.process.implemented,		|* Ref
			o.publish.get.implemented,		|* Ref
			o.publish.show.implemented,		|* Ref
			o.publish.update.implemented,		|* Ref
			o.publish.post.implemented,		|* Ref
			o.publish.acknowledge.implemented)	|* Ref

	if return.value <> 0 then
		ERROR_ROUTINE_GET_IMPLEMENTED_METHODS
	endif

	return( 0 )
}

function extern boolean txbod.dll9002.staging.is.never.applicable()
{
	DllUsage
	Expl  : This function determines if the parameter Staging
		is supported.
	pre   : NA
	post  : NA
	Input : NA
	Output: NA
	return: true	if NOT supported
		false	if supported
	Old Dll : bobod.dll1000.staging.is.never.applicable
	EndDllUsage

	boolean	supported

	supported = TRY_FUNCTION(
			txbod.dll9002.bod.parameter.supported.in.this.fp,
			PARM_STAGING)
 

	if supported then
		return(false)
	endif

	return(true)
}

function extern boolean txbod.dll9002.sync.processing.is.never.applicable()
{
	DllUsage
	Expl  : This function determines if the parameter Synchronous Processing
		is supported.
	pre   : NA
	post  : NA
	Input : NA
	Output: NA
	return: true	if NOT supported
		false	if supported
	Old Dll : bobod.dll1000.sync.processing.is.never.applicable
	EndDllUsage

	boolean	supported					

	supported = TRY_FUNCTION(
			txbod.dll9002.bod.parameter.supported.in.this.fp,
			PARM_SYNC_PROCESSING)

	if supported then
		return(false)
	endif							

	return(true)
}

function extern boolean txbod.dll9002.bod.parameter.supported.in.this.fp(
			domain	tcmcs.str100	i.parameter.name)
{
	DllUsage
	Expl	: This function checks if a specific BOD parameter is
		  supported in this FP (Feature Pack).
		  - When a BOD parameter is not supported anymore, it
		    should be removed from this function.
		  - When a new BOD parameter is supported, it
		   should be added to this function.
	pre	: NA
	post	: NA
	Input	: i.parameter.name
	Output	: NA
	return	: true		if supported
		  false		if not supported
	Old Dll : tcbod.dll0020.bod.parameter.supported.in.this.fp
	EndDllUsage

	|* in alphabetical order

	on case trim$(i.parameter.name)

	case "STAGING":
	case "SYNC_PROCESSING":
		return(true)
	endcase

	return(false)
}
function extern boolean txbod.dll9002.staging.is.derived(
				domain	bobod.name	i.bod.name,
				domain	bobod.type	i.bod.type,
			ref	domain	boyesno		o.parm.staging)
{
	DllUsage
	Expl  : This function executes the following 2 things for the parameter
		Staging:
		1. It sets the default value
		2. It determines if the value can be modified
	pre   : NA
	post  : NA
	Input : i.bod.name
	Output: o.parm.staging
	return: true	if parameter cannot be changed
		false	if parameter can be changed
	Old Dll : bobod.dll0000.staging.is.derived
	EndDllUsage

	|* Why BOD is added to the case statement must be described.
	on case trim$(i.bod.name)

	|***************
	|* YES and true
	|***************
	case "ProjectBudgetBOD":
	case "ProjectBudgetTimePhasedBOD":
		|* ProjectBudget is staged mandatory for performance and
		|* processing logic reasons. The publishing of a ProjectBudget
		|* BOD requires the temporary storage of the data in an
		|* interim table (tpptc310), from which table the calculated
		|* budget lines are published."
	case "PriceListBOD":
		|* A huge BOD, staging is mandatory.
		|* If not staged, a BOD is not published.
		|* Only a trigger on line level is made (and on the
		|* PCG parameters).
	case "LnResourceCalendarBOD":				
		|* Lot of records can be published for one calendar
		|* when a collective update has been executed.
	case "LnServiceContractBalanceBOD":
	case "LnServiceContractBalanceEstRevenueBOD":
	case "LnServiceContractBalanceActRevenueBOD":
	case "LnServiceContractBalanceActCostBOD":
		|* Header table is also line table. Multiple lines can be
		|* below same header. Always group staging is used.
		|* Otherwise, too much BODs are published.
								
	case "PayableTrackerInvoiceBOD":
	case "PayableTrackerPaymentBOD":
	case "ReceivableTrackerInvoiceBOD":
	case "ReceivableTrackerReceiptBOD":
		|* The Tracker BODs are triggered in the finalization process
		|* but do not use the tfbia810 table. The finalization process
		|* should not abort if a BOD publishing error occurs. Therefore
		|* staging is mandatory.
								
		|**************************************************************
		|* Mandatory staged.
		|**************************************************************
		o.parm.staging = boyesno.yes
		return(true)

	|***************
	|* NO and true
	|***************
	case "SecurityPermissionMasterBOD":
	case "SecurityRoleMasterBOD":
	case "SecurityUserMasterBOD":
		|* - Security BODs:
		|* Separately staged and published through Publish Security
		|* Data (ttbod0200m000) session.

		|**************************************************************
		|* Mandatory not staged:
		|**************************************************************
		o.parm.staging = boyesno.no
		return(true)

	|***************
	|* NO and false
	|***************
	case "LnVendorRatingBOD":
		|* Additional triggering is implemented in tdpur8850m000.
	case "ProjectContractBOD":
	case "SupplierQuoteBOD":				
	case "SupplierQuoteSubLineBOD":
		|* Default not staged, but should be staged if triggered
		|* from an incoming Process.SupplierQuoteBOD and autom.
		|* published at end of processing incoming BOD.	

		|**************************************************************
		|* Default not staged.
		|**************************************************************
		o.parm.staging = boyesno.no
		return(false)

	|***************
	|* YES and false
	|***************
	case "LnMaintenanceSalesOrderBOD":			
	case "LnClaimCustomerBOD":
	case "LnClaimSupplierBOD":
	case "OpportunityBOD":
	case "ProductionOrderSFCBOD":
	case "PurchaseOrderBOD":
	case "SalesOrderBOD":
		|* - OpportunityBOD
		|* - ProductionOrderSFCBOD
		|* - PurchaseOrderBOD
		|* - SalesOrderBOD
		|* Additional triggering implemented on sub level.
	case "ServiceOrderBOD":
	case "ServiceOrderWorkOrderBOD":
		|* Additional triggering was implemented for mobile service.
	case "TransferBOD":
		|* Additional triggering was implemented to solve issue with
		|* generation of Planned WH orders

		|**************************************************************
		|* Default staged.
		|**************************************************************
		o.parm.staging = boyesno.yes
		return(false)
	endcase

	if pos( i.bod.name, "CodeDefinition" ) = 1 then		
		|* - All CodeDefinition BODs.
		|* Combination of BOD / DocumentID is not unique.
		|* ListID makes the BOD unique, but is not stored as an
		|* identifier in the staging table.

		|**************************************************************
		|* Mandatory not staged:
		|**************************************************************
		o.parm.staging = boyesno.no
		return(true)
	endif							

	on case i.bod.type
	case bobod.type.balance:
	case bobod.type.system:
	case bobod.type.transactional:
		|**************************************************************
		|* Mandatory not staged.
		|**************************************************************
		o.parm.staging = boyesno.no
		return(true)
	endcase

	|**********************************************************************
	|* Default not staged (Master Data).
	|**********************************************************************
	o.parm.staging = boyesno.no

	return(false)
}

function extern boolean txbod.dll9002.sync.processing.is.derived(
				domain	bobod.name	i.bod.name,	
			ref	domain	boyesno		o.parm.sync.processing)
{
	DllUsage
	Expl  : This function executes the following 2 things for the parameter
		Synchronous Processing:
		1. It sets the default value
		2. It determines if the value can be modified
	pre   : NA
	post  : NA
	Input : i.bod.name
	Output: o.parm.sync.processing
	return: true	if parameter cannot be changed
		false	if parameter can be changed
	Old Dll : bobod.dll0000.sync.processing.is.derived
	EndDllUsage

								
	on case trim$(i.bod.name)
|	case "AdvanceShipNoticeBOD":				
	case "AdvanceShipNoticeInBOD":				
	case "CustomerRemittanceAdviceInBOD":			
	case "ExpenseReportBOD":				
	case "PayrollAdviceInBOD":				
	case "PersonnelInBOD":					
	case "PlanningScheduleReleaseBOD":
	case "PurchaseOrderInBOD":
	case "ReceiveDeliveryWarehousingBOD":
	case "SalesOrderInBOD":
	case "SalesOrderInLn106BOD":				
|	case "ShipmentOutBOD":					
	case "ShipmentInBOD":					
	case "ShipmentScheduleReleaseBOD":
	case "ShipmentScheduleReleasePUSBOD":
	case "SequenceScheduleBOD":				
		break
	default:
		o.parm.sync.processing = boyesno.no	
|		o.parm.sync.processing = tcyesno.no		
		return(true)
	endcase

	o.parm.sync.processing = boyesno.no		
|	o.parm.sync.processing = tcyesno.no			
								

	return(false)
}

function extern long txbod.dll9002.get.bod.metadata.by.name(
		const	string		i.name,
	ref	domain	bobod.impl	o.implementation.identifier,
	ref	domain	bobod.name	o.public.bod,
	ref	domain	bobod.impl	o.public.implementation.identifier,
	ref	domain	bobod.type	o.bod.type)
{
	DllUsage
	Expl	: This function retrieves the BOD meta data.
		  Error message is set when no metadata found for the BOD.
	pre	: NA
	post	: NA
	Input	: i.name			- BOD name
						 (e.g. CodeDefinitionBOD)
	Output	: o.implementation.identifier
	return	: 0/DALHOOKERROR
	Old Dll : bobod.dll0000.get.bod.metadata.by.name
	EndDllUsage

		long		visibility
	domain	bobod.type	dummy.type
	domain	bobod.name	bod
	domain	boyesno		dummy.support.accounting.entity
	string			dummy.parm.string(PARM_STRING)

	RETIFNOK( get.bod.metadata.by.name(
			i.name,
			o.implementation.identifier,		|* Ref
			visibility,				|* Ref
			o.bod.type,				|* Ref
			o.public.bod,				|* Ref
			dummy.support.accounting.entity,	|* Ref
			dummy.parm.string ))

	o.public.implementation.identifier = o.implementation.identifier

	|* Search for public BOD if needed.
	while visibility <> PUBLIC_BOD
		bod = o.public.bod

		VAL_RETIFNOK( get.bod.metadata.by.name(
				bod,
				o.public.implementation.identifier,	|* Ref
				visibility,				|* Ref
				dummy.type,				|* Ref
				o.public.bod,				|* Ref
				dummy.support.accounting.entity,	|* Ref
				dummy.parm.string ))

		if visibility = PROTECTED_BOD and
		   bod = o.public.bod then
			dal.set.error.message( "txbods0041", trim$( i.name ) )
			|* txbods0041  ???

			return( DALHOOKERROR )
		endif
	endwhile

	return( 0 )
}

function extern txbod.dll9002.after.form.read(
		domain	tcmcs.str18	i.mode.field.name,
	const	domain	tcyesno		i.bod.visible.stack(),
					... )
{
	DllUsage
	Expl:	The purpose of this function it to handle the 'after.form.read'
		section of the UI.

		- Based on the BOD parameters, the available options of field
		  'Mode' are set.
		- Based on macro 'ARGUMENT_LIST_BODS, group and field labels
		  are set.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.mode.field.name
		i.bod.visible.stack
		...	- 1. List of form tab labels
			  2. List of field labels
			  3.
	Output:	N.a.
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll0006.after.form.read
	EndDllusage

	long	argument.no
	long	nr.arguments
	long	group
	long	return.value
	long	step.size
	long	bod.no
	long	first.variable.argument
	long	label.sequence.no
	string	field(17)
	string	label(70)
	string	hold.label(70)
	boolean	restart.numbering

	first.variable.argument = 3

	step.size = 2
	nr.arguments = get.argc()
	bod.no = 0
	label.sequence.no = 0
	hold.label = ""
	restart.numbering = true

	set.enum.values.for.mode( i.mode.field.name )

	for argument.no = first.variable.argument to nr.arguments
							step step.size
		group = 0
		field = ""
		|**************************************************************
		|* Get group/field and label.
		|**************************************************************
		on case get.arg.type( argument.no )
		case DB.LONG:
			|* Group label.
			group = get.long.arg( argument.no )
			label = get.string.arg( argument.no + 1 )

			if do.add.label.sequence(
					group,
					label,
					hold.label,		|* Ref
					restart.numbering,	|* Ref
					get.arg.type( argument.no + step.size ),
					get.string.arg(
					    argument.no + step.size + 1 )) then

				if restart.numbering then
					label.sequence.no = 0
				endif

				INC( label.sequence.no )

				label = add.label.sequence(
						label,
						label.sequence.no )
			else
				label.sequence.no = 0
			endif

			break
		case DB.STRING:
			|* Field label.

			if step.size = 2 then
|t				STOP.MESSAGES
				if txbod.dll9002.bod.metadata.exists(
					get.string.arg( argument.no )) = 0 then
					|* Argument is a BOD. So, BOD argument
					|* list is reached. Increase step size.
					step.size = PD_NR_BOD_ARGUMENTS
				endif
|t				START.MESSAGES
			endif

			on case step.size
			case 2:
				field = get.string.arg( argument.no )
				label = get.string.arg( argument.no + 1 )

				break
			case PD_NR_BOD_ARGUMENTS:
				INC( bod.no )

				field = get.string.arg(
					 PD_ARG_NO_PB_FIELD(argument.no) )
				label = get.string.arg(
					 PD_ARG_NO_PB_FIELD_LABEL(argument.no) )

				break
			endcase

			break
		default:
			ASSERT(	false, "Argument type not supported." )

			break
		endcase

		if return.value = -1 then
			ASSERT(	false, "Session is not dynamic." )

			return	|* Early return!
		endif

		|**************************************************************
		|* Check label.
		|**************************************************************
		if isspace( label ) then
			|* Label is empty, if filled in UI.
			|* For example: Rules BPs.
			continue
		endif

		|**************************************************************
		|* Set label for group/field.
		|**************************************************************
		if group > 0 then
			return.value = change.group.label( group, label )

			if return.value = -2 then
				ASSERT( false,
					"Group '" & str$( group ) & "' not " &
					"found. Label of group cannot be set " &
					"to '" & trim$( label ) & "'." )
			endif
		endif

		if not isspace( field ) then
			if bod.no > 0 and
			   i.bod.visible.stack( bod.no ) = tcyesno.yes and
			   str.equals(	trim$( label ),
					LABEL_PUBLIC_BOD_NAME ) then
				|* Instruction for get public bod name.
				if get.business.object.name(
						get.string.arg( argument.no ),
						"",			|* Label
						label ) <> 0 then	|* Ref
					show.dal.messages()
				endif
			endif

			return.value = change.field.label( field, 1, label )

			if return.value = -2 then
				ASSERT( false,
					"Field '" & trim$( field ) & "' not " &
					"found. Label of field cannot be set " &
					"to '" & trim$( label ) & "'." )
			endif
		endif
	endfor
}

function extern long txbod.dll9002.sync.project.master.bod(
			domain	tcmcs.long	i.mode,
			domain	tccprj		i.project)
{
	DllUsage
	Expl	: Publish the ProjectMasterBOD
	Pre.	:
	Post	:
	Input	: i.project
	Output	: NA
	Return	: 0/DALHOOKERROR
	EndDllUsage
	|SourceDLL: tpbod.dll0010.sync.project.master.bod

		long		result
	domain	tcmcs.str10	action.code
	domain	tppdm.psts	project.status

	txpdm.dll9001.project.get.status(
					i.project,
					project.status)

	if not publish.project.master.allowed(
					i.mode,
					i.project,
					project.status) then
		return(0)
	endif

	determine.action.code(	i.mode,
				action.code)

	RETIFNOK(txbod.dll9002.publish.project.master_API(
					i.project,
					action.code))

	return(0)
}

function extern txbod.dll9002.set.maintainability.bods(
		domain	tcbod.mode	i.mode,
		domain	tcncmp		i.company.from,
		domain	tcncmp		i.company.to,
		domain	tcbod.uvrb	i.use.verb,
	const	domain	tcyesno		i.bod.visible.stack(),
			long		i.nr.bods.in.stack,
	ref	domain	tcyesno		o.bod.subscription.stack(),
					... )
{
	DllUsage
	Expl:	The purpose of this function is to set the maintainability of
		BODS within a specified range of companies.

		BODs are disabled if no subscription is present.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.mode
		i.company.from
		i.company.to
		i.use.verb
		i.bod.visible.stack
		i.nr.bods.in.stack
		...	- UI macro ARGUMENT_LIST_BODS
	Output:	N.a.
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll0006.set.maintainability.bods
	EndDllusage

			long		nr.companies.in.stack
			long		argument.no.bod
			long		argument.no.disable
			long		bod.no
			long		argument.no
			long		argument.no.first.bod
			long		position
			long		return.value
			long		dummy.value
			string		dummy.string
		domain	tcbod.type	dummy.type
		domain	tcmcs.st60m	public.bod
		domain	tcncmp		b.company.stack(1) based
		domain	tcmcs.str300m	error.message
	static	domain	tcmcs.st60m	s.public.bod
	static	domain	tcyesno		s.subscription


	

	argument.no.first.bod = 8

	|* Get the companies within the specified range.
|	if get.companies(					
	if txbod.dll9002.get.companies(				
			i.company.from,
			i.company.to,
			b.company.stack,
			nr.companies.in.stack ) <> 0 then
		ERROR_ROUTINE_SET_MAINTAINABILITY_BODS
	endif

	|* Allocate and initialize BOD subscription stack.
	dummy.value = alloc.mem( o.bod.subscription.stack, i.nr.bods.in.stack )
	dummy.value = set.mem( o.bod.subscription.stack, NO )

	|* Determine if subscriptions are present. Disable group/field if no
	|* subscription present.
	bod.no = 0

	for argument.no = argument.no.first.bod to get.argc()
						step PD_NR_BOD_ARGUMENTS
		argument.no.bod = PD_ARG_NO_BOD( argument.no )
		argument.no.disable = PD_ARG_NO_DISABLE( argument.no )

		|* Count BODs in arguments.
		INC( bod.no )

		|* Check if subscription is present for visible BODs only.
		if i.bod.visible.stack( bod.no ) = tcyesno.yes then
			|* BOD is visible. Get the public BOD.
			if txbod.dll9002.get.bod.data(
					get.string.arg( argument.no.bod ),
					dummy.string,	|* Ref: Identifier
					public.bod,	|* Ref
					dummy.string,	|* Ref: Identifier publ.
					dummy.type ) <> 0 then	|* Ref: Type
				ERROR_ROUTINE_SET_MAINTAINABILITY_BODS
			endif

			|* Determine if a subscription is present if the
			|* public BOD differs from the cached BOD.
			if trim$( public.bod ) <> trim$( s.public.bod ) then
				|* Determine if a subscription is present
				for position = 1 to nr.companies.in.stack
|t					STOP.MESSAGES

					return.value =
					check.subscription.exists(
						    b.company.stack( position ),
						    i.use.verb,
						    public.bod )

|t					START.MESSAGES

					if return.value = 0 then
						|* Subscription present.
						|* Stop loop for company.
						|* Save subscription in stack
						|* and continue with next BOD.

						s.subscription = tcyesno.yes

						break	|* !!!
					else
						s.subscription = tcyesno.yes
					endif
				endfor
			endif

			s.public.bod = public.bod
			o.bod.subscription.stack( bod.no ) = s.subscription
		endif

		|* In 'Publish'-mode, disable group/field if no subscription
		|* present.
		on case get.arg.type( argument.no.disable )
		case DB.LONG:
			if txbod.dll9002.do.publish.data.bod(
					i.mode,
					i.bod.visible.stack(bod.no),
					o.bod.subscription.stack(bod.no),
					tcyesno.yes ) then	|* Selected
				enable.group(
					get.long.arg( argument.no.disable ))
			else
				disable.group(
					get.long.arg( argument.no.disable ))
			endif

			break
		case DB.STRING:
			if txbod.dll9002.do.publish.data.bod(
					i.mode,
					i.bod.visible.stack(bod.no),
					o.bod.subscription.stack(bod.no),
					tcyesno.yes ) then	|* Selected
				enable.fields(
					get.string.arg( argument.no.disable ))
			else
				disable.fields(
					get.string.arg( argument.no.disable ))
			endif

			break
		default:
			ASSERT(	false, "Argument type not supported." )

			break
		endcase
	endfor
}

function extern long txbod.dll9002.get.bod.data(
		domain	tcbod.name	i.noun,
	ref	domain	tcbod.impl	o.identifier,
	ref	domain	tcbod.name	o.public.noun,
	ref	domain	tcbod.impl	o.public.identifier,
	ref	domain	tcbod.type	o.bod.type)
{
	DllUsage
	Expl	: This function retrieves the BOD metadata.
		  Input BOD can be protected or public.
	Pre	: -
	Post	: -
	Input	: i.noun	- BOD name (e.g. CodeDefinitionBOD)
	Output	: o.identifier
		  o.public.noun
		  o.public.identifier
		  o.bod.type
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : bobod.dll1200.get.bod.data
	EndDllUsage

	RETIFNOK(CALL_FUNCTION(
		txbod.dll9002.get.bod.metadata.by.name,
				i.noun,
				o.identifier,	|* Ref
				o.public.noun,		|* Ref
				o.public.identifier,	|* Ref
				o.bod.type))		|* Ref

	return(0)
}

function extern txbod.dll9002.set.visibility.bods(
	ref	domain	tcyesno	o.bod.visible.stack(),
	ref		long	o.nr.bods,
				... )
{
	DllUsage
	Expl:	The purpose of this function is to make a BOD field or a group
		of BOD fields invisible, if a BOD is not implemented.
	Pre:	N.a.
	Post:	N.a.
	Input:	...	- UI macro ARGUMENT_LIST_BODS
	Output:	o.bod.visible.stack
		o.nr.bods
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll0006.set.visibility.bods
	EndDllusage

		long	argument.no
		long	group.no
		long	argument.no.bod
		long	argument.no.disable
		long	nr.arguments
		long	dummy.value
		long	argument.no.first.bod
		string	dummy.field.name
	domain	tcyesno	visible

	argument.no.first.bod = 3

	|* Determine number of BODs present in variable arguments.
	nr.arguments = get.argc()

	o.nr.bods = (((nr.arguments - argument.no.first.bod) * 1.0) /
						(PD_NR_BOD_ARGUMENTS * 1.0)) + 1
	|* Allocate and initialize memory stack.
	dummy.value = alloc.mem( o.bod.visible.stack, o.nr.bods )
	dummy.value = set.mem( o.bod.visible.stack, NO )

	|* Make groups/fields invisible if BOD is not implemented.
	|* Handle BODs by set of arguments.
	o.nr.bods = 0

	for argument.no = argument.no.first.bod to nr.arguments
						step PD_NR_BOD_ARGUMENTS
		|* Handle BOD by set of arguments.
		argument.no.bod = PD_ARG_NO_BOD( argument.no )
		argument.no.disable = PD_ARG_NO_DISABLE( argument.no )
		group.no = 0
		dummy.field.name = ""
		INC( o.nr.bods )

		visible = tcyesno.yes

		on case get.arg.type( argument.no.disable )
		case DB.LONG:
			|* A group is specified to enable/disable.
			group.no = get.long.arg( argument.no.disable )

			handle.visibility.bods(
				get.string.arg( argument.no.bod ),
				group.no,
				dummy.field.name,
				visible )	|* Ref

			break
		case DB.STRING:
			|* A field is specified to enable/disable.
			group.no = 0

			handle.visibility.bods(
				get.string.arg( argument.no.bod ),
				group.no,
				get.string.arg( argument.no.disable ),
				visible )	|* Ref

			break
		default:
			ASSERT(	false, "Argument type not supported." )

			break
		endcase

		|* Fill visibility stack.
		o.bod.visible.stack(o.nr.bods) = visible
	endfor
}

function extern boolean txbod.dll9002.bod.implemented(
				const	string	i.noun)
{
	DllUsage
	Expl	: This function checks if a BOD is implemented by checking
		  if it's related st-library exists.
	pre	: NA
	post	: NA
	Input	: i.noun
	Output	: NA
	Return	: true	- if BOD exists
		  false	- if BOD does not exist
	Old Dll : tcint.dlltcbod.bod.implemented
	endDllUsage

	long	ret

	domain	tcmcs.str15	object.name

	domain	tcbod.impl	identifier
	domain	tcbod.name	public.noun
	domain	tcbod.impl	public.identifier
	domain	tcbod.type	bod.type

	identifier = ""

|t	STOP.MESSAGES
	ret = retrieve.bod.data(	i.noun,
					identifier,
					public.noun,
					public.identifier,
					bod.type)
|t	START.MESSAGES

	if not isspace(identifier) then
		object.name =	"o" &
				identifier(1;5) &
				"bl" &
				identifier(6;3) &
				"st00"

		ret = load_dll(object.name, DLL_SILENT_ERR)

		if ret > 0 then
			return(true)
		endif
	endif

	return(false)
}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID(
		domain	tcitem		i.ItemMasterHeader_ItemID_ID,
		domain	tcmcs.str25	i.ItemMasterHeader_PP_ProcurementMethodCode,
	ref	domain	tcmcs.str50	o.ItemMasterHeader_PP_DefaultSource_ProductionLocation_ID,
	ref		boolean		io.ItemMasterHeader_PP_DefaultSource_ProductionLocation_ID.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.hook.onget.itemmastercommonbod.itemmasterheader_procurementparameters_defaultsource_productionlocation_id
	EndDllusage

	|* Publish the BOD even if the attribute is empty.

	long	dummy.retval
	static	domain	tcitem		s.ItemMasterHeader_ItemID_ID
	static	domain	tcmcs.str25	s.ItemMasterHeader_PP_ProcurementMethodCode
	static	domain	tcmcs.str50	s.ItemMasterHeader_PP_DefaultSource_ProductionLocation_ID

	o.ItemMasterHeader_PP_DefaultSource_ProductionLocation_ID = ""
	io.ItemMasterHeader_PP_DefaultSource_ProductionLocation_ID.isSet = false

	if s.ItemMasterHeader_ItemID_ID <> i.ItemMasterHeader_ItemID_ID or
	   s.ItemMasterHeader_PP_ProcurementMethodCode <> i.ItemMasterHeader_PP_ProcurementMethodCode then

		s.ItemMasterHeader_PP_DefaultSource_ProductionLocation_ID = ""
		s.ItemMasterHeader_ItemID_ID = i.ItemMasterHeader_ItemID_ID
	   	s.ItemMasterHeader_PP_ProcurementMethodCode = i.ItemMasterHeader_PP_ProcurementMethodCode

|t		STOP.MESSAGES
	
		on case i.ItemMasterHeader_PP_ProcurementMethodCode
		case PROCUREMENT_MANUFACTURE:
			if txipd.dll9001.item.has.routing( i.ItemMasterHeader_ItemID_ID ) then
				dummy.retval = retrieve.workcenter.of.default.routing(
					0.0,
					i.ItemMasterHeader_ItemID_ID,
					0,
					s.ItemMasterHeader_PP_DefaultSource_ProductionLocation_ID ) |* Ref
			endif
	
			break
		endcase 
	
|t		START.MESSAGES

	endif

	if not isspace( s.ItemMasterHeader_PP_DefaultSource_ProductionLocation_ID ) then
		o.ItemMasterHeader_PP_DefaultSource_ProductionLocation_ID = s.ItemMasterHeader_PP_DefaultSource_ProductionLocation_ID
		io.ItemMasterHeader_PP_DefaultSource_ProductionLocation_ID.isSet = true
	endif

	return( 0 )
}				

function extern long txbod.dll9002.Hook.ConversionGet.ItemMasterCommonBOD.ItemMasterHeader_ItemPlanning_PlanItemType(
		domain	cprpd.plit	i.ItemMasterHeader_ItemPlanning_PlanItemType,
	ref		string		o.ItemMasterHeader_ItemPlanning_PlanItemType,
	ref		boolean		io.ItemMasterHeader_ItemPlanning_PlanItemType.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to return attribute
		ItemPlanning_PlanItemType of the main component.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.ItemMasterHeader_ItemPlanning_PlanItemType
	Output:	o.ItemMasterHeader_ItemPlanning_PlanItemType
	In/out:	io.ItemMasterHeader_ItemPlanning_PlanItemType.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.hook.conversionget.itemmastercommonbod.itemmasterheader_itemplanning_planitemtype
	EndDllUsage

	o.ItemMasterHeader_ItemPlanning_PlanItemType = ""
	io.ItemMasterHeader_ItemPlanning_PlanItemType.isSet = false

	RETIFNOK(txbod.dll9002.convert.from.erp.plan.item.type(
			i.ItemMasterHeader_ItemPlanning_PlanItemType,
			o.ItemMasterHeader_ItemPlanning_PlanItemType ))	|* Ref

	if not isspace( o.ItemMasterHeader_ItemPlanning_PlanItemType ) then
		io.ItemMasterHeader_ItemPlanning_PlanItemType.isSet = true
	endif

	return( 0 )
}

function extern long txbod.dll9002.convert.from.erp.plan.item.type(
		domain	cprpd.plit	i.erp.plan.item.type,
	ref	domain	tcmcs.str25	o.bod.plan.item.type )
{
	DLLUsage
	Expl.:	This function converts the ERP plan item type to the external
		plan item type used in the BODs.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.erp.plan.item.type
	Output:	o.bod.plan.item.type
	Return:	0/DALHOOKERROR
	Old Dll : cpbod.dll1000.convert.from.erp.plan.item.type
	EndDLLUsage

	o.bod.plan.item.type = ""

	if i.erp.plan.item.type = empty then
		return( 0 )
	endif

	on case i.erp.plan.item.type
	case cprpd.plit.productfamily:
		o.bod.plan.item.type = PLAN_ITEM_TYPE_FAMILY

		break
	case cprpd.plit.mpsitem:
		o.bod.plan.item.type = PLAN_ITEM_TYPE_ITEM

		break
	default:
		dal.set.error.message(
			"txbods0040",
			|* txbods0040  ???
			tt.label.desc( "cpcprpd100.plit", ttadv.cont.general ),
			|* cpcprpd100.plit  ???
			enum.descr$( "cprpd.plit", i.erp.plan.item.type ) )
			|* cprpd.plit  ???

		return( DALHOOKERROR )
	endcase

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemLocation.StockCarryingCost_Amount_currencyID(
		domain	tccwar	i.WarehouseLocation_ID,
			boolean	i.WarehouseLocation_ID.isSet,
	ref	domain	tcccur	o.StockCarryingCost_Amount_currencyID,
	ref		boolean	io.StockCarryingCost_Amount_currencyID.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to return attribute
		'StockCarryingCost_Amount_currencyID' of the ItemLocation
		component.

		This function reads the financial company of the warehouse.
		For this financial company the local currency should be
		displayed for the fields Order Cost and Inventory Carrying Cost
		per Year.
		If the warehouse is not found an error message will be shown.

		The logic used in this function is copied from function
		read.warehouse.currency() in script whwmd2510.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.WarehouseLocation_ID
		i.WarehouseLocation_ID.isSet
	Output:	o.StockCarryingCost_Amount_currencyID
	In/out:	io.StockCarryingCost_Amount_currencyID.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.hook.onget.itemlocation.stockcarryingcost_amount_currencyid
	EndDllUsage

		long		dummy.value
	domain	tcncmp		current.company
	domain	tcncmp		financial.company

	o.StockCarryingCost_Amount_currencyID = ""
	io.StockCarryingCost_Amount_currencyID.isSet = false

	current.company = get.compnr()

	itxcom0000.get.multi.currency.data( current.company )

	dummy.value = set.mem( itxcom0000.hcur, "" )

	if not isspace( i.WarehouseLocation_ID ) then
		if not get.financial.company.of.entity(
				current.company,
				tcemm.enty.warehouse,
				i.WarehouseLocation_ID,
				financial.company ) then
			dal.set.error.message( "txemm0007" )
			|* txemm0007  ???

			return( DALHOOKERROR )
		endif

		if txemm.dll9001.get.home.currencies(
				financial.company,
				itxcom0000.hcur,
				itxcom0000.ncur ) then
			o.StockCarryingCost_Amount_currencyID = itxcom0000.hcur(1,1)
		endif

		if not isspace( o.StockCarryingCost_Amount_currencyID ) then
			io.StockCarryingCost_Amount_currencyID.isSet = true
		endif
	endif

	return( 0 )
}


function extern long txbod.dll9002.check.return.value.parse.and.exec(
	const	string	i.script,
	const	string	i.function,
	const	string	i.function.call,
		long	i.return.value.parse.and.exec )
{
	DllUsage
	Expl:	The purpose of this function is to check the return value of
		tools functions:
		- parse_and_exec_function
		- exec_dll_function
	Pre:	N.a.
	Post:	N.a.
	Input:	i.script
		i.function
		i.function.call
		i.return.value.parse.and.exec
	Output: N.a.
	Return: 0/DALHOOKERROR
	Old Dll : bobod.dll1038.check.return.value.parse.and.exec
	EndDllUsage

	on case i.return.value.parse.and.exec
	case -1:
		dal.set.error.message( "txbods0016", trim$( i.script ) )
		|* No unit found for ISO Code %1$s.

		return( DALHOOKERROR )
	case -2:
		dal.set.error.message(
			"txbods0034",
			|* txbods0034  ???
			trim$( i.function ) & " (" & trim$( i.script ) & ")")
		|* Function %1$s not found.

		return( DALHOOKERROR )
	case -3:
		dal.set.error.message(
			"txbods0035",
			|* txbods0035  ???
			trim$( i.function.call) &
						" (" & trim$( i.script ) & ")")
		|* Syntax error in function call %1$s.

		return( DALHOOKERROR )
	endcase

	return( 0 )
}

function extern long txbod.dll9002.get.item.from.item.id.node.array(
		ref	domain	tcmcs.long	i.xml.node(),
		ref	domain	tcitem		o.item,
		ref	boolean			o.item.is.set,
		ref	domain	tcaitm		o.customer.item,
		ref	boolean			o.customer.item.is.set)
{
	DllUsage
	Expl	: This function gets the item and customer item from an xml
		  structure;
		  <ItemID>
			<ID schemeName="System">Standard Item</ID>
		  </ItemID>
		  <ItemID>
			<ID schemeName="Customer">Customer Item</ID>
		  </ItemID>

		  If qualifier schemeName is not present, "System" is assumed, so
		  a standard item is get.
	Pre	: -
	Post	: -
	Input	: i.xml.node	- Node containing the item elements
	Output	: o.item		- Item
		  o.item.is.set
		  o.customer.item	- Customer Item
		  o.customer.item.is.set
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0034.get.item.from.item.id.node.array
	EndDllUsage

	long	nr.dims
	long	array.depth(4)
	long	i

	domain	tcmcs.long	node
	domain	tcmcs.s512m	ID
	boolean			ID.is.set
	domain	tcmcs.str30	item.schemename
	boolean			item.schemename.is.set
	
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID 

	o.item = ""
	o.item.is.set = false
	o.customer.item	= ""
	o.customer.item.is.set = false

	array.info(	i.xml.node,
			nr.dims,
			array.depth)

	for i = 1 to array.depth(1)
		node = i.xml.node(i)
		if node = 0 then
			|* remaining nodes are empty
			break
		endif

		RETIFNOK(txbod.dll9002.xml.get.element.value(
					node,
					"?<ID>",
					"",	|* domain
					ID,
					ID.is.set))

		RETIFNOK(txbod.dll9002.xml.get.attribute.value(
					node,
					"?<ID>",
					"schemeName",
					item.schemename,
					item.schemename.is.set))

		if item.schemename.is.set then
			on case trim$(item.schemename)
			case SCHEME_NAME_SYSTEM:
			case "":
				if BOD.ConvertToERPItem(			|* API CALL
							trim$(ID),
							o.item,
 							o.ExceptionMessage,
 							o.ExceptionID ) <> 0 then
				
				|* Exception(s) found.
				for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
					dal.set.error.message("@"& o.ExceptionMessage(i))
				endfor
				Exception.Delete(o.ExceptionID)
				return(DALHOOKERROR)
  				else
  					|* Call was successful.
					o.item.is.set = true
				endif		
				break
				
			case SCHEME_NAME_CUSTOMER:
				o.customer.item = strip$(ID)	|*don't trim.
				o.customer.item.is.set = true
				break
			endcase
		else
			if BOD.ConvertToERPItem(trim$(ID),
							o.item,
 							o.ExceptionMessage,
 							o.ExceptionID ) <> 0 then
				|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
			
  			else
  			|* Call was successful.
				o.item.is.set = true
			endif
		endif
	endfor

	return(0)
}

function extern long txbod.dll9002.sync.project.revenue.bod(
		domain	tccprj		i.project,
		domain	tppdm.cpro	i.revenue.code,
		domain	tppdm.serf	i.sequence.number,
		domain	tpppc.tetm	i.posting.type,
		domain	tcmcs.long	i.mode)
{
	DllUsage
	Expl	: This functions sends out a SyncProjectRevenueManualBOD to the
		  ESB.
	Pre.	: NA
	Post	: NA
	Input	: i.project
		  i.revenue.code
		  i.sequence.number
		  i.posting.type
		  i.mode	- DAL_NEW, DAL_UPDATE or DAL_DESTROY
	Output	: NA
	Return	: 0/DALHOOKERROR
	Old Dll : tpbod.dll1053.sync.project.revenue.bod
	EndDllUsage

	domain	tcmcs.str10	action.code
	long	ret
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID 
	long	i

	if i.posting.type <> tpppc.tetm.manu and
	   i.posting.type <> tpppc.tetm.sal.invoice.fin then
		return(0)
	endif

	determine.action.code(i.mode, action.code)

	domain	tcmcs.str50	identifier

	identifier = concat$(	CONCAT_SEPARATOR,
				i.project,
				i.revenue.code,
				str$( i.sequence.number ))

	ret = BOD.Publish(				|* API CALL
			"ProjectRevenueManualBOD",
			"",
			action.code,
			BOD_ENTITY_PROJECT,
			i.project,
			identifier,
			VAL_PROC_STAGE_OR_PUBLISH,
			o.ExceptionMessage,
			o.ExceptionID)
			
	if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif

	return(0)
}

function extern long txbod.dll9002.bo.get.id.accounting.entity_API(
			domain	tcmcs.tabl	i.reference.table,
			domain	tcncmp		i.logical.company,
			const	string		i.public.noun,
			long			i.bod.entity.type,
			const	string		i.bod.entity.code,
		ref	domain	tcbod.acen	o.accountingEntity,
		ref	boolean			o.accountingEntity.isSet)
		
{	
	DllUsage
	Expl	: This function retrieves the following ID elements:
		  	- accountingEntity:	will be filled, based on
		  			tcemm300, when
		  			related noun has 'Sync'-subscription
		  			(ERPLN is SOR),	otherwise empty.
	pre	: NA
	post	: NA
	Input	: i.reference.table
		  i.logical.company
		  i.public.noun
		  i.bod.entity.type
		  i.bod.entity.code
	Output	: o.accountingEntity
		  o.accountingEntity.isSet
	Return	: 0 - Ok
		  DALHOOKERROR - Error
	Old Dll : tcbod.dll0001.bo.get.id.accounting.entity
	EndDllUsage
		
 	long	ret
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID
	long	i
 	
 	ret = BOD.GetIdAccountingEntity(		|* API USED
 			i.logical.company,
  			i.public.noun,
  			i.bod.entity.type,
  			i.bod.entity.code,
  			i.reference.table,
 			o.accountingEntity,
  			o.accountingEntity.isSet,
  			o.ExceptionMessage,
  			o.ExceptionID )
 
 	if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif
	
	return(0)

}

function extern long txbod.dll9002.convert.from.erp.item_API(
					domain	tcitem		i.erp.item,
				ref	domain	tcmcs.str50	o.bod.item)
{
	DllUsage
	Expl	: This function converts the ERP item
		  to the external item used in the BODs.
	Pre	: -
	Post	: -
	Input	: i.erp.item
	Output	: o.bod.item
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0031.convert.from.erp.item
		  tcbod.dll0001.convert.from.erp.item
	EndDllUsage
	
	long	ret
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID
	long	i
	
	ret = BOD.ConvertFromERPItem(				|* API USED
						i.erp.item,
						o.bod.item,
 						o.ExceptionMessage,
 						o.ExceptionID )
 
	if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif
	
	return(0)
}

function extern long txbod.dll9002.publish.bod_API(
		domain	tcbod.name	i.noun,
		domain	tcmcs.tabl	i.bod.root.table,
	const		string		i.action.code,
			long		i.bod.entity.type,
	const		string		i.bod.entity.code,
	const		string		i.document.id,
			boolean		i.batch.bod,
	const		string		i.batch.id,
			long		i.batch.sequence,
			long		i.batch.size,
	const		string		i.processing.action,
					... )
{
	DllUsage
	Expl	: This function publishes any BOD.
	Pre	: - Transaction handling is needed. Normally the standard
		    program handles the transaction management. But, for
		    example, when this function is called from a Bint
		    test, transaction handling must be done in the
		    calling script.
		  - If OCM is implemented for a table, define
		    OCM_NOT_ACTIVE_OR_OCM_CHECK_IN should be used in the DAL
		    to check if a BOD must be published.
	Post	: NA
	Input	: i.noun		- example: CodeDefinitionSkillBOD
		  i.bod.root.table	- only used for BOD_TYPE_MASTERDATA and
		  			  BOD_TYPE_SYSTEM
		  			  is filled with the main triggering
		  			  table. In case the physical company
		  			  of this table differs from the
		  			  current company a company switch is
		  			  done, to get the published BOD
		  			  in the outbox of the correct company.
		  i.action.code		- example: Add
		  i.bod.entity.type	- possible values:
		  				BOD_ENTITY_WAREHOUSE
		  				BOD_ENTITY_DEPARTMENT
		  				BOD_ENTITY_PROJECT
		  i.bod.entity.code	- together with i.bod.entity.type
		  			  used to determine
		  			  	Tenant,
		  			  	AccountingEntity and
		  			  	Location
		  i.document.id
		  i.batch.bod		- true or false
		  i.batch.id		- mandatory, if i.batch.bod = true
		  i.batch.sequence	- mandatory, if i.batch.bod = true
		  i.batch.size		- optional
		  i.processing.action	- PROC_ONLY_STAGE
		  			- PROC_STAGE_OR_PUBLISH
					- PROC_ONLY_PUBLISH
		  - variable arguments are identifiers

		  For OCM:
		  This function may never be called to publish checked out
		  data.
		  - OCM active: This function must be called to publish
		  		checked-in data or during check in.
				(OCM_NOT_ACTIVE_OR_OCM_CHECK_IN = true).
		  - OCM not active: This function can be called any time.
	Output	: NA
	return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll  : tcbod.dll0001.publish.bod
	EndDllUsage
	
	long	ret
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID	
	long	i	
	
	ret = BOD.Publish(
 			i.noun,
 			i.bod.root.table,
 			i.action.code,
 			i.bod.entity.type,
 			i.bod.entity.code,
 			i.document.id,
 			i.processing.action,
 			o.ExceptionMessage,
 			o.ExceptionID,
 			... )
 			
 	if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif

	return(0)
}

function extern long txbod.dll9002.convert.to.erp.item_API(
					domain	tcmcs.str50	i.bod.item,
				ref	domain	tcitem		o.erp.item)
{
	DllUsage
	Expl	: This function converts the BOD item format, to the format
		  used in ERP LN, taking into account item segmentation.
	pre	: NA
	post	: NA
	Input	: i.bod.item
	Output	: o.erp.item
	return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0031.convert.to.erp.item
	EndDllUsage
	
	long	ret
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID
	long	i
	
	ret = BOD.ConvertToERPItem(
						i.bod.item,
						o.erp.item,
						o.ExceptionMessage,
						o.ExceptionID )
						
	if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif

	return(0)
}


function extern long txbod.dll9002.execute.method_API(
			domain	tcbod.name	i.noun,
			const	string		i.method,
			long			i.xml.request,
		ref	long			o.xml.response,
		ref	long			o.xml.result)
{
	DllUsage
	Expl:	The purpose of this function is to execute a non-batch method
		for a specified BOD.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.bod.name	- e.g. "ReceiveDeliveryWarehousingBOD"
		i.method	- e.g. "Create"
		i.xml.request
	Output:	o.xml.reponse
		o.xml.result	- (error)
	Return:	0 / DALHOOKERROR
	Old Dll : tcbod.dll0030.execute.method
	EndDllUsage
	
	long	ret
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID
	long	i
	
	ret = BOD.ExecuteMethod(
			 i.noun,
			 i.method,
			 i.xml.request,
			 o.xml.response,
			 o.xml.result,
			 o.ExceptionMessage,
			 o.ExceptionID )
 					
	if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif

	return(0)
}

function extern long txbod.dll9002.execute.publish.for.chameleon_API(
			domain	tcbod.name	i.protected.noun,
			long			i.xml.request,
		ref	long			o.xml.response,
		ref	long			o.xml.result)
{
	DllUsage
	Expl	: This function executes the publishing for a protected
		  of the chameleon BOD.
		  It translates the protected noun to the public noun and
		  executes the publish event of the public nooun
	Pre	: -
	Post	: -
	Input	: i.protected.noun  - protected BOD, which is BOD
				  that calls this function
		  i.xml.request
	Output	: o.xml.response
		  o.xml.result
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0030.execute.publish.for.chameleon
	EndDllUsage
	
	long	ret
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID
	long	i
	
	ret = BOD.ExecutePublishForChameleon(
				 i.protected.noun,
				 i.xml.request,
				 o.xml.response,
				 o.xml.result,
				 o.ExceptionMessage,
				 o.ExceptionID )
				 
	if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif

	return(0)
}

function extern long txbod.dll9002.bo.get.id.lid_API(
			domain	tcmcs.tabl	i.reference.table,
			domain	tcncmp		i.logical.company,
			const	string		i.public.noun,
			long			i.bod.entity.type,
			const	string		i.bod.entity.code,
		ref	domain	tcbod.loid	o.lid,
		ref	boolean			o.lid.isSet)
{
	DllUsage
	Expl	: This function retrieves the following ID elements:
		  	- lid:		is filled with LogicalID
	pre	: NA
	post	: NA
	Input	: i.reference.table
		  i.logical.company
		  i.public.noun
		  i.bod.entity.type
		  i.bod.entity.code
	Output	: o.lid
		  o.lid.isSet
	Return	: 0 - Ok
		  DALHOOKERROR - Error
	Old Dll : tcbod.dll0001.bo.get.id.lid
	EndDllUsage
	
	domain tcmcs.s999m o.ExceptionMessage
	long o.ExceptionID
	long	ret
	long	i
	
	 ret =  BOD.GetIdLogicalID(
			i.logical.company,
 			i.public.noun,
 			i.bod.entity.type,
 			i.bod.entity.code,
 			i.reference.table,
 			o.lid,
 			o.lid.isSet,
 			o.ExceptionMessage,
 			o.ExceptionID )	
 	
 	if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif

	return(0)
}


function extern long txbod.dll9002.bo.get.id.location_API(
			domain	tcmcs.tabl	i.reference.table,
			domain	tcncmp		i.logical.company,
			const	string		i.public.noun,
			long			i.bod.entity.type,
			const	string		i.bod.entity.code,
		ref	domain	tcmcs.str50	o.location,
		ref	boolean			o.location.isSet)
{
	DllUsage
	Expl	: This function retrieves the following ID elements:
		  	- location:	will be filled, based on tcemm300, when
		  			related noun has 'Sync'-subscription
		  			(ERPLN is SOR),	otherwise empty.
	pre	: NA
	post	: NA
	Input	: i.reference.table
		  i.logical.company
		  i.public.noun
		  i.bod.entity.type
		  i.bod.entity.code
	Output	: o.location
		  o.location.isSet
	Return	: 0 - Ok
		  DALHOOKERROR - Error
	Old Dll : tcbod.dll0001.bo.get.id.location
	EndDllUsage
	
	domain tcmcs.s999m o.ExceptionMessage
	long o.ExceptionID
	long	ret
	long	i
	
	ret = BOD.GetIdLocation(
		 i.logical.company,
		 i.public.noun,
		 i.bod.entity.type,
		 i.bod.entity.code,
		 i.reference.table,
		 o.location,
		 o.location.isSet,
		 o.ExceptionMessage,
		 o.ExceptionID)
		 
	if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
	endif
	
	return(0)
}
  
function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_accountingEntity(
		domain	tcmcs.str50	i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID,
			boolean		i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID.isSet,
	ref	domain	tcmcs.str50	o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_accountingEntity,
	ref		boolean		io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_accountingEntity.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to return attribute
		ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_accountingEntity
		of the main component of the BOD.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID
		i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID.isSet
	Output:	o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_accountingEntity
	In/out:	io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_accountingEntity.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_accountingEntity
	EndDllUsage

	domain	tcmcs.str50	identifier
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID
	long	i
	long	ret
	

	o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_accountingEntity = ""
	io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_accountingEntity.isSet = false

	if not isspace( i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID ) then
		RETIFNOK( txbod.dll9002.compose.location.identifier(
				LOCATION_TYPE_OFFICE,
				i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID,
				identifier ))	|* Ref
|							|* ValOP2CE_01.so
|		RETIFNOK( tcbod.dll0041.get.accounting.entity(		|* Req API
|				get.compnr(),	|* Logical company
|				"LocationBOD",	|* Public noun
|				identifier,	|* Public noun identifier
|				o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_accountingEntity,		|* Ref
|				io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_accountingEntity.isSet ) )	|* Ref
							|* ValOP2CE_01.eo
							
							|* ValOP2CE_01.sn
		ret = BOD.GetIdAccountingEntity(		|* API Call
			get.compnr(),							
			"LocationBOD",						
			BOD_ENTITY_DEPARTMENT,								
			i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID,				
			"tcmcs065",					
			o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_accountingEntity,
			io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_accountingEntity.isSet,
			o.ExceptionMessage,
			o.ExceptionID )

		if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif
							|* ValOP2CE_01.en
	endif
	
	return(0)
}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_lid(
		domain	tcmcs.str50	i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID,
			boolean		i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID.isSet,
	ref	domain	tcmcs.str50	o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_lid,
	ref		boolean		io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_lid.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to return attribute
		ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_lid
		of the main component of the BOD.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID
		i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID.isSet
	Output:	o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_lid
	In/out:	io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_lid.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_lid
	EndDllUsage

	domain	tcmcs.str50	identifier
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID
	long	i
	long	ret

	o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_lid = ""
	io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_lid.isSet = false

	if not isspace( i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID ) then
		RETIFNOK( txbod.dll9002.compose.location.identifier(
				LOCATION_TYPE_OFFICE,
				i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID,
				identifier ))	|* Ref D_i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID

|							|* ValOP2CE_01.so
|		RETIFNOK( tcbod.dll0041.get.lid(		
|				get.compnr(),	|* Logical company
|				"LocationBOD",	|* Public noun
|				identifier,	|* Public noun identifier
|				o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_lid,		|* Ref
|				io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_lid.isSet ) )	|* Ref
							|* ValOP2CE_01.eo
							
							|* ValOP2CE_01.sn
		ret = BOD.GetIdLogicalID(
			 get.compnr(),
			 "LocationBOD",
			 BOD_ENTITY_DEPARTMENT,
			 i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID,
			 "tcmcs065",
			 o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_lid,
			 io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_lid.isSet,
			 o.ExceptionMessage,
			 o.ExceptionID )		

		if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif					|* ValOP2CE_01.en
		
	endif

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_accountingEntity(
		domain	tcmcs.str50	i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID,
			boolean		i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID.isSet,
	ref	domain	tcmcs.str50	o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_accountingEntity,
	ref		boolean		io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_accountingEntity.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to return attribute
		ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_accountingEntity
		of the main component of the BOD.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID
		i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID.isSet
	Output:	o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_accountingEntity
	In/out:	io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_accountingEntity.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_accountingEntity
	EndDllUsage

	domain	tcmcs.str50	identifier
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID
	long	i
	long	ret

	o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_accountingEntity = ""
	io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_accountingEntity.isSet = false

	if not isspace( i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID ) then
		RETIFNOK( txbod.dll9002.compose.location.identifier(
				LOCATION_TYPE_WAREHOUSE,
				i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID,
				identifier ))	|* Ref

|							|* ValOP2CE_01.so
|		RETIFNOK( tcbod.dll0041.get.accounting.entity(
|				get.compnr(),	|* Logical company
|				"LocationBOD",	|* Public noun
|				identifier,	|* Public noun identifier
|				o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_accountingEntity,		|* Ref
|				io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_accountingEntity.isSet ) )	|* Ref
							|* ValOP2CE_01.eo

							|* ValOP2CE_01.sn
		ret =  BOD.GetIdAccountingEntity(
			 get.compnr(),
			 "LocationBOD",
			 BOD_ENTITY_WAREHOUSE,
			 i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID,
			 "tcmcs003",
			 o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_accountingEntity,
			 io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_accountingEntity.isSet,
			 o.ExceptionMessage,
			 o.ExceptionID )
				
		if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif					|* ValOP2CE_01.en
		
 	endif

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_location(
		domain	tcmcs.str50	i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID,
			boolean		i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID.isSet,
	ref	domain	tcmcs.str100	o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_location,
	ref		boolean		io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_location.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to return attribute
		ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_location
		of the main component of the BOD.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID
		i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID.isSet
	Output:	o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_location
	In/out:	io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_location.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_location
	EndDllUsage

	domain	tcmcs.str50	identifier
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID
	long	i
	long	ret

	o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_location = ""
	io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_location.isSet = false

	if not isspace( i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID ) then
		RETIFNOK( txbod.dll9002.compose.location.identifier(
				LOCATION_TYPE_OFFICE,
				i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID,
				identifier ))	|* Ref

|							|* ValOP2CE_01.so
|		RETIFNOK( tcbod.dll0041.get.location(	* Req API
|				get.compnr(),	|* Logical company
|				"LocationBOD",	|* Public noun
|				identifier,	|* Public noun identifier
|				o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_location,		|* Ref
|				io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_location.isSet ) )	|* Ref
|							|* ValOP2CE_01.eo
		
							|* ValOP2CE_01.sn
		ret = BOD.GetIdLocation(
			 get.compnr(),
			 "LocationBOD",
			 BOD_ENTITY_DEPARTMENT,	|* iEntityType,
			 i.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID,	|* iEntityCode,
			 "tcmcs065",		|* iRootTable,
			 o.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_location,	|* oLocation,
			 io.ItemMasterHeader_ProcurementParameters_DefaultSource_ProductionLocation_ID_location.isSet,	|* oLocationisSet,
			 o.ExceptionMessage,
			 o.ExceptionID )
	
		if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif					|* ValOP2CE_01.en
	
	endif

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_lid(
		domain	tcmcs.str50	i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID,
			boolean		i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID.isSet,
	ref	domain	tcmcs.str50	o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_lid,
	ref		boolean		io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_lid.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to return attribute
		ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_lid
		of the main component of the BOD.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID
		i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID.isSet
	Output:	o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_lid
	In/out:	io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_lid.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_lid
	EndDllUsage

	domain	tcmcs.str50	identifier
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID
	long	i
	long	ret

	o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_lid = ""
	io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_lid.isSet = false

	if not isspace( i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID ) then
		RETIFNOK( txbod.dll9002.compose.location.identifier(
				LOCATION_TYPE_WAREHOUSE,
				i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID,
				identifier ))	|* Ref

|							|* ValOP2CE_01.so
|		RETIFNOK( tcbod.dll0041.get.lid(
|				get.compnr(),	|* Logical company
|				"LocationBOD",	|* Public noun
|				identifier,	|* Public noun identifier
|				o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_lid,		|* Ref
|				io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_lid.isSet ) )	|* Ref
							|* ValOP2CE_01.eo
	
							|* ValOP2CE_01.sn
		ret = BOD.GetIdLogicalID(
		 get.compnr(),			|* iCompany,
		 "LocationBOD",			|* iNoun,
		 BOD_ENTITY_WAREHOUSE,	|* iEntityType,
		 i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID,	|* iEntityCode,
		 "tcmcs003",			|* iRootTable,
		 o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_lid,	|* oLogicalID,
		 io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_lid.isSet,	|* oLogicalIDisSet,
		 o.ExceptionMessage,
		 o.ExceptionID )
	
		if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif					|* ValOP2CE_01.en
	endif

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_location(
		domain	tcmcs.str50	i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID,
			boolean		i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID.isSet,
	ref	domain	tcmcs.str100	o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_location,
	ref		boolean		io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_location.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to return attribute
		ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_location
		of the main component of the BOD.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID
		i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID.isSet
	Output:	o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_location
	In/out:	io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_location.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_location
	EndDllUsage

	domain	tcmcs.str50	identifier
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID
	long	i
	long	ret

	o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_location = ""
	io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_location.isSet = false

	if not isspace( i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID ) then
		RETIFNOK( txbod.dll9002.compose.location.identifier(
				LOCATION_TYPE_WAREHOUSE,
				i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID,
				identifier ))	|* Ref

|							|* ValOP2CE_01.so
|		RETIFNOK( tcbod.dll0041.get.location(
|				get.compnr(),	|* Logical company
|				"LocationBOD",	|* Public noun
|				identifier,	|* Public noun identifier
|				o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_location,		|* Ref
|				io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_location.isSet ) )	|* Ref
							|* ValOP2CE_01.eo
	
							|* ValOP2CE_01.sn
		ret = BOD.GetIdLocation(
			 get.compnr(),		|* iCompany,
			 "LocationBOD",		|* iNoun,
			 BOD_ENTITY_WAREHOUSE,		|* iEntityType,
			 i.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID,	|* iEntityCode,
			 "tcmcs003",			|* iRootTable,
			 o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_location,	|* oLocation,
			 io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID_location.isSet,	|* oLocationisSet,
			 o.ExceptionMessage,
			 o.ExceptionID )
 
 		if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif					|* ValOP2CE_01.en
 
	endif

	return( 0 )
}

function extern long txbod.dll9002.convert.to.quantity.in.inv.unit_API(
					domain	tcitem	i.item,
					domain	tcqst1	i.quantity,
					domain	tccuni	i.source.unit,
					domain	tccuni	i.target.unit,
				ref	domain	tcqiv1	o.conv.quantity)
{
	DllUsage
	Expl	: This function converts the quantity to inventory unit.
	Pre	: -
	Post	: -
	Input:	: i.item
		  i.quantity
		  i.source.unit
		  i.target.unit
	Output	: o.conv.quantity
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0031.convert.to.quantity.in.inv.unit
	EndDllUsage
	
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID
	long	i
	long	ret
	
	 ret = Common.ConvertQuantity(
			i.item,			|* iItem,
 			i.source.unit,		|* iFromUnit,
 			i.quantity,		|* iFromQuantity,
 			i.target.unit,		|* iToUnit,
 			o.conv.quantity,	|* oToQuantity,
 			o.ExceptionMessage,
 			o.ExceptionID )
 
		if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif
		
	return(0)
}
 
function extern long txbod.dll9002.bo.execute.bde.method_API(
			const	string	i.noun,
			const	string	i.method,
			long		i.request,
		ref	long		o.response,
		ref	long		o.result)
{
	DllUsage
	Expl	: This function executes a bde method for a specific
		  BOD.
		  Error messages are set when the DLL or method are not known.
	pre	: NA
	post	: NA
	Input	: i.noun, 	e.g. "ReceiveDeliveryWarehousingBOD"
		  i.method, 	e.g. "Create"
		  i.request	- XML structure with request
	Output	: o.response	- XML structure with response
		  o.result	- XML structure with result (error)
	return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0001.bo.execute.bde.method
	EndDllUsage
	
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID
	long	i
	long	ret
	 
 		ret =  BOD.ExecuteMethod(
 			i.noun,				|* iBusinessObject,
 			i.method,			|* iMethod,
 			i.request,			|* iXMLRequest,
 			o.response,			|* oXMLResponse,
 			o.result,			|* oXMLResult,
 			o.ExceptionMessage,
			o.ExceptionID )
 
 		if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif
	return(0)
}


function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID(
		domain	tcitem		i.ItemMasterHeader_ItemID_ID,
		domain	tcmcs.str25	i.ItemMasterHeader_ProcurementParameters_ProcurementMethodCode,
	ref	domain	tcmcs.str50	o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID,
	ref		boolean		io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID
	EndDllusage

	|* Publish the BOD even if the attribute is empty.

	long	dummy.retval

	o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID = ""
	io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID.isSet = false

|t	STOP.MESSAGES

	on case i.ItemMasterHeader_ProcurementParameters_ProcurementMethodCode
	case PROCUREMENT_TRANSFER:
		dummy.retval = get.default.warehouse.BOD(
				i.ItemMasterHeader_ItemID_ID,
				"",
				o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID )	|* Ref

		break
	endcase

|t	START.MESSAGES

	if not isspace( o.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID ) then
		io.ItemMasterHeader_ProcurementParameters_DefaultSource_WarehouseLocation_ID.isSet = true
	endif

	return( 0 )
}


function extern long txbod.dll9002.convert.from.erp.date.to.iso(
			long		i.date.conversion,
			long		i.date.format,
		domain	tcdate		i.erp.date,
	ref	domain	tcmcs.str20	o.iso.date,
	ref		boolean		o.iso.date.is.set,	
		       [boolean		i.erp.date.is.utc] )	

{
	DllUsage
	Expl	: This function does the following 2 things:
		  1. In case the i.erp.date = 0 then it determines a date based
		     on the i.date.conversion argument and converts it to iso.
		  2. In case the i.erp.date <> 0 then it converts the i.date to
		     iso.
		  If i.date.format = SET_TIME, the iso format will contain a
		  time part, otherwise not.
		  In ERPLN empty dates can have different meanings.
		  By calling this function the user can specify how the date
		  in the BOD must be filled.
		  Option SET_NO_DATE will remove the tag from the BOD.
	Pre	: -
	Post	: -
	Input	: i.date.conversion: possible values:	SET_MINIMUM_DATE
							SET_MAXIMUM_DATE
							SET_CURRENT_DATE
							SET_NO_DATE

		  i.date.format: possible values:	KEEP_TIME_FORMAT
		  					SET_TIME
		  					SET_NO_TIME
		  i.erp.date
	Output	: o.iso.date
		  o.iso.date.is.set
	Input	: i.erp.date.is.utc	- Optional
					  If i.erp.date has a value < 100000000,
					  but has to be interpret as UTC, this
					  variable must be set to 'True',
					  otherwise i.erp.date will be handled
					  as date.
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0031.convert.from.erp.date.to.iso
	EndDllUsage

		long	yearno
		long	monthno
		long	month_dayno
		long	hours
		long	minutes
		long	seconds
		boolean	erp.date.is.utc				
	domain	tcntdt	new.date
	domain	tcdate	new.utc.date

	o.iso.date = ""
	o.iso.date.is.set = false

	if get.argc() > 5 then					
		erp.date.is.utc = get.boolean.arg(6)
	else
		if i.erp.date < 100000000 then
			|* i.erp.date is date only.
			erp.date.is.utc = false
		else
			|* i.erp.date is UTC
			erp.date.is.utc = true
		endif
	endif							

	if i.erp.date > 0 then
		new.date = i.erp.date
		new.utc.date = i.erp.date

		on case i.date.format
		case SET_TIME:	
			if not erp.date.is.utc then		
				|* add time
				if num.to.date(	new.date, yearno, monthno, month_dayno) then
					dal.set.error.message("txccps3045")
					|* txccps3045  ???
					return(DALHOOKERROR)
				endif

				hours = 0
				minutes = 0
				seconds = 0
				new.utc.date = date.to.utc(yearno, monthno, month_dayno,
						hours, minutes, seconds)
			endif
			break
		case SET_NO_TIME:	
			if erp.date.is.utc then			
				|* remove time
				if utc.to.date(	new.utc.date, yearno, monthno, month_dayno,
						hours, minutes, seconds) then
					dal.set.error.message("txccps3045")
					|* txccps3045  ???
					return(DALHOOKERROR)
				endif

				new.date = date.to.num(yearno, monthno, month_dayno)
			endif
			break
		endcase
		o.iso.date.is.set = true
	else
		on case i.date.conversion
		case SET_MINIMUM_DATE:
			new.date = 1
			new.utc.date = 1
			o.iso.date.is.set = true
			break
		case SET_MAXIMUM_DATE:			
			set.max(new.date,domainof(new.date))	
			set.max(new.utc.date,domainof(new.utc.date))
			o.iso.date.is.set = true
			break
		case SET_CURRENT_DATE:		
			erp.date.is.utc = true			
			new.utc.date = utc.num()
			o.iso.date.is.set = true
			break
								
		case SET_CURRENT_DATE_NO_TIME:
			new.date = date.num()
			o.iso.date.is.set = true
			break
								
		case SET_NO_DATE:
			o.iso.date.is.set = false
			break
		endcase
	endif

	if o.iso.date.is.set then
		if i.date.format = SET_TIME or
								
		   (i.date.format = KEEP_TIME_FORMAT and erp.date.is.utc) then
		   
							|* ValOP2CE_01.so						
|			RETIFNOK(tlbct.interface.utc.to.string(	new.utc.date,
|								o.iso.date))
							|* ValOP2CE_01.eo
							
			|* Replaced with utc.to.iso()				
			o.iso.date = utc.to.iso(new.utc.date)	|* ValOP2CE_01.n
		else
		
							|* ValOP2CE_01.so
|			RETIFNOK(tlbct.interface.date.to.string(new.date,
|								o.iso.date))
							|* ValOP2CE_01.eo
							
			|* Replaced with date.to.iso()	
 			o.iso.date = date.to.iso(new.date)	|* ValOP2CE_01.n
		endif
	endif

	return(0)
}


function extern long txbod.dll9002.get.user.area.node(
				domain	tcmcs.long	i.arr.length,
				const	string		i.name(,),
				const	string		i.type(,),
				const	string		i.value(,),
			ref	string			i.description(,),
			ref	domain	tcdate		i.start.date(),
			ref	domain	tcdate		i.end.date(),
			ref	domain	tcmcs.long	o.xml.node,
			ref	boolean			o.xml.node.is.set)
{
	DllUsage
	Expl	: This function creates a user area node.
		  Only i.name, i.type and i.value are mandatory.
		  For PROP_TYPE_TIME format HH:MM:SS is expected for the value.

		  <UserArea>
		  	<Property>
		  		<NameValue name="aaa" type="bbb">xxx</NameValue>
		  		<Description>
			  	<EffectiveTimePeriod>
			  		<StartDateTime>
			  		<EndDateTime>
			  	</EffectiveTimePeriod>
			</Property>
		  </UserArea>
	Pre	: -
	Post	: -
	Input	: i.arr.length
		  i.name
		  i.type - Allowed values are:	PROP_TYPE_STRING
		  				PROP_TYPE_NUMERIC
		  				PROP_TYPE_INDICATOR
		  				PROP_TYPE_DATETIME
						PROP_TYPE_INTEGER_NUMERIC
						PROP_TYPE_DATE
						PROP_TYPE_TIME
		  i.value
		  i.description
		  i.start.date
		  i.end.date
	Output	: o.xml.node
		  o.xml.node.is.set
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0033.get.user.area.node
	EndDllUsage

	long	i

	o.xml.node = 0
	o.xml.node.is.set = false

	if i.arr.length = 0 then
		return(0)
	endif

	for i = 1 to i.arr.length
		RETIFNOK(txbod.dll9002.get.user.area.extended.node(
				UA_NAME, i.name(1,i),
				UA_TYPE, i.type(1,i),
				UA_VALUE, i.value(1,i),
				o.xml.node,
				o.xml.node.is.set))

		if not isspace(i.description(1,i)) then
			RETIFNOK(txbod.dll9002.get.user.area.extended.node(
				UA_DESC, i.description(1,i),
				o.xml.node,
				o.xml.node.is.set))
		endif

		if i.start.date(i) > 0 or i.end.date(i) > 0 then
			RETIFNOK(txbod.dll9002.get.user.area.extended.node(
				UA_STARTDATE, str$(i.start.date(i)),
				UA_ENDDATE, str$(i.end.date(i)),
				o.xml.node,
				o.xml.node.is.set))
		endif
	endfor

	return(0)
}


function extern long txbod.dll9002.bo.get.user.area.node(...)
{
	DllUsage
	Expl:	The purpose of this function is to create or extend the
		UserArea node.

		Example:
		<UserArea>
			<Property>
				<NameValue name = "ln.OrderType", type = "StringType">ORD</NameValue>
			</Property>
			<Property>
				<NameValue name="aaa" type="bbb">xxx</NameValue>
				<Description>
				<EffectiveTimePeriod>
					<StartDateTime>
					<EndDateTime>
				</EffectiveTimePeriod>
		  	</Property>
			<Property>
				<NameValue name = "ln.OrderAmount", type = "AmountType" unitCode="PCS">10.5</NameValue>
			</Property>

		It is assumed that conversions to ISO values are already done
		for currencyID and unitCode. Only dates are converted to ISO 
		based on the long values.
	Pre:	N.a.
	Post:	N.a.
	Input:	dynamic:	name - value pairs
		node.user.area
		node.user.area.is.set
		
		The name should be one of the following defines:
		- UA_NAME	- indicates, the next arg. is the name
		- UA_TYPE	- indicates, the next arg. is the type, related to the name
		- UA_VALUE	- indicates, the next arg. is the value, relatded to the name
		- UA_ATTR_NAME	- indicates, the next arg. is the name of the additional attribute
		- UA_ATTR_VALUE	- indicates, the next arg. is the value of the additional attribute
		- UA_DESC	- indicates, the next arg. is the Description value
		- UA_STARTDATE	- indicates, the next arg. is the StartDateTime value
		- UA_ENDDATE	- indicates, the next arg. is the EndDateTime value
	
		--> In the function call, the same sequence must be used!
	
		Example:

		bobod.dll1033.get.user.area.node(
				|* first name, type, value
				UA_NAME, PROP_NAME_ORDER_TYPE,
				UA_TYPE, PROP_TYPE_STRING,
				UA_VALUE, "ORD",

				|* second name, type, value incl. additional attributes
				UA_NAME, PROP_NAME_FINANCIALCALENDAR,
				UA_TYPE, PROP_TYPE_MASTERDATA_REFERENCE,
				UA_VALUE, "C_FISCAL",
					UA_ATTR_NAME, ATTR_NOUN_NAME,
					UA_ATTR_VALUE, "FinancialCalendar",
					UA_ATTR_NAME, ATTR_ACCOUNTING_ENTITY,
					UA_ATTR_VALUE, "DV1_422",
				
				|* third name, type, value incl. Description, StartDateTime and EndDateTime
				UA_NAME, PROP_NAME_CREATIONDATE,
				UA_TYPE, PROP_TYPE_DATETIME,
				UA_VALUE, str$(utc.num()),
				UA_DESC, "MyDescription",
				UA_STARTDATE, str$(utc.num()),
				UA_ENDDATE, str$(utc.num()),
				
				|* fourth name, type, value incl. additional attributes
				UA_NAME, PROP_NAME_STOCK_QUANTITY,
				UA_TYPE, PROP_TYPE_QUANTITY,
				UA_VALUE, "12.34",
					UA_ATTR_NAME, ATTR_UNITCODE,
					UA_ATTR_VALUE, "BOX",
				xml.node,
				xml.node.is.set)
		
	Output:	node.user.area
		node.user.area.is.set
		
		Example:
		
		<UserArea>
			<Property>
				<NameValue
					name="ln.OrderType"
					type="StringType">ORD</NameValue>
			</Property>
			<Property>
				<NameValue
					name="ln.FinancialCalendar"
					type="MasterDataReferenceType"
					nounName="FinancialCalendar"
					accountingEntity="DV1_422">C_FISCAL</NameValue>
			</Property>
			<Property>
				<NameValue
					name="ln.CreationDate"
					type="DateTimeType">2015-12-18T12:54:29Z</NameValue>
				<Description>MyDescription</Description>
				<EffectiveTimePeriod>
					<StartDateTime>2015-12-18T12:54:29Z</StartDateTime>
					<EndDateTime>2015-12-18T12:54:29Z</EndDateTime>
				</EffectiveTimePeriod>
			</Property>
			<Property>
				<NameValue
					name="ln.StockQuantity"
					type="QuantityType"
					unitCode="BOX">12.34</NameValue>
			</Property>
		</UserArea>
		
	Return: 0/DALHOOKERROR
	Old Dll : bobod.dll1033.get.user.area.node
	EndDllUsage


	long	i
	long	nr.arguments
	long	return.value
	long	dummy.value

	long	node.user.area
	long	node.property
	long	node.name.value
	long	node.description
	long	node.eff.time.period
	long	node.start.date
	long	node.end.date

	boolean	skip
	boolean	dummy.skip
	boolean	node.user.area.is.set

	string	date.type(12)

	string	b.hold.name(1)	based
	string	b.hold.type(1)	based
	string	b.value(1)	based
	string	b.start.date(1)	based
	string	b.end.date(1)	based

	#define	INIT_GET_USERAREA_NODE
^		free.mem( b.hold.name )
^		free.mem( b.hold.type )
^		free.mem( b.value )
^		free.mem( b.start.date )
^		free.mem( b.end.date )

	#define	ERROR_GET_USERAREA_NODE( i_RETURN_VALUE )
^		if i_RETURN_VALUE <> 0 then
^			if node.user.area <> 0 then
^				dummy.value = xmlDelete( node.user.area )
^				node.user.area = 0
^			endif
^			node.user.area.is.set = false
^			END_GET_USERAREA_NODE( i_RETURN_VALUE )
^		endif

	#define	END_GET_USERAREA_NODE( i_RETURN_VALUE )
^		INIT_GET_USERAREA_NODE
^		return( i_RETURN_VALUE )

	nr.arguments = get.argc()

	node.user.area = get.long.arg(nr.arguments-1)
	node.user.area.is.set = get.boolean.arg(nr.arguments)

	if node.user.area = 0 then
		return.value = txbod.dll9002.new.node(
					TAG_USER_AREA,
					node.user.area )	|* Ref

		ERROR_GET_USERAREA_NODE( return.value )
	endif

	node.user.area.is.set = true

	for i = 1 to nr.arguments -2 step 2
		on case get.string.arg(i)
		case UA_NAME:
			|* UserAreaName, UserAreaType en UserAreaValue are
			|* mandatory. Here, only store the name.
			SET_BASED_VARIABLE(get.string.arg(i+1),b.hold.name)

			break
		case UA_TYPE:
			|* UserAreaName, UserAreaType en UserAreaValue are
			|* mandatory. Here, only store the type.
			return.value = check.supported.property.type(
						get.string.arg(i+1))

			ERROR_GET_USERAREA_NODE( return.value )

			SET_BASED_VARIABLE(get.string.arg(i+1),b.hold.type)

			break
		case UA_VALUE:
			|* UserAreaName, UserAreaType en UserAreaValue are
			|* mandatory. Here, convert the value and create the
			|* Property node if needed.
			
			node.property = 0
			node.name.value = 0
			node.description = 0
			node.eff.time.period = 0
			node.start.date = 0
			node.end.date = 0

			return.value = convert.value(
					b.hold.type,
					get.string.arg(i+1),
					skip,		|* Ref
					b.value)	|* Ref

			ERROR_GET_USERAREA_NODE( return.value )

			if skip then
				|* Reset the Property node if the Property must
				|* be skipped, based no the UserAreaValue.
				|* For example if a date is 0.

				break
			endif

			|* Create element Property in UserArea.
			return.value = txbod.dll9002.new.node(
					TAG_PROPERTY,
					node.property,		|* Ref
					node.user.area )	|* Parent node

			ERROR_GET_USERAREA_NODE( return.value )

			|* Create element NameValue in Property.
			return.value = txbod.dll9002.new.data.element(
					TAG_NAME_VALUE,
					strip$( b.value ),
					node.name.value,	|* Ref
					node.property)		|* Parent node

			ERROR_GET_USERAREA_NODE( return.value )

			|* Create attribute name in NameValue.
			return.value = txbod.dll9002.set.attribute(
					node.name.value,
					ATTR_NAME,
					trim$(b.hold.name))

			ERROR_GET_USERAREA_NODE( return.value )

			|* Create attribute type in NameValue.
			return.value = txbod.dll9002.set.attribute(
					node.name.value,
					ATTR_TYPE,
					trim$(b.hold.type))

			ERROR_GET_USERAREA_NODE( return.value )

			break
		case UA_ATTR_NAME:
			|* UserAreaAttributeName and UserAreaAttributeValue
			|* are a pair. Here, only store the
			|* UserAreaAttributeName.
			if node.name.value <> 0 then
				return.value = check.supported.attribute.name(
							b.hold.type,
							get.string.arg(i+1))

				ERROR_GET_USERAREA_NODE( return.value )

				SET_BASED_VARIABLE(get.string.arg(i+1),b.hold.name)
			endif

			break
		case UA_ATTR_VALUE:
			|* UserAreaAttributeName and UserAreaAttributeValue
			|* are a pair. Here, create attribute 
			|* UserAreaAttributeName in NameValue.
			if node.name.value <> 0 then
				return.value = txbod.dll9002.set.attribute(
						node.name.value,
						b.hold.name,
						strip$(get.string.arg(i+1)))

				ERROR_GET_USERAREA_NODE( return.value )
			endif

			free.mem( b.hold.name )

			break
		case UA_DESC:
			|* Create element Description in Property.
			if not isspace(get.string.arg(i+1)) then
				if node.property = 0 then
					return.value = txbod.dll9002.new.node(
							TAG_PROPERTY,
							node.property,		|* Ref
							node.user.area )	|* Parent node

					ERROR_GET_USERAREA_NODE( return.value )
				endif

				return.value = txbod.dll9002.new.data.element(
						TAG_DESCRIPTION,
						trim$(get.string.arg(i+1)),
						node.description,	|* Ref
						node.property )		|* Parent node

				ERROR_GET_USERAREA_NODE( return.value )
			endif

			break
		case UA_STARTDATE:
			|* Create element EffectiveTimePeriod in Property and
			|* element StartDateTime in EffectiveTimePeriod.
			if lval(get.string.arg(i+1)) > 0 then
				if node.property = 0 then
					return.value = txbod.dll9002.new.node(
							TAG_PROPERTY,
							node.property,		|* Ref
							node.user.area )	|* Parent node

					ERROR_GET_USERAREA_NODE( return.value )
				endif

				return.value = txbod.dll9002.new.node(
						TAG_EFF_TIME_PERIOD,
						node.eff.time.period,	|* Ref
						node.property )		|* Parent node

				ERROR_GET_USERAREA_NODE( return.value )

				if lval(get.string.arg(i+1)) > 99999999 then
					date.type = PROP_TYPE_DATETIME
				else
					date.type = PROP_TYPE_DATE
				endif

				return.value = convert.value(
						date.type,
						get.string.arg(i+1),
						dummy.skip,	|* Ref
						b.start.date)	|* Ref

				ERROR_GET_USERAREA_NODE( return.value )

				return.value = txbod.dll9002.new.data.element(
						TAG_START_DATE_TIME,
						b.start.date,
						node.start.date,	|* Ref
						node.eff.time.period)	|* Parent

				ERROR_GET_USERAREA_NODE( return.value )
			endif

			break
		case UA_ENDDATE:
			|* Create element EffectiveTimePeriod in Property and
			|* element EndDateTime in EffectiveTimePeriod.
			if lval(get.string.arg(i+1)) > 0 then
				if node.property = 0 then
					return.value = txbod.dll9002.new.node(
							TAG_PROPERTY,
							node.property,		|* Ref
							node.user.area )	|* Parent node

					ERROR_GET_USERAREA_NODE( return.value )
				endif

				if node.eff.time.period = 0 then
					return.value = txbod.dll9002.new.node(
						TAG_EFF_TIME_PERIOD,
						node.eff.time.period,	|* Ref
						node.property )		|* Parent node

					ERROR_GET_USERAREA_NODE( return.value )
				endif

				if lval(get.string.arg(i+1)) > 99999999 then
					date.type = PROP_TYPE_DATETIME
				else
					date.type = PROP_TYPE_DATE
				endif

				return.value = convert.value(
						date.type,
						get.string.arg(i+1),
						dummy.skip,	|* Ref
						b.end.date)	|* Ref

				ERROR_GET_USERAREA_NODE( return.value )

				return.value = txbod.dll9002.new.data.element(
						TAG_END_DATE_TIME,
						b.end.date,
						node.end.date,		|* Ref
						node.eff.time.period)	|* Parent

				ERROR_GET_USERAREA_NODE( return.value )
				
				node.eff.time.period = 0
			endif

			break
		endcase
	endfor

	put.long.arg(nr.arguments-1, node.user.area)
	put.boolean.arg(nr.arguments, node.user.area.is.set)

	END_GET_USERAREA_NODE( 0 )
}

function extern long txbod.dll9002.get.user.area.extended.node(...)
{
	DllUsage
	Expl:	The purpose of this function is to create or extend the
		UserArea node.

		Example:
		<UserArea>
			<Property>
				<NameValue name = "ln.OrderType", type = "StringType">ORD</NameValue>
			</Property>
			<Property>
				<NameValue name="aaa" type="bbb">xxx</NameValue>
				<Description>
				<EffectiveTimePeriod>
					<StartDateTime>
					<EndDateTime>
				</EffectiveTimePeriod>
		  	</Property>
			<Property>
				<NameValue name = "ln.OrderAmount", type = "AmountType" unitCode="PCS">10.5</NameValue>
			</Property>
	Pre:	N.a.
	Post:	N.a.
	Input:	dynamic:	name - value pairs
		node.user.area
		node.user.area.is.set
		
		The name should be one of the following defines:
		- UA_NAME	- indicates, the next arg. is the name
		- UA_TYPE	- indicates, the next arg. is the type, related to the name
		- UA_VALUE	- indicates, the next arg. is the value, relatded to the name
		- UA_ATTR_NAME	- indicates, the next arg. is the name of the additional attribute
		- UA_ATTR_VALUE	- indicates, the next arg. is the value of the additional attribute
		- UA_DESC	- indicates, the next arg. is the Description value
		- UA_STARTDATE	- indicates, the next arg. is the StartDateTime value
		- UA_ENDDATE	- indicates, the next arg. is the EndDateTime value
		
		Example:

		tcbod.dll0033.get.user.area.extended.node(
				|* first name, type, value
				UA_NAME, PROP_NAME_ORDER_TYPE,
				UA_TYPE, PROP_TYPE_STRING,
				UA_VALUE, "ORD",

				|* second name, type, value incl. additional attributes
				UA_NAME, PROP_NAME_FINANCIALCALENDAR,
				UA_TYPE, PROP_TYPE_MASTERDATA_REFERENCE,
				UA_VALUE, "C_FISCAL",
					UA_ATTR_NAME, ATTR_NOUN_NAME,
					UA_ATTR_VALUE, "FinancialCalendar",
					UA_ATTR_NAME, ATTR_ACCOUNTING_ENTITY,
					UA_ATTR_VALUE, "DV1_422",
				
				|* third name, type, value incl. Description, StartDateTime and EndDateTime
				UA_NAME, PROP_NAME_CREATIONDATE,
				UA_TYPE, PROP_TYPE_DATETIME,
				UA_VALUE, str$(utc.num()),
				UA_DESC, "MyDescription",
				UA_STARTDATE, str$(utc.num()),
				UA_ENDDATE, str$(utc.num()),
				
				|* fourth name, type, value incl. additional attributes
				UA_NAME, PROP_NAME_STOCK_QUANTITY,
				UA_TYPE, PROP_TYPE_QUANTITY,
				UA_VALUE, "12.34",
					UA_ATTR_NAME, ATTR_UNITCODE,
					UA_ATTR_VALUE, "BOX",
				xml.node,
				xml.node.is.set)
		
	Output:	node.user.area
		node.user.area.is.set
		
		Example:
		
		<UserArea>
			<Property>
				<NameValue
					name="ln.OrderType"
					type="StringType">ORD</NameValue>
			</Property>
			<Property>
				<NameValue
					name="ln.FinancialCalendar"
					type="MasterDataReferenceType"
					nounName="FinancialCalendar"
					accountingEntity="DV1_422">C_FISCAL</NameValue>
			</Property>
			<Property>
				<NameValue
					name="ln.CreationDate"
					type="DateTimeType">2015-12-18T12:54:29Z</NameValue>
				<Description>MyDescription</Description>
				<EffectiveTimePeriod>
					<StartDateTime>2015-12-18T12:54:29Z</StartDateTime>
					<EndDateTime>2015-12-18T12:54:29Z</EndDateTime>
				</EffectiveTimePeriod>
			</Property>
			<Property>
				<NameValue
					name="ln.StockQuantity"
					type="QuantityType"
					unitCode="BOX">12.34</NameValue>
			</Property>
		</UserArea>
		
	Return: 0/DALHOOKERROR
	Old Dll : tcbod.dll0033.get.user.area.extended.node
	EndDllUsage
	
	long	i
	long	nr.arguments
	long	node.user.area
	long	return.value
	long	return.value.exec
	long	last.comma
	long	previous.comma
	
	string	object(15)
	string	function.name(2048)
	string	function.call(2048)
	string	converted.string(2048)

	#define	ARG_NO_USER_AREA	(nr.arguments - 1)
	#define	ARG_NO_USER_AREA_IS_SET	(nr.arguments)
	
	return.value = 0
	
	nr.arguments = get.argc()

|	object = "oboboddll1033"			|#valmet_op_ce_01.so
|	function.name = "bobod.dll1033.get.user.area.node"
							|#valmet_op_ce_01.eo
							
							|#valmet_op_ce_01.sn
	object = "otxboddll9002"
	function.name = "txbod.dll9002.bo.get.user.area.node"
							|#valmet_op_ce_01.en
	
	function.call = function.name & "("

	for i = 1 to nr.arguments - 2
		converted.string =
			txbod.dll9002.convert.string.for.parsing(
				get.string.arg( i ))

		function.call = function.call &
				"""" & converted.string & """" & ","
	endfor

	|* Add 'UserArea' node.
	node.user.area = get.long.arg( ARG_NO_USER_AREA )
	function.call = function.call & str$( node.user.area ) &
			"," & str$(0)

	function.call = function.call & ")"

	|* Execute function call.
	return.value.exec = parse_and_exec_function(
				object,
				function.call,
				return.value,	|* Ref
				function.call )	|* Ref

	RETIFNOK( txbod.dll9002.check.return.of.exec(
			return.value.exec,
			object,
			function.name ))

	|* Get node from function call.
	last.comma = rpos( function.call, "," )
	previous.comma = rpos( function.call(1;last.comma-1), "," )

	node.user.area = val( function.call(
				(previous.comma + 1);
				(last.comma - previous.comma )))

	|* Put node to output argument.
	put.long.arg( ARG_NO_USER_AREA, node.user.area )

	|* Put 'isSet'-flag to output argument.
	put.boolean.arg(
		ARG_NO_USER_AREA_IS_SET,
		node.user.area <> 0 ? true : false )

	return( return.value )
}

function extern string txbod.dll9002.convert.string.for.parsing(
				const string	i.old.string)
{
	DllUsage
	Expl	: This function replaces 1 " by 2 ""-'s.
		  This is necessary when using function parse_and_exec_function
	Pre	: -
	Post	: -
	Input	: i.old.string
	Output	: -
	Return	: converted string
	Old Dll : tcbod.dll0038.convert.string.for.parsing
	EndDllUsage

	long	start.pos
	long	found.pos
	long	len.old.string

	string	new.string(4096)

	if isspace(i.old.string) then
		return("")
	endif

	len.old.string = len(i.old.string)

	new.string = ""

	start.pos = 1
	found.pos = pos(i.old.string,"""")

	while found.pos > 0
		new.string =	new.string &
				i.old.string(start.pos;found.pos) & """"

		start.pos = start.pos + found.pos
		if start.pos > len.old.string then
			return(new.string)
		endif

		found.pos = pos(i.old.string(start.pos),"""")

	endwhile

	new.string = new.string & i.old.string(start.pos)

	return(new.string)
}

function extern long txbod.dll9002.check.return.of.exec(
				long		i.ret.exec,
				const string	i.dll.name,
				const string	i.function.name)
{
	DllUsage
	Expl	: This function checks the return value and sets an error
		  message.
	Pre	: -
	Post	: -
	Input	: i.ret.exec
		  i.dll.name
		  i.function.name
	Output	: -
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0038.check.return.of.exec
	EndDllUsage

	on case i.ret.exec
	case -1:
		dal.set.error.message("txbods0016", trim$(i.dll.name))
		|* No unit found for ISO Code %1$s.
		return(DALHOOKERROR)
	case -2:
		dal.set.error.message(	"txbods0034",
		|* txbods0034  ???
					trim$(i.function.name) &
					" (" &
					trim$(i.dll.name) &
					") ")
		|* Function %1$s not found.
		return(DALHOOKERROR)
	case -3:
		dal.set.error.message("txbods0035", trim$(i.function.name))
		|* txbods0035  ???
		return(DALHOOKERROR)
	endcase

	return(0)
}

function extern long txbod.dll9002.get.custom.fields(
				domain	tcbod.name	i.noun,
				const	string		i.component,
						... )
{
	DllUsage
	Expl	: This function adds custom fields specified in a custom DLL (cc)
		  to a node. If the node is not specified, a node is created.
	Pre	: -
	Post	: -
	Input	: i.noun
		  i.component
		  Table field - value pairs (multiple pairs can be passed)
	In/out	: io.node		- For example: io.UserArea
		  io.node.is.set	- For example: io.UserArea.is.set
	Output	: -
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0038.get.custom.fields
	EndDllUsage

	long	type
	long	argument.number
	long	nr.arguments
	long	position.comma
	long	position.bracket
	long	node.user.area
	long	return.value
	long	return.value.exec
	string	object(15)
	string	function.name(2048)
	string	function.call(2048)
	string	converted.string(2048)
	domain	tcbod.impl	identifier

	#define	FIRST_PAIR_ARGUMENT	3
	#define LAST_PAIR_ARGUMENT	(nr.arguments - 2)
	#define	ARG_NO_USER_AREA	(nr.arguments - 1)
	#define	ARG_NO_USER_AREA_IS_SET	(nr.arguments)

	|* Get identifier BOD.
	RETIFNOK( txbod.dll9002.get.bod.identifier(
				i.noun,
				identifier ))

	|* Compose object based on identifier.
	object = 	"o" &
			identifier(1;5) &
			"bl" & identifier(6;3) & "sb00"
	|* Example: boibdbl505sb00

	|* Compose function name based on identifier.
	function.name =	identifier(1;5) &
			".bl" & identifier(6;3) & "sb00." &
			trim$(i.component) & ".add.custom.output.if.any"
	|* Examples:
	|* boibd.bl505sb00.ItemMasterCommonBOD.add.custom.output.if.any
	|* boibd.bl505sb00.UOMCodeConversion.add.custom.output.if.any

	nr.arguments = get.argc()

	|* Compose function call based on function name and input arguments.
	function.call = function.name & "("
	|* Add 'UserArea' node.
	node.user.area = get.long.arg( ARG_NO_USER_AREA )
	function.call = function.call & str$( node.user.area ) & ","

	for argument.number = FIRST_PAIR_ARGUMENT to LAST_PAIR_ARGUMENT
		type = get.arg.type( argument.number)

		on case type
		case DB.LONG:
			function.call =
				function.call &
				str$( get.long.arg( argument.number ))
			break
		case DB.DOUBLE:
			function.call =
				function.call &
				str$( get.double.arg( argument.number ))
			break
		case DB.STRING:
		case DB.MULTIBYTE:
			converted.string =
				txbod.dll9002.convert.string.for.parsing(
					get.string.arg( argument.number ))

			function.call = function.call &
					"""" & converted.string & """"
			break
		endcase

		if argument.number < LAST_PAIR_ARGUMENT then
			function.call = function.call & ","
		endif
	endfor

	function.call = function.call & ")"

	|* Execute function call.
	return.value.exec = parse_and_exec_function(
				object,
				function.call,
				return.value,	|* Ref
				function.call )	|* Ref

	|* Check return value parse and exec function.
	RETIFNOK( txbod.dll9002.check.return.of.exec(
			return.value.exec,
			object,
			function.name ))

	|* Get node from function call.
	position.bracket = pos( function.call, "(" )
	position.comma = pos( function.call, "," )

	node.user.area =
		lval( function.call(
			(position.bracket + 1);
			(position.comma - position.bracket )))

	|* Put node to output argument.
	put.long.arg( ARG_NO_USER_AREA, node.user.area )

	|* Set handling of custom fields by tools can be skipped.
	RETIFNOK( txbod.dll9002.skip.custom.fields.by.tools(
			i.noun,
			i.component ))

	|* Put 'isSet'-flag to output argument.
	put.boolean.arg(
		ARG_NO_USER_AREA_IS_SET,
		node.user.area <> 0 ? true : false )

	return( return.value )
}

function extern long txbod.dll9002.skip.custom.fields.by.tools(
				domain	tcbod.name	i.noun,
				const	string		i.component )
{
	DllUsage
	Expl	: This function sets a flag for the component to indicate if
		  handling of the custom fields can be skipped by tools.
		  The default value of the flag is 'true'. With this function
		  the flag can be set to 'false'.
	Pre	: -
	Post	: -
	Input	: i.noun
		  i.component
	Output	: -
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0038.skip.custom.fields.by.tools
	EndDllUsage

	long	return.value.exec
	string	object(15)
	string	function.name(2048)
	string	function.call(2048)
	domain	tcbod.impl	identifier

	RETIFNOK( txbod.dll9002.get.bod.identifier(
			i.noun,
			identifier ))	|* Ref

	object = "o" & identifier(1;5) & "bl" & identifier(6;3) & "st00"
	|* Example: boibdbl505st00

	function.name =
		identifier(1;5) & ".bl" & identifier(6;3) &
		"st00.do.not.add." & trim$( i.component ) & ".custom.output"
	|* Examples:
	|* boibd.bl505st00.do.not.add.ItemMasterCommonBOD.custom.output
	|* boibd.bl505st00.do.not.add.UOMCodeConversion.custom.output

	function.call = function.name & "()"

	return.value.exec = parse_and_exec_function( object, function.call )

	|* If a BOD is generated with a Business Studio version earlier then
	|* 8.7.0.0161, external function '...add.custom.output.if.any' is not
	|* generated. To be able to support this case without error, return
	|* value -2 of parse and exec function is ignored.
	|*
	|* Examples of BODs without0 the external function are:
	|*  1. Customized BODs on customer systems, generated with Business
	|*     Studio < 8.7.0.0161.
	|*  2. BODs not regenerated in BOD package 2.0.
	if return.value.exec <> -2 then
		RETIFNOK( txbod.dll9002.check.return.of.exec(
				return.value.exec,
				object,
				function.name ))
	endif

	return( 0 )
}

function extern long txbod.dll9002.add.node.to.stack(
		long	i.xml.node,
	ref	long	io.xml.node.stack(),
	ref	boolean	io.xml.node.is.set.stack(),
	ref	long	io.xml.node.stack.size )
{
	DllUsage
	Expl:	The purpose of this function is to add a node to the stack.

		- If needed, the stack size is increased with size of
		  ALLOCATION_SIZE.
		- If added:
			# The isSet-flag of the stack position is set to 'true'.
			# Variable for the stack size (io.xml.node.stack.size)
			  is increased with one.

		For example the function can be used for repeatable attributes
		implemented with datatype ERPAnyType0.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.xml.node
	Output:	io.xml.node.stack
		io.xml.node.is.set.stack
		io.xml.node.stack.size
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll0038.add.node.to.stack
	EndDllUsage

	long	dummy.value
	long	stack.size
	long	dimensions.stack(4)

	if i.xml.node <> 0 then
		|* Get actual stack size.
		array.info( io.xml.node.stack, dummy.value, dimensions.stack )
		stack.size = dimensions.stack(1)

		|* An actual stack size < variable 'io.xml.node.stack.size'
		|* is not expected. In this case the variable and the stack
		|* size are out of sync.
		if stack.size < io.xml.node.stack.size then
			dal.set.error.message(
				"@A stack size (" &
				str$( io.xml.node.stack.size ) &
				") smaller than the actual stack size (" &
				str$( stack.size ) & ") is not expected." )

			return( DALHOOKERROR )
		endif
 
		|* New stack position.
		INC( io.xml.node.stack.size )

		|* Increase stack size if new stack position is not available.
		if io.xml.node.stack.size > stack.size then
			stack.size = stack.size + ALLOCATION_SIZE

			dummy.value = alloc.mem(
					io.xml.node.stack,
					stack.size )

			dummy.value = alloc.mem(
					io.xml.node.is.set.stack,
					stack.size )
		endif

		|* Add node to stack en set isSet flag.
		io.xml.node.stack(io.xml.node.stack.size) = i.xml.node
		io.xml.node.is.set.stack(io.xml.node.stack.size) = true
	endif

	return( 0 )
}

function extern long txbod.dll9002.get.bod.identifier(
		domain	bobod.name	i.name,
	ref	domain	bobod.impl	o.identifier )
{
	DllUsage
	Expl	: This function retrieves the identifier of a BOD.

		  Error message is set when no metadata found for the BOD.
	pre	: N.a.
	post	: N.a.
	Input	: i.name	- BOD name (e.g. CodeDefinitionBOD)
	Output	: o.identiifer
	return	: 0/DALHOOKERROR
	Old Dll : tcbod.dll0032.get.bod.identifier
	EndDllUsage

		long		dummy.visibility
	domain	bobod.type	dummy.type
	domain	bobod.name	dummy.parent.bod
	domain	boyesno		dummy.support.ae
	string			dummy.parm.string(PARM_STRING)

	RETIFNOK( get.bod.metadata.by.name(
			i.name,
			o.identifier,		|* Ref
			dummy.visibility,	|* Ref
			dummy.type,		|* Ref
			dummy.parent.bod,	|* Ref
			dummy.support.ae,	|* Ref
			dummy.parm.string ))

	return( 0 )
}

function extern boolean txbod.dll9002.subscription.exists(
		long	i.company,
	const	string	i.bod,
	const	string	i.verb )
{
	DllUsage
	Expl:	This function checks if a subscription exists for a specified
		BOD and verb in current company.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.company
		i.bod
		i.verb
	Output:	N.a.
	Return:	True	- Subscription exists
		False	- Subscription doesnot exist.
	Old Dll : bobod.dll1029.subscription.exists
	EndDllusage

	long	return.value
	boolean	subscription.exists

|t	STOP.MESSAGES

	return.value = txbod.dll0002.check.subscription.exists(
			i.company,
			i.bod,
			i.verb,
			subscription.exists )	|* Ref

|t	START.MESSAGES

	if return.value = 0 then
		|* Subscription exists.
		return( true )
	else
		|* Subscription does not exists.
		return( false )
	endif
}

function extern long txbod.dll0002.check.subscription.exists(
		long	i.company,
	const	string	i.bod,
	const	string	i.verb,
	ref	boolean	o.subscription.exists )
{
	DllUsage
	Expl:	This function checks if a subscription exists for a specified
		BOD and verb in current company.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.company
		i.bod
		i.verb
	Output:	o.subscription.exists
	Return:	0/DALHOOKERROR
	Old Dll :  bobod.dll1029.check.subscription.exists
	EndDllusage
			long		return.value
		domain	tcbod.loid	logical.id
		domain	tcbod.name	noun
		domain	tcbod.name	public.bod
	static		boolean		s.subscription.exists
	static	domain	tcncmp		s.company
	static	domain	tcbod.name	s.bod
	static	domain	tcmcs.str7	s.verb
	static	domain	tcmcs.str300m	s.error.message

	o.subscription.exists = false

	RETIFNOK( txbod.dll9002.get.bod.public(
			i.bod,
			public.bod ) )	|* Ref

	if i.company <> s.company or
	   i.bod <> s.bod or
	   i.verb <> s.verb then
		s.company = i.company
		s.bod = i.bod
		s.verb = i.verb
		s.subscription.exists = false

		noun = txbod.dll9002.convert.noun.name.to.without.bod(
					public.bod)

|t		STOP.MESSAGES

		return.value = determine.logical.id(
				s.company,
				s.verb,
				noun,
				logical.id )	|* Ref

|t		START.MESSAGES

		|* Assumption:
		|* Variable 'logical.id':
		|* - Is filled if return value of function is 0.
		|* - Is filled with (1) logical ID or with (2) '*' if no
		|*   subscription is found and call back function is set.

		if (return.value = 0 and trim$( logical.id ) <> "*") then
			|* Subscription found.

			s.subscription.exists = true
		else
			|* No subscription found.

			s.error.message = sprintf$(
						form.text$( "tcbods0109" ),
						|* tcbods0109  ???
						trim$( i.verb ),
						trim$( noun ),
						s.company )
			|* No subscription exists for Verb '%1$s', Noun %2$s'
			|* and Company '%3$d'.
		endif
	endif

	o.subscription.exists = s.subscription.exists

	if not s.subscription.exists then
		dal.set.error.message( "@" & s.error.message )

		return( DALHOOKERROR )
	endif

	return( 0 )
}



function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ItemID(
		domain	tcitem		i.ERPItem,
			boolean		i.ERPItem.isSet,
	ref	domain	tcmcs.long	o.ItemMasterHeader_ItemID(),
	ref		boolean		o.ItemMasterHeader_ItemID.isSet(),
	ref		long		o.ItemMasterHeader_ItemID.size )
{
	DllUsage
	Expl:	The purpose of this function is to add the DocumentID and
		Business Partner Item Code(s) to the BOD. The used XML structure
		is ItemID/ID for both.
	Pre:	N.a.
	Post:	N.a.
	Args:	i.ERPItem
		i.ERPItem.isSet
		o.ItemMasterHeader_ItemID
		o.ItemMasterHeader_ItemID.isSet
		o.ItemMasterHeader_ItemID.size
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ItemID
	EndDllUsage

		long		xml.node(1)
		long		dummy.value
		boolean		xml.node.is.set(1)
	domain	tcmcs.str50	bod.item
	domain	tccom.bpid	business.partner
	domain	tccitt		item.code.system
	domain	tcaitm		business.partner.item.code
		long		arr.sequence			
		long		o.number.of.business.partners
	domain	tccom.bpid	o.business.partner.array(1) based
	domain	tcaitm		o.bp.packaging.item.code.array(1) based
	domain	tcaitm		o.packaging.classification.array(1) based
		boolean		business.partner.packaging	
		
		long	ret,i
	domain tcmcs.s999m exception.message
	long	exception.id 

	free.mem( o.ItemMasterHeader_ItemID )
	free.mem( o.ItemMasterHeader_ItemID.isSet )
	o.ItemMasterHeader_ItemID.size = 0
	o.number.of.business.partners = 0			
	business.partner.packaging = false			

	|* Convert the item to the BOD item.
 	
	ret = BOD.ConvertFromERPItem(				|* API USED
								i.ERPItem,
								bod.item,
 								exception.message,
 								exception.id )
 
	if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(exception.id)
				dal.set.error.message("@"& exception.message(i))
			endfor
			Exception.Delete(exception.id)
			return(DALHOOKERROR)
		endif
	
	|* Create the ItemID/ID XML for the item.
	VAL_RETIFNOK( txbod.dll9002.get.item.id.node(
			ITEM.NODE.ITEM,
			"",			|* Ship-to BP
			"",			|* Sold-to BP
			i.ERPItem,
			"",			|* Item code system
			xml.node,		|* Ref
			xml.node.is.set ))	|* Ref

	if xml.node.is.set(1) then
		|* Put the XML node on the stack if filled.
		RETIFNOK( txbod.dll9002.add.node.to.stack(
				xml.node(1),
				o.ItemMasterHeader_ItemID,		|* Ref
				o.ItemMasterHeader_ItemID.isSet,	|* Ref
				o.ItemMasterHeader_ItemID.size ))	|* Ref
	endif

	|* Select all business partners of the item.		|#LND2-6977.sn
	if txwmd.dll9001.bp.packaging.item.code.exists.for.packaging.item(i.ERPItem) then
		VAL_RETIFNOK(txwmd.dll9001.bp.packaging.item.code.get.data.for.packaging.item(
				i.ERPItem,
				o.number.of.business.partners,
				o.business.partner.array,
				o.bp.packaging.item.code.array,
				o.packaging.classification.array))

		if o.number.of.business.partners > 0 then

			for arr.sequence = 1 to o.number.of.business.partners
				if isspace (o.bp.packaging.item.code.array(1, arr.sequence)) then
					continue
				else
					business.partner = 
						trim$(o.business.partner.array(1, arr.sequence))
					business.partner.item.code = 
						trim$(o.bp.packaging.item.code.array(1, arr.sequence))
			
					|* Records for each master data noun should be present.
					RETIFNOK( handle.business.partner.external.item.codes(
							business.partner,
							business.partner.item.code,
							o.ItemMasterHeader_ItemID,	 |* Ref
							o.ItemMasterHeader_ItemID.isSet, |* Ref
							o.ItemMasterHeader_ItemID.size ))|* Ref
		
				endif
			endfor
		
		endif

	endif							|#LND2-6977.en

	|* Select all business partners of the item.
	select	tcibd004.bpid:business.partner
	from	tcibd004
	where	tcibd004.item = :i.ERPItem
	and	tcibd004.bpid <> ""
	group by tcibd004.bpid
	order by tcibd004.bpid
	selectdo
		|* Do for each unique business partner.
		if o.number.of.business.partners > 0 then	|#LND2-6977.sn	
		    for arr.sequence = 1 to o.number.of.business.partners
			if not isspace (o.bp.packaging.item.code.array(1, arr.sequence)) and
			   business.partner = trim$(o.business.partner.array(1, arr.sequence)) then
				business.partner.packaging = true
				break
			endif
		    endfor
		endif
		
		if not business.partner.packaging then		|#LND2-6977.en
	
			business.partner.item.code = ""
		
			|* Read the default item code system of the business partner.

			dummy.value = txibd.dll9001.default.business.partner.item.code(
					business.partner,
					item.code.system )	
		
			if not isspace( item.code.system ) then
				|* Read the business partner item code for the default
				|* item code system, business partner and item.
							
			dummy.value = txibd.dll9001.tcibd004.read.alternative.item.code(
					i.ERPItem,
					item.code.system,
					business.partner,
					business.partner.item.code )	|* Ref
							
			endif
		
			if not isspace( business.partner.item.code ) then
				VAL_RETIFNOK( handle.business.partner.external.item.codes(
						business.partner,
						business.partner.item.code,
						o.ItemMasterHeader_ItemID,	 |* Ref
						o.ItemMasterHeader_ItemID.isSet, |* Ref
						o.ItemMasterHeader_ItemID.size ))|* Ref
			endif

		endif						
		business.partner.packaging = false		
	endselect

	if o.number.of.business.partners > 0 then		
		free.mem(o.business.partner.array)
		free.mem(o.bp.packaging.item.code.array)
		free.mem(o.packaging.classification.array)
	endif							

	return( 0 )
}
 
function extern long txbod.dll9002.get.item.id.node(
				long		i.item.node.type,
			domain	tccom.bpid	i.ship.to.bp,
			domain	tccom.bpid	i.sold.to.bp,
			domain	tcitem		i.item,
			domain	tccitt		i.item.code.system,
		ref	domain	tcmcs.long	o.xml.node(),
		ref	boolean			o.xml.node.is.set())
{
	DllUsage
	Expl	: This function creates one or more ItemID nodes.

		  <ItemID>
		  	<ID
	  			accountingEntity="aaa"
	  			location="bbb"
	  			lid="ccc">XXX</ID>
		  	<ID
		  		schemeName="Customer"
		  		schemeAgencyID="ddd">YYY</ID>
		  </ItemID>
	Pre	: -
	Post	: -
	Input	: i.item.node.type	- Possible values:
					  ITEM.NODE.ITEM
					  ITEM.NODE.SHIPPINGMATERIAL
					  ITEM.NODE.PACKINGMATERIAL
		  i.ship.to.bp		- Ship To BP
		  i.sold.to.bp		- Sold To BP
		  i.item		- Item
		  i.item.code.system	- Item Code System
	Output	: o.xml.node
		  o.xml.node.is.set
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0033.get.item.id.node
	EndDllUsage

	long	node, ret, i
	domain	tcmcs.str50	bod.item
	domain	tcbod.acen	accounting.entity
	domain	tcbod.lctn	location
	domain	tcbod.loid	lid
	domain	tcaitm		customer.item
	domain	tccom.bpid	customer

	boolean	lid.is.set
	boolean	accounting.entity.is.set
	boolean	location.is.set
	
	domain	tcmcs.s999m	exception.message
	long	exception.id

	set.mem(o.xml.node, 0)
	set.mem(o.xml.node.is.set, false)

	if isspace(i.item) then
		return(0)
	endif

|	RETIFNOK(tcbod.dll0031.convert.from.erp.item(
|					i.item,
|					bod.item))
					
	ret = BOD.ConvertFromERPItem(				|* API USED
								i.item,
								bod.item,
 								exception.message,
 								exception.id )
 
	if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(exception.id)
				dal.set.error.message("@"& exception.message(i))
			endfor
			Exception.Delete(exception.id)
			return(DALHOOKERROR)
		endif

	RETIFNOK(txbod.dll9002.get.id.attributes.by.noun(
					get.compnr(),
					"ItemMasterBOD",
					"",	|i.noun.identifier
					accounting.entity,
					accounting.entity.is.set,
					location,
					location.is.set,
					lid,
					lid.is.set))

	on case i.item.node.type
	case ITEM.NODE.ITEM:
		NEW_NODE("ItemID", 0, o.xml.node(1))

		o.xml.node.is.set(1) = true

		NEW_ELEMENT(	"ID",
				bod.item,
				o.xml.node(1),
				node)

		RETIFNOK(set.attributes(node,
					"ID",
					accounting.entity,
					accounting.entity.is.set,
					location,
					location.is.set,
					lid,
					lid.is.set))

		if not isspace(i.ship.to.bp) then
			get.customer.item(
					i.ship.to.bp,
					i.sold.to.bp,
					i.item,
					i.item.code.system,
					customer,
					customer.item)

			if not isspace(customer.item) then
				NEW_NODE("ItemID", 0, o.xml.node(2))

				o.xml.node.is.set(2) = true

				NEW_ELEMENT_NOT_TRIMMED(
						"ID",
						customer.item,
						o.xml.node(2),
						node)

				NEW_ATTRIBUTE(	node,
						"ID",
						"schemeName",
						SCHEME_NAME_CUSTOMER)

				NEW_ATTRIBUTE(	node,
						"ID",
						"schemeAgencyID",
						customer)

			endif
		endif

		break
	case ITEM.NODE.SHIPPINGMATERIAL:
	case ITEM.NODE.PACKINGMATERIAL:
		NEW_ELEMENT(	"ID",
				bod.item,
				0,
				o.xml.node(1))

		o.xml.node.is.set(1) = true

		RETIFNOK(set.attributes(o.xml.node(1),
					"ID",
					accounting.entity,
					accounting.entity.is.set,
					location,
					location.is.set,
					lid,
					lid.is.set))

		if not isspace(i.ship.to.bp) then
			get.customer.item(
					i.ship.to.bp,
					i.sold.to.bp,
					i.item,
					i.item.code.system,
					customer,
					customer.item)

			if not isspace(customer.item) then

				NEW_ELEMENT_NOT_TRIMMED(
						"ID",
						customer.item,
						0,
						o.xml.node(2))

				o.xml.node.is.set(2) = true

				NEW_ATTRIBUTE(	o.xml.node(2),
						"ID",
						"schemeName",
						SCHEME_NAME_CUSTOMER)

				NEW_ATTRIBUTE(	o.xml.node(2),
						"ID",
						"schemeAgencyID",
						customer)
			endif
		endif

		break
	endcase

	return(0)
}

function extern long txbod.dll9002.get.item.id.node.supplier(
				long		i.item.node.type,
			domain	tccom.bpid	i.ship.from.bp,
			domain	tccom.bpid	i.buy.from.bp,
			domain	tcitem		i.item,
			domain	tccitt		i.item.code.system,
		ref	domain	tcmcs.long	o.xml.node(),
		ref	boolean			o.xml.node.is.set())
{
	DllUsage
	Expl	: This function creates one or more ItemID nodes.

		  <ItemID>
		  	<ID
	  			accountingEntity="aaa"
	  			location="bbb"
	  			lid="ccc">XXX</ID>
		  	<ID
		  		schemeName="Supplier"
		  		schemeAgencyID="ddd">YYY</ID>
		  </ItemID>
	Pre	: -
	Post	: -
	Input	: i.item.node.type	- Possible values:
					  ITEM.NODE.ITEM
		  i.ship.from.bp	- Ship From BP
		  i.buy.from.bp		- Buy From BP
		  i.item		- Item
		  i.item.code.system	- Item Code System
	Output	: o.xml.node
		  o.xml.node.is.set
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll " tcbod.dll0033.get.item.id.node.supplier
	EndDllUsage

	long	node
	long	ret, i

	domain	tcmcs.str50	bod.item
	domain	tcbod.acen	accounting.entity
	domain	tcbod.lctn	location
	domain	tcbod.loid	lid
	domain	tcaitm		supplier.item
	domain	tccom.bpid	supplier
	
	domain	tcmcs.s999m exception.message
	long	exception.id
	

	boolean	lid.is.set
	boolean	accounting.entity.is.set
	boolean	location.is.set

	set.mem(o.xml.node, 0)
	set.mem(o.xml.node.is.set, false)

	if isspace(i.item) then
		return(0)
	endif
	
	ret = BOD.ConvertFromERPItem(				|* API USED
								i.item,
								bod.item,
 								exception.message,
 								exception.id )
 
	if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(exception.id)
				dal.set.error.message("@"& exception.message(i))
			endfor
			Exception.Delete(exception.id)
			return(DALHOOKERROR)
		endif

	RETIFNOK(txbod.dll9002.get.id.attributes.by.noun(
					get.compnr(),
					"ItemMasterBOD",
					"",	|i.noun.identifier
					accounting.entity,
					accounting.entity.is.set,
					location,
					location.is.set,
					lid,
					lid.is.set))

	on case i.item.node.type
	case ITEM.NODE.ITEM:
		NEW_NODE("ItemID", 0, o.xml.node(1))

		o.xml.node.is.set(1) = true

		NEW_ELEMENT(	"ID",
				bod.item,
				o.xml.node(1),
				node)

		RETIFNOK(set.attributes(node,
					"ID",
					accounting.entity,
					accounting.entity.is.set,
					location,
					location.is.set,
					lid,
					lid.is.set))

		if not isspace(i.buy.from.bp) or 
			not isspace(i.ship.from.bp) then
			get.supplier.item(
					i.ship.from.bp,
					i.buy.from.bp,
					i.item,
					i.item.code.system,
					supplier,
					supplier.item)

			if not isspace(supplier.item) then
				NEW_NODE("ItemID", 0, o.xml.node(2))

				o.xml.node.is.set(2) = true

				NEW_ELEMENT_NOT_TRIMMED(
						"ID",
						supplier.item,
						o.xml.node(2),
						node)

				NEW_ATTRIBUTE(	node,
						"ID",
						"schemeName",
						SCHEME_NAME_SUPPLIER)

				NEW_ATTRIBUTE(	node,
						"ID",
						"schemeAgencyID",
						supplier)

			endif
		endif

		break

	endcase

	return(0)
}



function extern long txbod.dll9002.get.id.attributes.by.noun(
		domain	tcncmp		i.company,
		domain	tcbod.name	i.public.noun,
		const	string		i.noun.identifier,
	ref	domain	tcbod.acen	o.accounting.entity,
	ref	boolean			o.accounting.entity.is.set,
	ref	domain	tcbod.lctn	o.location,
	ref	boolean			o.location.is.set,
	ref	domain	tcbod.loid	o.lid,
	ref	boolean			o.lid.is.set)
{
	DllUsage
	Expl	: This function determines the BOD entity type and code.
	Pre	: -
	Post	: -
	Input	: i.company
		  i.public.noun
		  i.noun.identifier
	Output	: o.accounting.entity
		  o.accounting.entity.is.set
		  o.location
		  o.location.is.set
		  o.lid
		  o.lid.is.set
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0041.get.id.attributes.by.noun
	EndDllUsage

		long		dummy.ret

	domain	tdpur.reltype	dummy.release.type

	o.accounting.entity = ""
	o.accounting.entity.is.set = false
	o.location = ""
	o.location.is.set = false
	o.lid = ""
	o.lid.is.set = false

	STORE.MESSAGES

	on case trim$(i.public.noun)
	case "ItemMasterBOD":
		dummy.ret = txbod.dll9002.get.id.attributes.item.master(
					i.company,
					o.accounting.entity,
					o.accounting.entity.is.set,
					o.location,
					o.location.is.set,
					o.lid,
					o.lid.is.set)
		break
	endcase
	
	RESTORE.MESSAGES

	return(0)
}

function extern long txbod.dll9002.get.id.attributes.item.master(
		domain	tcncmp		i.company,
	ref	domain	tcbod.acen	o.accounting.entity,
	ref		boolean		o.accounting.entity.is.set,
	ref	domain	tcbod.lctn	o.location,
	ref		boolean		o.location.is.set,
	ref	domain	tcbod.loid	o.lid,
	ref		boolean		o.lid.is.set )
{
	DLLUsage
	Expl:	The purpose of this function is to read the ID attributes of
		the ItemMaster BOD.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.company
	Output:	o.accounting.entity,
		o.accounting.entity.is.set
		o.location
		o.location.is.set
		o.lid
		o.lid.is.set
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2501.get.id.attributes.item.master
	EndDLLUsage

	domain	tcmcs.tabl	root.table
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID 
	long	ret,i

	o.accounting.entity = ""
	o.accounting.entity.is.set = false
	o.location = ""
	o.location.is.set = false
	o.lid = ""
	o.lid.is.set = false

	RETIFNOK( get.root.table( root.table ))	|* Ref

							|* ValOP2CE_01.so
|	RETIFNOK( tcbod.dll0039.get.id.attributes(	
|			i.company,
|			"ItemMasterBOD",
|			0,				|* Entity type
|			"",				|* Entity code
|			root.table,
|			o.accounting.entity,		|* Ref
|			o.accounting.entity.is.set,	|* Ref
|			o.location,			|* Ref
|			o.location.is.set,		|* Ref
|			o.lid,				|* Ref
|			o.lid.is.set ))			|* Ref
							|* ValOP2CE_01.eo

	
	ret = BOD.GetIdAccountingEntity(		|* API Call
			i.company,							
			"ItemMasterBOD",						
			0,								
			"",				
			root.table,					
			o.accounting.entity,
			o.accounting.entity.is.set,
			o.ExceptionMessage,
			o.ExceptionID )

		if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif
		
		ret = BOD.GetIdLocation(
			i.company,							
			"ItemMasterBOD",						
			0,								
			"",				
			root.table,					
			o.location,	|* oLocation,
			o.location.is.set,	|* oLocationisSet,
			o.ExceptionMessage,
			o.ExceptionID )
	
		if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif
		
		ret = BOD.GetIdLogicalID(
			i.company,							
			"ItemMasterBOD",						
			0,								
			"",				
			root.table,					
			o.lid,
			o.lid.is.set,
			o.ExceptionMessage,
			o.ExceptionID )		

		if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif
		
		
	
	return( 0 )
}

function extern void txbod.dll9002.set.status.updated(boolean	i.value)
{
	DllUsage
	Expl	:
	Input	: i.value - New value of g.tpbod.dll0010.status.updated
	EndDllUsage
	|SourceDLL : tpbod.dll0010.set.status.updated
	
	g.tpbod.dll0010.status.updated = i.value
}

function boolean txbod.dll9002.get.status.updated()
{
	|SourceDLL : tpbod.dll0010.get.status.updated
	return(g.tpbod.dll0010.status.updated)
}
	
function extern long txbod.dll9002.convert.from.erp.period.type.to.iso(
			double		i.duration,
		domain	tctope		i.period.type,
	ref	domain	tcmcs.str25	o.iso.duration,
	ref		boolean		o.iso.duration.is.set)
{
	DllUsage
	Expl:	The purpose of this function is to convert a specified duration
		in a specified period type to a
		ISO duration in the format PnYnMnDTnHnMnS.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.duration
		i.period.type
	Output:	o.iso.duration
		o.iso.duration.is.set				|#1517932.n
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll0031.convert.from.erp.period.type.to.iso
	EndDllUsage

	o.iso.duration = ""
	o.iso.duration.is.set = false

	on case i.period.type
	case tctope.hours:
							|#VAL_ToDo_API
|		RETIFNOK( tcbod.dll0031.convert.from.erp.period.to.iso(
|				0,		|* Years
|				0,		|* Months
|				0.0,		|* Days
|				i.duration,	|* Hours
|				0.0,		|* Minutes
|				0.0,		|* Seconds
|				o.iso.duration,	|* Ref
|				o.iso.duration.is.set))	|* ref
							|#VAL_ToDo_API

		break
	case tctope.days:				|#VAL_ToDo_API
|		RETIFNOK( tcbod.dll0031.convert.from.erp.period.to.iso(
|				0,		|* Years
|				0,		|* Months
|				i.duration,	|* Days
|				0.0,		|* Hours
|				0.0,		|* Minutes
|				0.0,		|* Seconds
|				o.iso.duration,	|* Ref
|				o.iso.duration.is.set))	|* ref
							|#VAL_ToDo_API

		break
	default:
		dal.set.error.message(
			"txbods0040",
			|* txbods0040  ???
			tt.label.desc( "tctcmcs016.ptyp", ttadv.cont.general ),
			|* tctcmcs016.ptyp  ???
			enum.descr$( "tctope", i.period.type ))
			|* tctope  ???

		return( DALHOOKERROR )
	endcase

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemLocation.InboundLeadTimeDuration(
		domain	tcwttm		i.ERPInboundLeadTime,
			boolean		i.ERPInboundLeadTime.isSet,
		domain	tctope		i.ERPInboundLeadTimeUnit,
			boolean		i.ERPInboundLeadTimeUnit.isSet,
	ref	domain	tcmcs.str25	o.InboundLeadTimeDuration,
	ref		boolean		io.InboundLeadTimeDuration.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to return attribute
		'InboundLeadTimeDuration' of the ItemLocation component.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.ERPInboundLeadTime
		i.ERPInboundLeadTime.isSet
		i.ERPInboundLeadTimeUnit
		i.ERPInboundLeadTimeUnit.isSet
	Output:	o.InboundLeadTimeDuration
	In/out:	io.InboundLeadTimeDuration.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemLocation.InboundLeadTimeDuration
	EndDllUsage

	o.InboundLeadTimeDuration = ""
	io.InboundLeadTimeDuration.isSet = false

	if i.ERPInboundLeadTimeUnit <> empty then
		RETIFNOK( txbod.dll9002.convert.from.erp.period.type.to.iso(
				i.ERPInboundLeadTime,
				i.ERPInboundLeadTimeUnit,
				o.InboundLeadTimeDuration,	|* Ref
				io.InboundLeadTimeDuration.isSet ))

	endif

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemLocation.OutboundLeadTimeDuration(
		domain	tcwttm		i.ERPOutboundLeadTime,
			boolean		i.ERPOutboundLeadTime.isSet,
		domain	tctope		i.ERPOutboundLeadTimeUnit,
			boolean		i.ERPOutboundLeadTimeUnit.isSet,
	ref	domain	tcmcs.str25	o.OutboundLeadTimeDuration,
	ref		boolean		io.OutboundLeadTimeDuration.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to return attribute
		'InboundLeadTimeDuration' of the ItemLocation component.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.ERPOutboundLeadTime
		i.ERPOutboundLeadTime.isSet
		i.ERPOutboundLeadTimeUnit
		i.ERPOutboundLeadTimeUnit.isSet
	Output:	o.OutboundLeadTimeDuration
	In/out:	io.OutboundLeadTimeDuration.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemLocation.OutboundLeadTimeDuration
	EndDllUsage

	o.OutboundLeadTimeDuration = ""
	io.OutboundLeadTimeDuration.isSet = false

	if i.ERPOutboundLeadTimeUnit <> empty then
		RETIFNOK( txbod.dll9002.convert.from.erp.period.type.to.iso(
				i.ERPOutboundLeadTime,
				i.ERPOutboundLeadTimeUnit,
				o.OutboundLeadTimeDuration,	|* Ref
				io.OutboundLeadTimeDuration.isSet ))

	endif

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemLocation.ProcurementParameters_OrderCycleDuration(
		domain	tcwttm		i.ERPOrderInterval,
		domain	tctope		i.ERPOrderIntervalUnit,
	ref	domain	tcmcs.str25	o.PP_OrderCycleDuration,
	ref		boolean		io.PP_OrderCycleDuration.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemLocation.ProcurementParameters_OrderCycleDuration
	EndDllusage

	o.PP_OrderCycleDuration = ""
	io.PP_OrderCycleDuration.isSet = false

	if i.ERPOrderIntervalUnit <> empty then
		RETIFNOK( txbod.dll9002.convert.from.erp.period.type.to.iso(
				i.ERPOrderInterval,
				i.ERPOrderIntervalUnit,
				o.PP_OrderCycleDuration,	|* Ref
				io.PP_OrderCycleDuration.isSet ))
	endif

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemLocation.ShelfLifeDuration(
		domain	tcqbia		i.ERPShelfLife,
		domain	tckpsl		i.ERPPeriodForShelfLife,
	ref	domain	tcmcs.str25	o.ShelfLifeDuration,
	ref		boolean		io.ShelfLifeDuration.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemLocation.ShelfLifeDuration
	EndDllusage

	o.ShelfLifeDuration = ""
	io.ShelfLifeDuration.isSet = false

	if i.ERPPeriodForShelfLife <> empty then
		RETIFNOK(
		txbod.dll9002.convert.from.erp.period.shelf.life.to.iso(
			i.ERPShelfLife,
			i.ERPPeriodForShelfLife,
			o.ShelfLifeDuration,		|* Ref
			io.ShelfLifeDuration.isSet ))	|* Ref
	endif

	return( 0 )
}

function extern long txbod.dll9002.convert.from.erp.period.shelf.life.to.iso( |* NOT UNTRUSTED
			long		i.duration,
		domain	tckpsl		i.period.shelf.life,
	ref	domain	tcmcs.str25	o.iso.duration,
	ref		boolean		o.iso.duration.is.set )
{
	DllUsage
	Expl.:	The purpose of this function is to convert a specified duration
		in a specified period shelf life to a ISO duration in the format
		PnYnMnDTnHnMnS.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.duration
		i.period.shelf.life
	Output:	o.iso.duration
		o.iso.duration.is.set
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll0031.convert.from.erp.period.shelf.life.to.iso
	EndDllUsage

	o.iso.duration = ""
	o.iso.duration.is.set = false

	on case i.period.shelf.life
	case tckpsl.year: |* Years
							|* Val_Todo_API.so
|		RETIFNOK( tcbod.dll0031.convert.from.erp.period.to.iso(
|				i.duration,		|* Years
|				0,			|* Months
|				0.0,			|* Days
|				0.0,			|* Hours
|				0.0,			|* Minutes
|				0.0,			|* Seconds
|				o.iso.duration,		|* Ref
|				o.iso.duration.is.set ))|* Ref
							|* Val_Todo_API.eo

		break
	case tckpsl.month: |* Months
							|* Val_Todo_API.so
|		RETIFNOK( tcbod.dll0031.convert.from.erp.period.to.iso(
|				0,			|* Years
|				i.duration,		|* Months
|				0.0,			|* Days
|				0.0,			|* Hours
|				0.0,			|* Minutes
|				0.0,			|* Seconds
|				o.iso.duration,		|* Ref
|				o.iso.duration.is.set ))|* Ref
							|* Val_Todo_API.eo

		break
	case tckpsl.day: |* Days
							|* Val_Todo_API.so
|		RETIFNOK( tcbod.dll0031.convert.from.erp.period.to.iso(
|				0,			|* Years
|				0,			|* Months
|				i.duration * 1.0,	|* Days
|				0.0,			|* Hours
|				0.0,			|* Minutes
|				0.0,			|* Seconds
|				o.iso.duration,		|* Ref
|				o.iso.duration.is.set ))|* Ref
							|* Val_Todo_API.eo

		break
	case tckpsl.none: |* Not Applicable
		|* Do not publish and no error message.

		break
	default:
		dal.set.error.message(
			"txbods0040",
			|* txbods0040  ???
			tt.label.desc( "tcwhwmd400.npsl", ttadv.cont.general ),
			|* tcwhwmd400.npsl  ???
			enum.descr$(
				domainof( i.period.shelf.life ),
				i.period.shelf.life ))
		|* %1$s '%2$s' is not supported.

		return( DALHOOKERROR )
	endcase

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemLocation_PP_DefaultSource_SupplierParty_PartyIDs_ID(
		domain	tccom.bpid		i.buy.from.bp,
		domain	tcmcs.str25		i.procurement.methode.code,
	ref		long			o.supplier.party.id,
	ref		boolean			io.supplier.party.id.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemLocation_PP_DefaultSource_SupplierParty_PartyIDs_ID
	EndDllUsage

		domain 	tcmcs.str25	l.noun.identifier

	io.supplier.party.id.isSet = false

	on case i.procurement.methode.code
	case PROCUREMENT_PURCHASE:

		RETIFNOK( txbod.dll9002.convert.from.erp.business.partner(
				BUY_FROM,
				i.buy.from.bp,
				"",	|* Department
				l.noun.identifier ) )	|* Ref
				
|							|* Val_Todo_API.so
|		RETIFNOK(tcbod.dll0033.get.id.reference.node(
|				get.compnr(),
|				"SupplierPartyMasterBOD",
|				l.noun.identifier,
|				o.supplier.party.id,
|				io.supplier.party.id.isSet))
							|* Val_Todo_API.eo

		break
	endcase

	return(0)
}

function extern long txbod.dll9002.publish.project.master_API(
			domain	tccprj		i.project,
			domain	tcmcs.str10	i.action.code)
{
	DllUsage
	Expl:	This function publishes the ProjectMaster BOD.
	Pre:	N.A.
	Post:	N.A.
	Input:	i.project	-> Project
		i.action.code	-> Action Code
	Output:	N.A.
	Return: 0 / DALHOOKERROR
	Old Dll : tcbod.dll0005.publish.project.master
	EndDllUsage
	
	long ret,i
	domain tcmcs.s999m o.ExceptionMessage
	long o.ExceptionID

	ret =  BOD.Publish(
				"ProjectMasterTPBOD",		|* iNoun
				"tppdm600",			|* iRootTable
				i.action.code,			|* iActionCode,
				0,				|* iEntityType,
				"",				|* iEntityCode,
				i.project,			|* iDocumentId,
				VAL_PROC_STAGE_OR_PUBLISH,	|* iProcessingAction,
				o.ExceptionMessage,
				o.ExceptionID
				)
			 		
		if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif
		
		return(0)
}	


function extern long txbod.dll9002.Hook.OnGet.ItemLocation_ProcurementParameters_DefaultSource_ProductionLocation_ID(
		domain	tcitem		i.item,
		domain	tcmcs.str25	i.procurement.method.code,
	ref		long		o.production.location.id,
	ref		boolean		io.production.location.id.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.hook.onget.itemlocation_procurementparameters_defaultsource_productionlocation_id
	EndDllusage

		domain 	tcmcs.str25	l.noun.identifier
		domain	tccwoc		l.production.location
			long		l.dummy.retval

	io.production.location.id.isSet = false
	o.production.location.id = 0				|#1947758.n
	l.production.location = ""				|#1947758.n


	on case i.procurement.method.code
	case PROCUREMENT_MANUFACTURE:
		if txipd.dll9001.item.has.routing( i.item ) then

			STOP.MESSAGES				|#1897342.n

			l.dummy.retval = txrou.dll9001.retrieve.workcenter.of.default.routing(
					0.0,
					i.item,
					0,
					l.production.location ) |* Ref

			START.MESSAGES				|#1897342.n

			if not isspace(l.production.location) then|#1897342.n
				RETIFNOK(txbod.dll9002.compose.location.identifier(
					LOCATION_TYPE_OFFICE,
					l.production.location,
					l.noun.identifier))	|* Ref
					
|							|* Val_Todo_API.so
|				RETIFNOK(tcbod.dll0033.get.id.reference.node(
|					get.compnr(),
|					"LocationBOD",
|					l.noun.identifier,
|					o.production.location.id,
|					io.production.location.id.isSet))
|							|* Val_Todo_API.eo
			endif					
		endif

		break
	endcase

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemLocation_ProcurementParameters_DefaultSource_WarehouseLocation_ID(
		domain	tcitem		i.item,
		domain	tcmcs.str25	i.procurement.method.code,
	ref		long		o.warehouse.id,
	ref		boolean		io.warehouse.id.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemLocation_ProcurementParameters_DefaultSource_WarehouseLocation_ID
	EndDllusage

		domain 	tcmcs.str25	l.noun.identifier
		domain	tccwar		l.default.warehouse
			long		l.dummy.retval

	io.warehouse.id.isSet = false
	o.warehouse.id = 0					|#1947758.n
	l.default.warehouse = ""					|#1947758.n

|	STOP.MESSAGES						|#1897342.o

	on case i.procurement.method.code
	case PROCUREMENT_TRANSFER:

		STOP.MESSAGES					|#1897342.n

		|* This function retrives the plan item's default warehouse.
		l.dummy.retval = get.default.warehouse.BOD(
				i.item,
				"",
				l.default.warehouse )	|* Ref

		START.MESSAGES					|#1897342.n

		if not isspace(l.default.warehouse) then		|#1897342.n
			RETIFNOK( txbod.dll9002.compose.location.identifier(
				LOCATION_TYPE_WAREHOUSE,
				l.default.warehouse,
				l.noun.identifier ))	
				
|							|* Val_Todo_API.so
|			RETIFNOK(tcbod.dll0033.get.id.reference.node(
|				get.compnr(),
|				"LocationBOD",
|				l.noun.identifier,
|				o.warehouse.id,
|				io.warehouse.id.isSet))
|							|* Val_Todo_API.eo
		endif								
		break
	endcase

	return( 0 )
}
			
function extern long txbod.dll9002.Hook.OnGet.ItemLocation_ProcurementParameters_DefaultSource_WorkCenterReference_ID(
		domain	tcitem		i.item,
		domain	tcmcs.str25	i.procurement.method.code,
	ref	domain	tcdsca		o.workcenter.description,
	ref		long		o.workcenter.id,
	ref		boolean		io.workcenter.id.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemLocation_ProcurementParameters_DefaultSource_WorkCenterReference_ID
	EndDllusage

		domain 	tcmcs.str25	l.noun.identifier
		domain	tccwoc		l.workcenter
			long		l.dummy.retval

	io.workcenter.id.isSet = false
	o.workcenter.id = 0					|#1947758.n
	o.workcenter.description = ""				|#1947758.n
	l.workcenter = ""						|#1947758.n

|	STOP.MESSAGES						|#1897342.o

	on case i.procurement.method.code
	case PROCUREMENT_MANUFACTURE:
		if txrou.dll9001.item.has.routing( i.item ) then

			STOP.MESSAGES				|#1897342.n

			l.dummy.retval = txrou.dll9001.retrieve.workcenter.of.default.routing(
					0.0,
					i.item,
					0,
					l.workcenter ) |* Ref

			START.MESSAGES				|#1897342.n

			if not isspace(l.workcenter) then		|#1897342.n
				RETIFNOK(get.work.center.description(
	  				l.workcenter,
					o.workcenter.description))
					
|							|* Val_Todo_API.so
|				RETIFNOK(tcbod.dll0033.get.id.reference.node(
|					get.compnr(),
|					"LocationBOD",
|					l.noun.identifier,
|					o.workcenter.id,
|					io.workcenter.id.isSet))
|							|* Val_Todo_API.eo
			endif					
		endif

		break
	endcase

|	START.MESSAGES						|#1897342.o

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ItemPlanning_PlanningTimeFence(
		domain	tcwttm		i.ERPTimeFence,
			boolean		i.ERPTimeFence.isSet,
		domain	tctope		i.ERPTimeFenceUnit,
			boolean		i.ERPTimeFenceUnit.isSet,
	ref	domain	tcmcs.str25	o.ItemMasterHeader_ItemPlanning_PlanningTimeFence,
	ref		boolean		io.ItemMasterHeader_ItemPlanning_PlanningTimeFence.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to return attribute
		ItemPlanning_PlanningTimeFence of the main component.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.ERPTimeFence
		i.ERPTimeFence.isSet
		i.ERPTimeFenceUnit
		i.ERPTimeFenceUnit.isSet
	Output:	o.ItemMasterHeader_ItemPlanning_PlanningTimeFence
	In/out:	io.ItemMasterHeader_ItemPlanning_PlanningTimeFence.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.hook.onget.itemmastercommonbod.itemmasterheader_itemplanning_planningtimefence
	EndDllUsage

	o.ItemMasterHeader_ItemPlanning_PlanningTimeFence = ""
	io.ItemMasterHeader_ItemPlanning_PlanningTimeFence.isSet = false

	if i.ERPTimeFenceUnit <> empty then
		RETIFNOK( txbod.dll9002.convert.from.erp.period.type.to.iso(
				i.ERPTimeFence,
				i.ERPTimeFenceUnit,
				o.ItemMasterHeader_ItemPlanning_PlanningTimeFence,|* Ref
				io.ItemMasterHeader_ItemPlanning_PlanningTimeFence.isSet ))
	endif

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_LeadTimeDuration(
		domain	tcwttm		i.ERPOrderLeadTime,
		domain	tctope		i.ERPOrderLeadTimeUnit,
	ref	domain	tcmcs.str25	o.ItemMasterHeader_LeadTimeDuration,
	ref		boolean		io.ItemMasterHeader_LeadTimeDuration.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_LeadTimeDuration
	EndDllusage

	o.ItemMasterHeader_LeadTimeDuration = ""
	io.ItemMasterHeader_LeadTimeDuration.isSet = false

	if i.ERPOrderLeadTimeUnit <> empty then
		RETIFNOK( txbod.dll9002.convert.from.erp.period.type.to.iso(
				i.ERPOrderLeadTime,
				i.ERPOrderLeadTimeUnit,
				o.ItemMasterHeader_LeadTimeDuration,	|* Ref
				io.ItemMasterHeader_LeadTimeDuration.isSet ))
	endif

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_OrderCycleDuration(
		domain	tcwttm		i.ERPOrderInterval,
		domain	tctope		i.ERPOrderIntervalUnit,
	ref	domain	tcmcs.str25	o.ItemMasterHeader_ProcurementParameters_OrderCycleDuration,
	ref		boolean		io.ItemMasterHeader_ProcurementParameters_OrderCycleDuration.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ProcurementParameters_OrderCycleDuration
	EndDllusage

	o.ItemMasterHeader_ProcurementParameters_OrderCycleDuration = ""
	io.ItemMasterHeader_ProcurementParameters_OrderCycleDuration.isSet = false

	if i.ERPOrderIntervalUnit <> empty then
		RETIFNOK( txbod.dll9002.convert.from.erp.period.type.to.iso(
				i.ERPOrderInterval,
				i.ERPOrderIntervalUnit,
				o.ItemMasterHeader_ProcurementParameters_OrderCycleDuration,	|* Ref
				io.ItemMasterHeader_ProcurementParameters_OrderCycleDuration.isSet ))
	endif

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ShelfLifeDuration(
		domain	tcqbia		i.ERPShelfLife,
		domain	tckpsl		i.ERPPeriodForShelfLife,
	ref	domain	tcmcs.str25	o.ItemMasterHeader_ShelfLifeDuration,
	ref		boolean		io.ItemMasterHeader_ShelfLifeDuration.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemMasterCommonBOD.ItemMasterHeader_ShelfLifeDuration
	EndDllusage

	o.ItemMasterHeader_ShelfLifeDuration = ""
	io.ItemMasterHeader_ShelfLifeDuration.isSet = false

	if i.ERPPeriodForShelfLife <> empty then
		RETIFNOK(
		txbod.dll9002.convert.from.erp.period.shelf.life.to.iso(
			i.ERPShelfLife,
			i.ERPPeriodForShelfLife,
			o.ItemMasterHeader_ShelfLifeDuration,		|* Ref
			io.ItemMasterHeader_ShelfLifeDuration.isSet ))	|* Ref
	endif

	return( 0 )
}

function extern long txbod.dll9002.hook.onexecute.itemlocation.show(
	ref	domain	tcitem		io.ERPItem,				|*tcibd001
	ref		boolean		io.ERPItem.isSet,
	ref	domain	tcncmp		o.ERPLocation,
	ref		boolean		o.ERPLocation.isSet,
	ref	domain	tccwar		o.ERPWarehouseLocation,			|*whwmd210
	ref		boolean		o.ERPWarehouseLocation.isSet,
	ref	domain	tcdsca		o.WarehouseLocation_Name,
	ref		boolean		o.WarehouseLocation_Name.isSet,
	ref	domain	tcomth		o.PP_OrderMethod,
	ref		boolean		o.PP_OrderMethod.isSet,
	ref	domain	tcqiv2		o.PP_OrderIncrementQuantity,
	ref		boolean		o.PP_OrderIncrementQuantity.isSet,
	ref	domain	tcqiv2		o.PP_FixedOrderQuantity,
	ref		boolean		o.PP_FixedOrderQuantity.isSet,
	ref	domain	tcqiv2		o.PP_MinOrderQuantity,
	ref		boolean		o.PP_MinOrderQuantity.isSet,
	ref	domain	tcqiv2		o.PP_MaxOrderQuantity,
	ref		boolean		o.PP_MaxOrderQuantity.isSet,
	ref	domain	tcqiv2		o.PP_OrderPointQuantity,
	ref		boolean		o.PP_OrderPointQuantity.isSet,
	ref	domain	tcqiv2		o.PP_MaxQuantity,
	ref		boolean		o.PP_MaxQuantity.isSet,
	ref	domain	tcqiv2		o.PP_SafetyStockQuantity,
	ref		boolean		o.PP_SafetyStockQuantity.isSet,
	ref	domain	tcqiv2		o.PP_EOQQuantity,
	ref		boolean		o.PP_EOQQuantity.isSet,
	ref	domain	tcpric		o.StockCarryingCost_Amount,
	ref		boolean		o.StockCarryingCost_Amount.isSet,
	ref	domain	tcwttm		o.ERPInboundLeadTime,
	ref		boolean		o.ERPInboundLeadTime.isSet,
	ref	domain	tctope		o.ERPInboundLeadTimeUnit,
	ref		boolean		o.ERPInboundLeadTimeUnit.isSet,
	ref	domain	tcwttm		o.ERPOutboundLeadTime,
	ref		boolean		o.ERPOutboundLeadTime.isSet,
	ref	domain	tctope		o.ERPOutboundLeadTimeUnit,
	ref		boolean		o.ERPOutboundLeadTimeUnit.isSet,
	ref	domain	tcyesno		o.ERPUseItemOrderingData,
	ref		boolean		o.ERPUseItemOrderingData.isSet,
	ref	domain	tcleng		o.ERPDepth,
	ref		boolean		o.ERPDepth.isSet,
	ref	domain	tcleng		o.ERPHeight,
	ref		boolean		o.ERPHeight.isSet,
	ref	domain	tcleng		o.ERPWidth,
	ref		boolean		o.ERPWidth.isSet,
	ref	domain	tcyesno		o.ERPHazardousMaterial,
	ref		boolean		o.ERPHazardousMaterial.isSet,
	ref	domain	whwmd.risk	o.ERPClassofRisk,
	ref		boolean		o.ERPClassofRisk.isSet,
	ref	domain	tcqbia		o.ERPShelfLife,
	ref		boolean		o.ERPShelfLife.isSet,
	ref	domain	tckpsl		o.ERPPeriodForShelfLife,
	ref		boolean		o.ERPPeriodForShelfLife.isSet,
	ref	domain	tccwar		o.ERPDefaultWarehouseLocation,
	ref		boolean		o.ERPDefaultWarehouseLocation.isSet,
	ref	domain	tcdate		o.PP_EffectiveTimePeriod_StartDateTime,
	ref		boolean		o.PP_EffectiveTimePeriod_StartDateTime.isSet,
	ref	domain	tcdate		o.PP_EffectiveTimePeriod_EndDateTime,
	ref		boolean		o.PP_EffectiveTimePeriod_EndDateTime.isSet,
	ref	domain	tcosys		o.PP_PlanningMethod,
	ref		boolean		o.PP_PlanningMethod.isSet,
	ref	domain	tcwttm		o.ERPOrderInterval,
	ref		boolean		o.ERPOrderInterval.isSet,
	ref	domain	tctope		o.ERPOrderIntervalUnit,
	ref		boolean		o.ERPOrderIntervalUnit.isSet,
	ref	domain 	tcyesno		o.BackFlushedIndicator,
	ref		boolean		o.BackFlushedIndicator.isSet,
	ref	domain 	tcyesno		o.PhantomIndicator,
	ref		boolean		o.PhantomIndicator.isSet,
	ref	domain	tcwttm		o.ERPOrderLeadTime,
	ref		boolean		o.ERPOrderLeadTime.isSet,
	ref	domain	tctope		o.ERPOrderLeadTimeUnit,
	ref		boolean		o.ERPOrderLeadTimeUnit.isSet,
	ref	domain	tcccur		o.ERPCurrency,
	ref		boolean		o.ERPCurrency.isSet,
	ref	domain	tccopr		o.ERPEstimatedCostprice,
	ref		boolean		o.ERPEstimatedCostprice.isSet,
	ref	domain	fmfmd.frcl	o.ERPFreightClass,
	ref		boolean		o.ERPFreightClass.isSet,
	ref	domain	tccom.bpid	o.ERPBuyFromBusinessPartner,
	ref		boolean		o.ERPBuyFromBusinessPartner.isSet,
	ref	domain	tcwttm		o.ERPSupplyTime,
	ref		boolean		o.ERPSupplyTime.isSet,
	ref	domain	tctope		o.ERPUnitforSupplyTime,
	ref		boolean		o.ERPUnitforSupplyTime.isSet,
	ref	domain	tcitem		o.ERPPlanningDataItem,			|*cprpd100
	ref		boolean		o.ERPPlanningDataItem.isSet,
	ref	domain	cprpd.plit	o.IT_PlanItemType,
	ref		boolean		o.IT_PlanItemType.isSet,
	ref	domain	cpitem		o.ERPPlanItem,
	ref		boolean		o.ERPPlanItem.isSet,
	ref	domain	cpcom.plvl	o.ERPPlanLevel,
	ref		boolean		o.ERPPlanLevel.isSet,
	ref	domain	tcwttm		o.ERPTimeFence,
	ref		boolean		o.ERPTimeFence.isSet,
	ref	domain	tctope		o.ERPTimeFenceUnit,
	ref		boolean		o.ERPTimeFenceUnit.isSet,
	ref	domain	tcemno		o.ERPPlanner,			
	ref		boolean		o.ERPPlanner.isSet,		
	ref	domain	tcitem		o.ERPWarehousingDataItem,
	ref	domain	tcitem		o.ERPSalesDataItem,
	ref	domain	tcitem		o.ERPProductionDataItem,
	ref	domain	tcitem		o.ERPPurchaseDataItem,
	ref	domain	tcdsca		o.PackagingUnit_Name,			|*tcmcs001
	ref		boolean		o.PackagingUnit_Name.isSet,
	ref	domain	tcmcs.long	o.Classification,
	ref		boolean		o.Classification.isSet,
	ref	domain	tcmcs.long	o.UserArea,
	ref		boolean		o.UserArea.isSet,
	ref		boolean		o.anythingFetched)
{
	DllUsage
	Old Dll : tcbod.dll2505.hook.onexecute.itemlocation.show
	EndDllUsage

	static		long		hold.status
	static		long		sql.lines
	static		long		arr.seq
	static		boolean		first.time.read		
			long		no.of.companies
			long		return.value		
	static	domain	tcncmp		current.company		
	static	domain	tcncmp		shared.comp(1) based		
		domain	tcncmp		unsorted.shared.comp(1) based 	
	 	domain	tcabcc		ABC.code
		domain	tdcms.cmgp	sales.rebate.group
		domain	tckitm		item.type
		domain 	tccitg		item.group
		domain	tccprj		item.project
		domain	tcopol		order.policy
		domain	tcmcs.rgrp	routing.group
		domain	tcitem		control.code.material
		domain	tcitem		costing.data.item
		domain	tcitem		project.data.item
		domain	tcitem		quality.data.item
		domain	tcitem		ordering.data.item
		domain	tcitem		freight.data.item		
		domain	tcitem		service.data.item
		domain	tccuni		inventory.unit		
		domain	tccuni		sales.price.unit
		domain	tcpric		sales.price
		domain	tcsftm		safety.time
		domain	tctope		safety.time.unit
		domain	tcprct		service.level		
		domain	tcyesno		itemmaster.shared.company.parameter	
			long		t.ret.val
			string		item.master$(5)		
		static	boolean		s.location.producible.indicator	
		static	boolean		s.location.purchasable.indicator
		static	boolean		s.location.sellable.indicator
		static	boolean		s.location.stockable.indicator	
			boolean		l.update.producible.indicator
			boolean		l.update.purchasable.indicator
			boolean		l.update.sellable.indicator
			boolean		l.update.stockable.indicator	
								
	#define INIT_VARIABLES_ITEMLOCATION_SHOW
^		free.mem(shared.comp)
^		free.mem(unsorted.shared.comp)

	#define ERROR_HOOK_ON_EXECUTE_ITEMLOCATION_SHOW( i_RETURN_VALUE )
^		if i_RETURN_VALUE <> 0 then
^			INIT_VARIABLES_ITEMLOCATION_SHOW
^			return( i_RETURN_VALUE )
^		endif
								

	|* Free allocated memory.
	free.mem(unsorted.shared.comp)			

	o.ERPWarehouseLocation = ""
	o.UserArea = 0
	o.UserArea.isSet = false
	o.anythingFetched = false

	o.ERPWarehouseLocation.isSet = false		|*whwmd210
	o.WarehouseLocation_Name.isSet = false
	o.PP_OrderMethod.isSet = false
	o.PP_OrderIncrementQuantity.isSet = false
	o.PP_FixedOrderQuantity.isSet = false
	o.PP_MinOrderQuantity.isSet = false
	o.PP_MaxOrderQuantity.isSet = false
	o.PP_OrderPointQuantity.isSet = false
	o.PP_MaxQuantity.isSet = false
	o.PP_SafetyStockQuantity.isSet = false
	o.PP_EOQQuantity.isSet = false
	o.StockCarryingCost_Amount.isSet = false
	o.ERPInboundLeadTime.isSet = false
	o.ERPInboundLeadTimeUnit.isSet = false
	o.ERPOutboundLeadTime.isSet = false
	o.ERPOutboundLeadTimeUnit.isSet = false
	o.ERPUseItemOrderingData.isSet = false
	o.ERPLocation.isSet = false
	o.ERPDepth.isSet = false
	o.ERPHeight.isSet = false
	o.ERPWidth.isSet = false
	o.ERPHazardousMaterial.isSet = false
	o.ERPClassofRisk.isSet = false
	o.ERPShelfLife.isSet = false
	o.ERPPeriodForShelfLife.isSet = false
	o.ERPDefaultWarehouseLocation.isSet = false
	o.PP_EffectiveTimePeriod_StartDateTime.isSet = false
	o.PP_EffectiveTimePeriod_EndDateTime.isSet = false
	o.PP_PlanningMethod.isSet = false
	o.ERPOrderInterval.isSet = false
	o.ERPOrderIntervalUnit.isSet = false
								|*tiipd001
	o.BackFlushedIndicator.isSet = false
	o.PhantomIndicator.isSet = false
	o.ERPOrderLeadTime.isSet = false
	o.ERPOrderLeadTimeUnit.isSet = false
								|*ticpr007
	o.ERPCurrency.isSet = false
	o.ERPEstimatedCostprice.isSet = false
	o.ERPFreightClass.isSet = false
	o.ERPBuyFromBusinessPartner.isSet = false
	o.ERPSupplyTime.isSet = false
	o.ERPUnitforSupplyTime.isSet = false
	o.ERPPlanningDataItem.isSet = false			|*cprpd100
	o.IT_PlanItemType.isSet = false
	o.ERPPlanItem.isSet = false
	o.ERPPlanLevel.isSet = false
	o.ERPTimeFence.isSet = false
	o.ERPTimeFenceUnit.isSet = false
	o.ERPPlanner.isSet = false			
	o.PackagingUnit_Name.isSet = false			|*tcmcs001

	l.update.producible.indicator = false			
	l.update.purchasable.indicator = false
	l.update.sellable.indicator = false
	l.update.stockable.indicator = false			
								
							
	|** It will read the BODParamater value for OneTime whether to publish
	|** the SharedCompany Data or not and it will form the Shared Companies 
	|**array only once for BOD Paramater yes and No
	if not first.time.read then
		itemmaster.shared.company.parameter = tcyesno.no
		current.company = get.compnr()
		inc(arr.seq)
		item.master$ = txmcs.dll9001.get.tcmcs095.str.parameter(
				"BOD",
				0,
				505,
				"imsc")
		if trim$(item.master$) = "true" then
			itemmaster.shared.company.parameter = tcyesno.yes
		endif
		if itemmaster.shared.company.parameter = tcyesno.yes then
			if arr.seq = 1 then
				
				return.value = txcom.dll9001.get.shared.company.relation(
					current.company,
					"tcibd001",
					no.of.companies,
					unsorted.shared.comp) 

				ERROR_HOOK_ON_EXECUTE_ITEMLOCATION_SHOW( 
								return.value )

				|* the last company must be the current company
				return.value = order.companies.in.array(
						no.of.companies,
						current.company,
						unsorted.shared.comp,
						shared.comp)

				ERROR_HOOK_ON_EXECUTE_ITEMLOCATION_SHOW( 
								return.value )
			endif
	      else
			|* Swith back to current company if the BODParameter
			|** is set to "NO"
			RETIFNOK(txcom.dll9001.switch.to.company(current.company))
			
			no.of.companies = 1
			t.ret.val = alloc.mem(unsorted.shared.comp,
	     				no.of.companies)
			     
			unsorted.shared.comp(no.of.companies) = current.company
		
		
			|* the last company must be the current company
			return.value = order.companies.in.array(
					no.of.companies,
					current.company,
					unsorted.shared.comp,
					shared.comp)

			ERROR_HOOK_ON_EXECUTE_ITEMLOCATION_SHOW( return.value )
		endif			
		|**Set the variable to true to read the BODParamater and form 
		|**the Shared Array only once.
		first.time.read = true
	endif		
																												
	|**IF condition to publish the data for the physical and logical company.																											
	if arr.seq <= no.of.companies then			
		|* Swith to not shared company.
		RETIFNOK.SWITCH.COMP(
				current.company,
				txcom.dll9001.switch.to.company(shared.comp(arr.seq)))
								|#1994725.en
	if hold.status = 0 then
		if sql.lines = 0 then
			sql.lines = sql.parse(
			"select	 whwmd210.cwar:1, " &
				"whwmd210.omth:2, " &
				"whwmd210.oqmf:3, " &
				"whwmd210.fioq:4, " &
				"whwmd210.mioq:5, " &
				"whwmd210.maoq:6, " &
				"whwmd210.reop:7, " &
				"whwmd210.maxs:8, " &
				"whwmd210.sfst:9, " &
				"whwmd210.ecoq:10, " &
				"whwmd210.scst:11, " &
				"whwmd210.abcc:12, " &
				"whwmd210.iltm:13, " &
				"whwmd210.iltu:14, " &
				"whwmd210.oltm:15, " &
				"whwmd210.oltu:16, " &			
				"whwmd210.uidt:17, " &
				"whwmd210.serv:18, " &		
				"whwmd210.sftm:20, " &		
				"whwmd210.sftu:21, " &		
				"tcmcs003.dsca:19  " &
			"from	whwmd210 " &
				"left outer join tcibd001 on whwmd210.item=tcibd001.item " &
				"left outer join tcmcs003 on whwmd210.cwar=tcmcs003.cwar " &
			"where	whwmd210._index2 = {:1} " &
			"and	whwmd210.iwhs = whwmd.iwhs.active ")

			sql.select.bind(sql.lines,   1,  o.ERPWarehouseLocation)
			sql.select.bind(sql.lines,   2,  o.PP_OrderMethod)
			sql.select.bind(sql.lines,   3,  o.PP_OrderIncrementQuantity)
			sql.select.bind(sql.lines,   4,  o.PP_FixedOrderQuantity)
			sql.select.bind(sql.lines,   5,  o.PP_MinOrderQuantity)
			sql.select.bind(sql.lines,   6,  o.PP_MaxOrderQuantity)
			sql.select.bind(sql.lines,   7,  o.PP_OrderPointQuantity)
			sql.select.bind(sql.lines,   8,  o.PP_MaxQuantity)
			sql.select.bind(sql.lines,   9,  o.PP_SafetyStockQuantity)
			sql.select.bind(sql.lines,  10,  o.PP_EOQQuantity)
			sql.select.bind(sql.lines,  11,  o.StockCarryingCost_Amount)
			sql.select.bind(sql.lines,  12,  ABC.code)
			sql.select.bind(sql.lines,  13,  o.ERPInboundLeadTime)
			sql.select.bind(sql.lines,  14,  o.ERPInboundLeadTimeUnit)
			sql.select.bind(sql.lines,  15,  o.ERPOutboundLeadTime)
			sql.select.bind(sql.lines,  16,  o.ERPOutboundLeadTimeUnit)
			sql.select.bind(sql.lines,  17,  o.ERPUseItemOrderingData)
			sql.select.bind(sql.lines,  18,  service.level)			
			sql.select.bind(sql.lines,  20,  safety.time)			
			sql.select.bind(sql.lines,  21,  safety.time.unit)		
			sql.select.bind(sql.lines,  19,  o.WarehouseLocation_Name)

			sql.where.bind(sql.lines,    1,  io.ERPItem)

			if sql.exec(sql.lines) <> 0 then
				sql.close(sql.lines)
				sql.lines = 0
				dal.set.error.message(	"tcbods0102",
				|* tcbods0102  ???
					trim$(io.ERPItem))
				|* Dynamic SQL-query for ID %1$s cannot be executed.
				return(DALHOOKERROR)
			endif
		endif

		on case sql.fetch(sql.lines)
		case ENOREC:
		case EENDFILE:
			sql.close(sql.lines)
			sql.lines = 0
								
			if itemmaster.shared.company.parameter = tcyesno.yes then
				hold.status = 1
			endif					
			break
		default:
			o.ERPWarehouseLocation.isSet = true		|*whwmd210
			o.WarehouseLocation_Name.isSet = true
			
			if itemmaster.shared.company.parameter = tcyesno.yes then
				o.ERPLocation =	shared.comp(arr.seq)
				o.ERPLocation.isSet = true
			endif					
			|* Publish attribute if fields 'Use Item Ordering Data' 
			|* (whwmd210.uidt) is set to 'No'.
			if o.ERPUseItemOrderingData = tcyesno.no then
				o.PP_OrderMethod.isSet = true
				o.PP_OrderIncrementQuantity.isSet = true
				o.PP_FixedOrderQuantity.isSet = true
				o.PP_MinOrderQuantity.isSet = true
				o.PP_MaxOrderQuantity.isSet = true
				o.PP_OrderPointQuantity.isSet = true
				o.PP_MaxQuantity.isSet = true
				o.PP_SafetyStockQuantity.isSet = true
				o.PP_EOQQuantity.isSet = true
			endif
			o.StockCarryingCost_Amount.isSet = true
			o.ERPInboundLeadTime.isSet = true
			o.ERPInboundLeadTimeUnit.isSet = true
			o.ERPOutboundLeadTime.isSet = true
			o.ERPOutboundLeadTimeUnit.isSet = true
			o.ERPUseItemOrderingData.isSet = true
								
			RETIFNOK(set.item.location.warehouse.user.area.properties(
					safety.time,
					safety.time.unit,
					service.level,	
					o.UserArea,
					o.UserArea.isSet ))
								
		|#Define a new macro,if any Error occurs ,switches back to the  |#1994725.sn
		|#Original Company								
		
		RETIFNOK.DYN.SQL.COMP(current.company,sql.lines, 
				txbod.dll9002.get.custom.fields(
				"ItemMasterCommonBOD",
				"ItemLocation",
				"whwmd210.cwar", o.ERPWarehouseLocation,
				"whwmd210.item", io.ERPItem,
				"tcmcs003.cwar", o.ERPWarehouseLocation,
				"tcibd001.item", io.ERPItem,
				o.UserArea,		|* Ref
				o.UserArea.isSet ))	|* Ref				

			o.anythingFetched = true

			break
		endcase
	endif


		if hold.status = 1 then				

			select	tcibd001.kitm:item.type,			|* tcibd001
				tcibd001.citg:item.group,
				tcibd001.cprj:item.project,
				tcibd001.cuni:inventory.unit,		
				whwmd400.item:o.ERPWarehousingDataItem,		|* whwmd400
				whwmd400.abcc:ABC.code,
				whwmd400.dpth:o.ERPDepth,
				whwmd400.hght:o.ERPHeight,
				whwmd400.wdth:o.ERPWidth,
				whwmd400.hama:o.ERPHazardousMaterial,
				whwmd400.npsl:o.ERPShelfLife,
				whwmd400.kpsl:o.ERPPeriodForShelfLife,
				whwmd400.risk:o.ERPClassofRisk,
				tdisa001.item:o.ERPSalesDataItem,		|* tdisa001
				tdisa001.rbgp:sales.rebate.group,
				tdisa001.pris:sales.price,		
				tdisa001.cups:sales.price.unit,		
				tcibd200.item:ordering.data.item,		|* tcibd200
				tcibd200.cwar:o.ERPDefaultWarehouseLocation,
				tcibd200.fodt:o.PP_EffectiveTimePeriod_StartDateTime,
				tcibd200.lodt:o.PP_EffectiveTimePeriod_EndDateTime,
				tcibd200.ecoq:o.PP_EOQQuantity,
				tcibd200.fioq:o.PP_FixedOrderQuantity,
				tcibd200.maxs:o.PP_MaxQuantity,
				tcibd200.maoq:o.PP_MaxOrderQuantity,
				tcibd200.mioq:o.PP_MinOrderQuantity,
				tcibd200.omth:o.PP_OrderMethod,
				tcibd200.oqmf:o.PP_OrderIncrementQuantity,
				tcibd200.osys:o.PP_PlanningMethod,
				tcibd200.reop:o.PP_OrderPointQuantity,
				tcibd200.sfst:o.PP_SafetyStockQuantity,
				tcibd200.rgrp:routing.group,
				tcibd200.opol:order.policy,
				tcibd200.oint:o.ERPOrderInterval,
				tcibd200.oivu:o.ERPOrderIntervalUnit,
				tiipd001.item:o.ERPProductionDataItem,		|* tiipd001
				tiipd001.bfep:o.BackFlushedIndicator,
				tiipd001.cpha:o.PhantomIndicator,
				tiipd001.oltm:o.ERPOrderLeadTime,
				tiipd001.oltu:o.ERPOrderLeadTimeUnit,
				ticpr007.item:costing.data.item,		|* ticpr007
				ticpr007.ccur:o.ERPCurrency,
				ticpr007.ecpr:o.ERPEstimatedCostprice,
				fmfmd100.item:freight.data.item,		|* fmfmd100
				fmfmd100.frcl:o.ERPFreightClass,
				tdipu001.item:o.ERPPurchaseDataItem,		|* tdipu001
				tdipu001.otbp:o.ERPBuyFromBusinessPartner,
				tdipu001.suti:o.ERPSupplyTime,
				tdipu001.sutu:o.ERPUnitforSupplyTime,
				tppdm005.item:project.data.item,		|* tppdm005
				tppdm005.ccit:control.code.material,
				cprpd100.item:o.ERPPlanningDataItem,		|* cprpd100
				cprpd100.plit:o.IT_PlanItemType,
				cprpd100.plni:o.ERPPlanItem,
				cprpd100.plvl:o.ERPPlanLevel,
				cprpd100.tmfc:o.ERPTimeFence,
				cprpd100.tmfu:o.ERPTimeFenceUnit,
				cprpd100.plid:o.ERPPlanner,			
				tsmdm200.item:service.data.item,		|* tsmdm200
				qmptc018.item:quality.data.item,		|* qmptc018
				tcmcs001.dsca:o.PackagingUnit_Name		|* tcmcs001
			from	tcibd001
				left outer join whwmd400 on tcibd001.item=whwmd400.item
				left outer join tdisa001 on tcibd001.item=tdisa001.item
				left outer join tcibd200 on tcibd001.item=tcibd200.item
				left outer join tiipd001 on tcibd001.item=tiipd001.item
				left outer join ticpr007 on tcibd001.item=ticpr007.item
				left outer join fmfmd100 on tcibd001.item=fmfmd100.item
				left outer join tdipu001 on tcibd001.item=tdipu001.item
				left outer join tppdm005 on tcibd001.item=tppdm005.item
				left outer join cprpd100 on tcibd001.item=cprpd100.item
				left outer join tsmdm200 on tcibd001.item=tsmdm200.item
				left outer join qmptc018 on tcibd001.item=qmptc018.item
				left outer join tcmcs001 on tcibd001.cuni=tcmcs001.cuni
			where	tcibd001._index1 = {:io.ERPItem}
			as set with 1 rows
			selectdo
	
				o.ERPLocation =	shared.comp(arr.seq)
				o.ERPLocation.isSet = true
	
				|* Publish if Item Warehousing Data is present (whwmd400).
				if not isspace(o.ERPWarehousingDataItem) then
					o.ERPDepth.isSet = true
					o.ERPHeight.isSet = true
					o.ERPWidth.isSet = true
					o.ERPShelfLife.isSet = true
					o.ERPPeriodForShelfLife.isSet = true
					o.ERPHazardousMaterial.isSet = true
					o.ERPClassofRisk.isSet = true
					s.location.stockable.indicator = true	
				endif

				|* Publish if Item - Ordering Data is present (tcibd200).
				if not isspace(ordering.data.item) then
					o.ERPDefaultWarehouseLocation.isSet = true
					o.PP_EffectiveTimePeriod_StartDateTime.isSet = true
					o.PP_EffectiveTimePeriod_EndDateTime.isSet = true
					o.PP_EOQQuantity.isSet = true
					o.PP_FixedOrderQuantity.isSet = true
					o.PP_MaxQuantity.isSet = true
					o.PP_MaxOrderQuantity.isSet = true
					o.PP_MinOrderQuantity.isSet = true
					o.PP_OrderMethod.isSet = true
					o.PP_OrderIncrementQuantity.isSet = true
					o.PP_PlanningMethod.isSet = true
					o.PP_OrderPointQuantity.isSet = true
					o.PP_SafetyStockQuantity.isSet = true
					o.ERPOrderInterval.isSet = true
					o.ERPOrderIntervalUnit.isSet = true
				endif
				|* Publish if Item Production Data is present (tiipd001).
				if not isspace(o.ERPProductionDataItem) then
					o.BackFlushedIndicator.isSet = true
					o.PhantomIndicator.isSet = true
					o.ERPOrderLeadTime.isSet = true
					o.ERPOrderLeadTimeUnit.isSet = true
					s.location.producible.indicator = true	
				endif
				|* Publish if Item Costing Data is present (ticpr007).
				if not isspace(costing.data.item) then
					o.ERPCurrency.isSet = true
					o.ERPEstimatedCostprice.isSet = true
				endif
				|* Publish if Item Freight Management Data is present (fmfmd100).
				if not isspace(freight.data.item) then
					o.ERPFreightClass.isSet = true
				endif
				|* Publish if Item Purchase Data is present (tdipu001).
				if not isspace(o.ERPPurchaseDataItem) then
					o.ERPBuyFromBusinessPartner.isSet= true
					o.ERPSupplyTime.isSet = true
					o.ERPUnitforSupplyTime.isSet = true
					s.location.purchasable.indicator = true	
				endif
				|* Publish if Items - Planning Data is present (cprpd100).
				if not isspace(o.ERPPlanningDataItem) then
					o.ERPPlanningDataItem.isSet = true
					o.IT_PlanItemType.isSet = true
					o.ERPPlanItem.isSet = true
					o.ERPPlanLevel.isSet = true
					o.ERPTimeFence.isSet = true
					o.ERPTimeFenceUnit.isSet = true
					o.ERPPlanner.isSet = true			
				endif
				if not isspace(o.ERPSalesDataItem) then		
					s.location.sellable.indicator = true
				endif						

				|* Publish if Units Data is present (tcmcs001).
				if not isspace(o.PackagingUnit_Name) then
					o.PackagingUnit_Name.isSet = true
				endif

				RETIFNOK.SWITCH.COMP(
					current.company,
					set.item.location.user.area.properties(
						o.ERPSalesDataItem,
						o.ERPProductionDataItem,
						costing.data.item,
						o.ERPWarehousingDataItem,
						project.data.item,
						quality.data.item,
						o.ERPPurchaseDataItem,
						ordering.data.item,
						o.ERPPlanningDataItem,
						service.data.item,
						freight.data.item,
						io.ERPItem,
						item.type,
						item.project,
						inventory.unit,		
						sales.price,		
						sales.price.unit,	
						o.UserArea,
						o.UserArea.isSet ))	

				RETIFNOK.SWITCH.COMP(
					current.company,
					txbod.dll9002.get.custom.fields(
						"ItemMasterCommonBOD",
						"ItemLocation",
						"tcibd001.item", io.ERPItem,
						"whwmd400.item", io.ERPItem,
						"tdisa001.item", io.ERPItem,
						"tcibd200.item", io.ERPItem,
						"tiipd001.item", io.ERPItem,
						"ticpr007.item", io.ERPItem,
						"fmfmd100.item", io.ERPItem,
						"tdipu001.item", io.ERPItem,
						"tppdm005.item", io.ERPItem,
						"cprpd100.item", io.ERPItem,
						"tsmdm200.item", io.ERPItem,
						"qmptc018.item", io.ERPItem,
						o.UserArea,		|* Ref
						o.UserArea.isSet ))	|* Ref

				o.anythingFetched = true
			selectempty
			endselect
	
		endif		
	endif

	if not o.anythingFetched then
		hold.status = 0
		|**reset it to false for deletion
		first.time.read = false				
		|* Update header indicators			
		if s.location.producible.indicator and
		   isspace(o.ERPProductionDataItem) then
		   	l.update.producible.indicator = true
		endif
		if s.location.purchasable.indicator and
		   isspace(o.ERPPurchaseDataItem) then
		   	l.update.purchasable.indicator = true
		endif
		if s.location.sellable.indicator and
		   isspace(o.ERPSalesDataItem) then
		   	l.update.sellable.indicator = true
		endif
		if s.location.stockable.indicator and
		   isspace(o.ERPWarehousingDataItem) then
		   	l.update.stockable.indicator = true
		endif
		set.header.indicator.must.be.updated(
				l.update.producible.indicator,
				l.update.purchasable.indicator,
				l.update.sellable.indicator,
				l.update.stockable.indicator)
		|* reset statics
		s.location.producible.indicator = false
		s.location.purchasable.indicator = false
		s.location.sellable.indicator = false
		s.location.stockable.indicator = false
								
		|* Swith back to current company
		RETIFNOK(txcom.dll9001.switch.back.to.company(current.company))
		|* Free allocated memory.
		free.mem(shared.comp)
		free.mem(unsorted.shared.comp)			
		|* reset static
		arr.seq = 0
		o.UserArea = 0					
	else
		if hold.status = 0 then
			RETIFNOK(get.item.location.warehouse.classification(
					ABC.code,
					o.Classification,
					o.Classification.isSet))
		else
			RETIFNOK.SWITCH.COMP(current.company, get.item.location.location.classification(
					io.ERPItem,
					item.type,
					"",
					"",
					ABC.code,
					"",
					"",
					item.group,
					sales.rebate.group,
					o.ERPPurchaseDataItem,
					o.Classification,		|* Ref
					o.Classification.isSet,		|* Ref
					"",
					"",
					"",
					"",				
					"",
					control.code.material,
					order.policy,
					routing.group ))
								|#1994725.sn
		|**Reseting the variable to Zero to publish the WHWMD210 data of
		|**shared companies and increment the arr.seq value to read data
		|** for another company																			
			hold.status = 0
			inc(arr.seq)				|#1994725.en	
		endif
	endif

	return(0)
}

function extern long txbod.dll9002.get.classification.node(
			domain	tcmcs.long	i.arr.length,
		const		string		i.code.type(,),
		const		string		i.code.value(,),
		ref	domain	tcmcs.long	o.xml.node,
		ref		boolean		o.xml.node.is.set)
{
	DllUsage
	Expl:	The purpose of this function is to create the Classification
		node according next stucture:

		<Classification>
			<Codes>
				<Code
					listID="Item Types"
					sequence="1">Purchased</Code>
				<Code
					listID="Item Groups"
					accountingEntity="codedefinition180"
					sequence="2">JTO-00</Code>
			</Codes>
		</Classification>
	Pre:	N.a.
	Post:	Delete XML o.xml.node.
	Input:	i.arr.length	- Array length
		i.code.type(,)
		i.code.value(,)
	Output: o.xml.node
		o.xml.node.is.set
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll0033.get.classification.node
	EndDllUsage

	long	node
	long	node.code
	long	node.result
	long	return.value
	long	dummy.value
	string	b.data(1) based
	string	b.code(1) based
	string	b.list.id(1) based

	#define	INIT_GET_CLASSIFICATION_NODE
^		free.mem( b.data )
^		free.mem( b.code )
^		free.mem( b.list.id )

	#define	ERROR_GET_CLASSIFICATION_NODE( i_RETURN_VALUE )
^		if i_RETURN_VALUE <> 0 then
^			if node.result <> 0 then
^				dummy.value = xmlDelete( node.result )
^				node.result = 0
^			endif
^			if o.xml.node <> 0 then
^				dummy.value = xmlDelete( o.xml.node )
^				o.xml.node = 0
^			endif
^			o.xml.node = false
^			END_GET_CLASSIFICATION_NODE( i_RETURN_VALUE )
^		endif

	#define	END_GET_CLASSIFICATION_NODE( i_RETURN_VALUE )
^		INIT_GET_CLASSIFICATION_NODE
^		return( i_RETURN_VALUE )

	INIT_GET_CLASSIFICATION_NODE
	o.xml.node = 0
	o.xml.node.is.set = false

	if i.arr.length = 0 then
		return( 0 )
	endif

	|* Get the complete structure except attribute accountingEntity.
	return.value = CALL_FUNCTION(
			txbod.dll9002.classification.node.get,
			i.code.value,
			i.code.type,
			o.xml.node,		|* Ref
			o.xml.node.is.set )	|* Ref

	ERROR_GET_CLASSIFICATION_NODE( return.value )

	|* Further processing can be stopped, if no clasification node is
	|* created.
	if not o.xml.node.is.set then
		END_GET_CLASSIFICATION_NODE( 0 )
	endif

	|* Add attribute accountingEntity to element Code.
	|* Get all Code nodes.
	return.value = txbod.dll9002.get.nodes.find.match(
			"<Classification><Codes><Code>",|* Path
			"",				|* Attribute name
			"",				|* Attribute value
			o.xml.node,
			node.result )			|* Ref

	ERROR_GET_CLASSIFICATION_NODE( return.value )

	|* Handle the result.
	|* Get the first Code node.
	node = xmlGetFirstChild( node.result )

	while node <> 0
		|* Get the Code value from the node.
		return.value = txbod.dll9002.get.data.node( node, b.data )
			|* Ref: b.data

		ERROR_GET_CLASSIFICATION_NODE( return.value )

		node.code = lval( b.data )

		return.value = txbod.dll9002.get.data.node( node.code, b.code )
			|* Ref: b.code

		ERROR_GET_CLASSIFICATION_NODE( return.value )

		|* Get the value of attribute listID from the node.
		return.value = txbod.dll9002.alloc.attribute(
				node.code,
				ATTR_LIST_ID,
				b.list.id )	|* Ref

		ERROR_GET_CLASSIFICATION_NODE( return.value )

		|* Get the accountingEntity fo the actual company, code and
		|* list id.
		return.value = get.accounting.entity.for.reference.node(
				get.compnr(),
				b.code,
				b.list.id,
				ELEMENT_CODE,
				node.code )	|* Ref (io)

		ERROR_GET_CLASSIFICATION_NODE( return.value )

		|* Get next Code node.
		node = xmlGetRightSibling( node )
	endwhile

	END_GET_CLASSIFICATION_NODE( 0 )
}

function extern long txbod.dll9002.get.data.node(
		long	i.node,
	ref	string	o.data() )
{
	DllUsage
	Expl:	This function gets the data of a specified node.
	Pre:	Variable 'o.data' is declared as a based string.
	Post:	N.a.
	Input:	i.node
	Output:	o.data
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll0043.get.data.node
	EndDllUsage

	string	b.tag.name(1) based

	free.mem( o.data )

	if xmlAllocData( o.data, i.node ) = -1 then
		RETIFNOK( txbod.dll9002.get.tag.name( i.node, b.tag.name ))
			|* Ref: b.tag.name

		dal.set.error.message(
			"@No based string used. Data of XML element '" &
			b.tag.name & "' cannot be read from request." )

		return( DALHOOKERROR )
	endif

	return( 0 )
}

function extern long txbod.dll9002.get.tag.name(
		long	i.node,
	ref	string	o.tag.name() )
{
	DllUsage
	Expl:	This function gets the tag name of a specified node.
	Pre:	Variable 'o.tag.name' is declared as a based string.
	Post:	N.a.
	Input:	i.node
	Output:	o.tag.name
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll0043.get.tag.name
	EndDllUsage

	if xmlAllocName( o.tag.name, i.node ) = -1 then
		dal.set.error.message( "@No based string used." )

		return( DALHOOKERROR )
	endif

	return( 0 )
}

function extern long txbod.dll9002.alloc.attribute(
	const	long	i.node,
	const	string	i.attribute,
	ref	string	o.data() )
{
	DllUsage
	Expl:	The purpose of this function is to return a specified
		attribute from a specified node.
	Pre:	Variable 'o.data' is declared as a based string.
	Post:	Deallocate memory of variable 'o.data'.
	Input:	i.node
	Output:	o.tag
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll0043.alloc.attribute
	EndDllUsage

	if xmlAllocAttribute( o.data, i.node, i.attribute ) = -1 then
		dal.set.error.message( "@No based string used." )

		return( DALHOOKERROR )
	endif

	return( 0 )
}

function extern long txbod.dll9002.classification.node.get(
	const	string	i.code.stack(,),
	const	string	i.code.list.id.stack(,),
	ref	long	o.node,
	ref	boolean	o.node.is.set )
{
	DllUsage
	Expl.:	The purpose of this function is to create the Classification
		node according next stucture:

		<Classification>
			<Codes>
				<Code
					listID="Item Types"
					sequence="1">Purchased</Code>
				<Code
					listID="Item Groups"
					sequence="2">JTO-00</Code>
			</Codes>
		</Classification>
	Pre:	N.a.
	Post:	Delete XML o.node.
	Input:	i.code.stack(,)
		i.code.list.id.stack(,)
	Output:	o.node
		o.node.is.set
	Return:	0/DALHOOKERROR
	Old Dll : bobod.dll1033.get.classification.node
	EndDllUsage

	long	sequence
	long	position
	long	node.code
	long	node.codes
	long	nr.dimensions
	long	nr.positions
	long	dimension.info.stack(4)
	long	return.value
	long	dummy.value
	boolean	dummy.boolean

	#define	INIT_GET_CLASSIFICATION_NODE
^		sequence = 0

	#define	ERROR_GET_CLASSIFICATION_NODE( i_RETURN_VALUE )
^		if i_RETURN_VALUE <> 0 then
^			if o.node <> 0 then
^				dummy.value = xmlDelete( o.node )
^				o.node = 0
^			endif
^			o.node.is.set = false
^			END_GET_CLASSIFICATION_NODE( i_RETURN_VALUE )
^		endif

	#define	END_GET_CLASSIFICATION_NODE( i_RETURN_VALUE )
^		INIT_GET_CLASSIFICATION_NODE
^		return( i_RETURN_VALUE )

	INIT_GET_CLASSIFICATION_NODE
	o.node = 0
	o.node.is.set = false

	array.info( i.code.stack, nr.dimensions, dimension.info.stack )
	nr.positions = dimension.info.stack(2)

	|* Create the classificiation node if 
	if nr.positions > 0 then
		|* Create node 'Classification'.
		return.value = txbod.dll9002.new.node(
				TAG_NAME_CLASSIFICATON,
				o.node )	|* Ref

		ERROR_GET_CLASSIFICATION_NODE( return.value )

		|* Create node 'Codes'.
		return.value = txbod.dll9002.new.node(
				TAG_NAME_CODES,
				node.codes,	|* Ref
				o.node)		|* Parent node

		ERROR_GET_CLASSIFICATION_NODE( return.value )

		for position = 1 to nr.positions
			if isspace( i.code.stack(1,position) ) then
				continue
			endif

			return.value =
			txbod.dll9002.get.reference.node.codedefinition.bod(
				node.codes,	|* Parent node
				i.code.stack(1,position),
				i.code.list.id.stack(1,position),
				TAG_NAME_CODE,
				node.code,	|* Ref
				dummy.boolean )	|* Ref: Is set

			ERROR_GET_CLASSIFICATION_NODE( return.value )

			INC( sequence )

			|* Set attribute 'sequence'.
			return.value = txbod.dll9002.set.attribute(
					node.code,
					ATTR_SEQUENCE,
					str$( sequence ))

			ERROR_GET_CLASSIFICATION_NODE( return.value )
		endfor

		|* Remove Classification XML if no code has been added.
		if sequence = 0 then
			dummy.value = xmlDelete( o.node )
			o.node = 0
		else
			o.node.is.set = true
		endif
	endif

	END_GET_CLASSIFICATION_NODE( 0 )
}

function extern long txbod.dll9002.get.reference.node.codedefinition.bod(
		long	i.parent.node,
	const	string	i.code,
	const	string	i.list.id,
	const	string	i.tag,
	ref	long	o.node,
	ref	boolean	o.node.is.set )
{
	DllUsage
	Expl.:	The purpose of this function is to create the reference node
		for the CodeDefinitionBOD, according next structure.

		Example:
		<Codes>
			<Code
				listID="Item Types">Purchased</Code>
			<Code
				listID="Item Groups">JTO-00</Code>
		</Codes>
	Pre:	N.a.
	Post:	Delete XML o.node.
	Input:	i.parent.node
		i.code
		i.list.id
		i.tag
	Output:	o.node
		o.node.is.set
	Return:	0/DALHOOKERROR
	Old Dll : bobod.dll1033.get.reference.node.codedefinition.bod
	EndDllUsage

	long	return.value
	long	dummy.value

	#define	ERROR_GET_REFERENCE_NODE( i_RETURN_VALUE )
^		if i_RETURN_VALUE <> 0 then
^			if o.node <> 0 then
^				dummy.value = xmlDelete( o.node )
^				o.node = 0
^			endif
^			o.node.is.set = false
^			END_GET_REFERENCE_NODE( i_RETURN_VALUE )
^		endif

	#define	END_GET_REFERENCE_NODE( i_RETURN_VALUE )
^		return( i_RETURN_VALUE )

	o.node = 0
	o.node.is.set = false

	|* Create node for tag.
	return.value = txbod.dll9002.new.data.element(
			i.tag,
			trim$( i.code ),
			o.node,		|* Ref
			i.parent.node )

	ERROR_GET_REFERENCE_NODE( return.value )

	o.node.is.set = true

	|* Add attribute to node.
	return.value = txbod.dll9002.set.attribute(
			o.node,
			ATTR_LIST_ID,
			trim$( i.list.id ))

	ERROR_GET_REFERENCE_NODE( return.value )

	END_GET_REFERENCE_NODE( 0 )
}

function extern long txbod.dll9002.get.nodes.find.match(
	const	string	i.path,
	const	string	i.attribute.name,
	const	string	i.attribute.value,
		long	i.node,
	ref	long	o.node.result )
{
	DLLUsage
	Expl:	This function tries to find an XML node for the specified
		tag name/attribute name/attribute value.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.path
		i.attribute.name
		i.attribute.value
		i.node
	Output:	o.node.result
	Return:	0		--> Variable 'o.node.result' 
		DALHOOKERROR
	Old Dll : tcbod.dll0043.get.nodes.find.match
	EndDLLUsage

	long	dummy.value

	#define ERROR_GET_NODES_FIND_MATCH( i_RETURN_VALUE )
^		if i_RETURN_VALUE <> 0 then
^			if o.node.result <> 0 then
^				dummy.value = xmlDelete( o.node.result )
^				o.node.result = 0
^			endif
^			END_GET_NODES_FIND_MATCH( i_RETURN_VALUE )
^		endif

	#define END_GET_NODES_FIND_MATCH( i_RETURN_VALUE )
^		return( i_RETURN_VALUE )

	o.node.result = 0

	if isspace( i.attribute.name ) then
		|* Search for tag name only.
		o.node.result = xmlFindMatch(
				"?" & trim$( i.path ),
				i.node )

		if xmlGetNumChilds( o.node.result ) = 0 then
			dal.set.error.message(
				"tcgens0006",
				|* tcgens0006  ???
				trim$( i.path ))
			|* Element '%1$s' cannot be read from request.

			ERROR_GET_NODES_FIND_MATCH( DALHOOKERROR )
		endif
	else
		|* Search for tag name and attribute.
		if isspace( i.attribute.value ) then
			|* Attribute value not specified.
			o.node.result = xmlFindMatch(
					"?" &
					    trim$( i.path(1;len(i.path)-1 ))  &
					    " " &
					    trim$( i.attribute.name ) & ">",
					i.node )

			if xmlGetNumChilds( o.node.result ) = 0 then
				dal.set.error.message(
					"tcgens0004",
					|* tcgens0004  ???
					trim$( i.attribute.name ),
					trim$( i.path ))
				|* Attribute '%1$s' of XML element '%2$s' not
				|* found.

				ERROR_GET_NODES_FIND_MATCH( DALHOOKERROR )
			endif
		else
			|* Attribute value specified.
			o.node.result = xmlFindMatch(
					"?" &
					    trim$( i.path(1;len(i.path)-1 ))  &
					    " " &
					    trim$( i.attribute.name ) & "=" &
					    quoted.string(
					    trim$( i.attribute.value )) & ">",
					i.node )

			if xmlGetNumChilds( o.node.result ) = 0 then
				dal.set.error.message(
					"tcgens0005",
					|* tcgens0005  ???
					trim$( i.attribute.name ),
					trim$( i.attribute.value ),
					trim$( i.path ))
				|* Attribute '%1$s' with value '%2$s' not found
				|* for XML element '%3$s'.

				ERROR_GET_NODES_FIND_MATCH( DALHOOKERROR )
			endif
		endif
	endif

	END_GET_NODES_FIND_MATCH( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemLocation.ERPOrderHorizon(
		domain	tcitem		i.ERPItem,
	ref	domain	tcmcs.str25	o.ERPOrderHorizon,
	ref		boolean		io.ERPOrderHorizon.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemLocation.ERPOrderHorizon
	EndDllusage

	RETIFNOK( get.erp.order.horizon(
			i.ERPItem,
			o.ERPOrderHorizon,			|* Ref
			io.ERPOrderHorizon.isSet ) )		|* Ref

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemLocation.ERPPlanningHorizon(
		domain	tcitem		i.ERPItem,
	ref	domain	tcmcs.str25	o.ERPPlanningHorizon,
	ref		boolean		io.ERPPlanningHorizon.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemLocation.ERPPlanningHorizon
	EndDllusage

	RETIFNOK( get.erp.planning.horizon(
			i.ERPItem,
			o.ERPPlanningHorizon,			|* Ref
			io.ERPPlanningHorizon.isSet ) ) 	|* Ref

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemLocation_ItemPlanning_PlanningTimeFence(
		domain	tcwttm		i.ERPTimeFence,
			boolean		i.ERPTimeFence.isSet,
		domain	tctope		i.ERPTimeFenceUnit,
			boolean		i.ERPTimeFenceUnit.isSet,
	ref	domain	tcmcs.str25	o.PlanningTimeFence,
	ref		boolean		io.PlanningTimeFence.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to return attribute
		ItemPlanning_PlanningTimeFence of the main component.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.ERPTimeFence
		i.ERPTimeFence.isSet
		i.ERPTimeFenceUnit
		i.ERPTimeFenceUnit.isSet
	Output:	o.ItemPlanning_PlanningTimeFence
	In/out:	io.ItemPlanning_PlanningTimeFence.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.hook.onget.itemlocation_itemplanning_planningtimefence
	EndDllUsage

	o.PlanningTimeFence = ""
	io.PlanningTimeFence.isSet = false

	if i.ERPTimeFenceUnit <> empty then
		RETIFNOK( txbod.dll9002.convert.from.erp.period.type.to.iso(
				i.ERPTimeFence,
				i.ERPTimeFenceUnit,
				o.PlanningTimeFence,|* Ref
				io.PlanningTimeFence.isSet ))
	endif

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ERPOrderHorizon(
		domain	tcitem		i.ERPItem,
	ref	domain	tcmcs.str25	o.ERPOrderHorizon,
	ref		boolean		io.ERPOrderHorizon.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemMasterCommonBOD.ERPOrderHorizon
	EndDllusage

	RETIFNOK( get.erp.order.horizon(
			i.ERPItem,
			o.ERPOrderHorizon,			|* Ref
			io.ERPOrderHorizon.isSet ) )		|* Ref

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnGet.ItemMasterCommonBOD.ERPPlanningHorizon(
		domain	tcitem		i.ERPItem,
	ref	domain	tcmcs.str25	o.ERPPlanningHorizon,
	ref		boolean		io.ERPPlanningHorizon.isSet )
{
	DllUsage
	Old Dll : tcbod.dll2505.Hook.OnGet.ItemMasterCommonBOD.ERPPlanningHorizon
	EndDllusage

	RETIFNOK( get.erp.planning.horizon(
			i.ERPItem,
			o.ERPPlanningHorizon,			|* Ref
			io.ERPPlanningHorizon.isSet ) ) 	|* Ref

	return( 0 )
}

function extern long txbod.dll9002.Hook.OnSet.ItemMasterCommonBOD.ERPPlanItem(
		domain	tcitem		i.ItemMasterHeader_ItemID_ID,
			boolean		i.ItemMasterHeader_ItemID_ID.isSet,
	ref	domain	tcmcs.str50m	o.ERPPlanItem,
	ref		boolean		io.ERPPlanItem.isSet )
{
	DllUsage
	Expl:	The purpose of this function is to return attribute
		ERPItemWithoutClusterSegment from the main component.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.ItemMasterHeader_ItemID_ID
		i.ItemMasterHeader_ItemID_ID.isSet
	Output:	o.ERPPlanItem
	In/out:	io.ERPPlanItem.isSet
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll2505.Hook.OnSet.ItemMasterCommonBOD.ERPPlanItem
	EndDllUsage

	o.ERPPlanItem = ""
	io.ERPPlanItem.isSet = false
	
							|* Val_Todo_API.s	
|	RETIFNOK(cpcomdll0001.tc.to.cp.item(i.ItemMasterHeader_ItemID_ID,
|						 "", 
|						 o.ERPPlanItem))
							|* Val_Todo_API.e

	if not isspace( o.ERPPlanItem ) then
		io.ERPPlanItem.isSet = true
	endif

	return( 0 )
}

function extern long txbod.dll9002.add.string.to.stack(
	const	string	i.string(),
	ref	string	io.stack(,),
	ref	long	io.size )
{
	DllUsage
	Expl:	The purpose of this function is to add a string to the stack.
	Pre:	N.a.
	Post:	- If needed, the stack size is increased with size
		  ALLOCATION_SIZE.
		- If the string is added to the stack, the variable for the
		  stack size (io.size) is increased with one.
	Input:	i.string()
	In/out:	io.stack()
	Output:	io.size
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll0038.add.string.to.stack
	EndDllUsage
	
	#define	NOT_EMPTY( i_VALUE )
^		txbod.dll9002.value.is.not.empty( i_VALUE )

	long	dummy.value
	long	nr.stack.positions
	long	new.nr.stack.positions
	long	length.string
	long	length.stack.position
	long	new.length.stack.position
	long	dimensions.stack(4)
	long	position
	string	hold.stack(1,1) based
	boolean	allocate.memory.stack

	allocate.memory.stack = false

	|* Get actual stack sizes.
	array.info( io.stack, dummy.value, dimensions.stack ) |* Ref
	length.stack.position = dimensions.stack(1)
	nr.stack.positions = dimensions.stack(2)

	|* Get needed stack position and length.
	length.string = len.in.bytes( i.string )
	INC( io.size )

	|* Check if (re)allocation is needed.
	if length.string > length.stack.position or
	   io.size > nr.stack.positions then
		allocate.memory.stack = true
	endif

	if allocate.memory.stack then
		|* First make a copy of the actual stack if needed.
		if nr.stack.positions > 0 then
			dummy.value = alloc.mem(
					hold.stack,
					length.stack.position,
					nr.stack.positions )

			copy.mem( hold.stack, io.stack )
		endif

		|* Get new stack sizes.
		if length.string > length.stack.position then
			new.length.stack.position =
					length.string + ALLOCATION_SIZE
		else
			new.length.stack.position = length.stack.position
		endif

		|* Fall back for empty strings on first stack position.
		if new.length.stack.position = 0 then
			INC( new.length.stack.position )
		endif

		if io.size > nr.stack.positions then
			new.nr.stack.positions =
					io.size + ALLOCATION_SIZE
		else
			new.nr.stack.positions = nr.stack.positions
		endif

		dummy.value = alloc.mem(
				io.stack,
				new.length.stack.position,
				new.nr.stack.positions )

		|* Copy the hold stack to the new allocated stack if needed.
		if nr.stack.positions > 0 then
			for position = 1 to nr.stack.positions
				copy.mem(
					io.stack(1,position),
					hold.stack(1,position) )
			endfor

			free.mem( hold.stack )
		endif
	endif

	|* Add string to stack.
	if NOT_EMPTY( i.string ) then
		copy.mem( io.stack(1,io.size), i.string )
	endif

	return( 0 )
}

function extern long txbod.dll9002.convert.from.erp.item.type(
		domain	tckitm		i.erp.item.type,
       ref	domain	tcmcs.str25	o.bod.item.type )
{
	DllUsage
	expl	: This function converts the ERP Item Type to the external
		  item type specification used in the BODs.
	Pre	: Variable o.bod.item.type is declared as based.
	Post	: Deallocate memory variable o.bod.item.type
	Input	: i.erp.item.type
	Output	: o.bod.item.type
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0031.convert.from.erp.item.type
	EndDllUsage

	o.bod.item.type = ""

	on case i.erp.item.type
	case tckitm.purchase:
		o.bod.item.type = PURCHASED

		break
	case tckitm.manufacture:
		o.bod.item.type = MANUFACTURED

		break
	case tckitm.generic:
		o.bod.item.type = GENERIC

		break
	case tckitm.cost:
		o.bod.item.type = COST

		break
	case tckitm.service:
		o.bod.item.type = SERVICE

		break
	case tckitm.subcontracting:
		o.bod.item.type = SUBCONTRACTING

		break
	case tckitm.list:
		o.bod.item.type = LIST

		break
	case tckitm.tool:					|#JVD.sn
		o.bod.item.type = TOOL

		break						|#JVD.en
	case tckitm.equipment:
		o.bod.item.type = EQUIPMENT

		break
	case tckitm.engineering:
		o.bod.item.type = ENGINEERING

		break
	default:
		#pragma used domain tckitm
		#pragma used field tcibd001.kitm

		dal.set.error.message(
			"tcbods0040",
			|* tcbods0040  ???
			tt.field.desc( "tcibd001.kitm" ),
			enum.descr$( "tckitm", i.erp.item.type ))
			|* tckitm  ???

		return( DALHOOKERROR )
	endcase

	return( 0 )
}

function extern long txbod.dll9002.convert.from.erp.order.policy(
		domain	tcopol		i.erp.order.policy,
	ref	domain	tcmcs.str25	o.bod.order.policy )
{
	DllUsage
	expl	: This function converts the ERP Order Policy to the external
		  order policy used in the BODs.
	Pre	: Variable o.bod.order.policy is declared as based.
	Post	: Deallocate memory variable o.bod.order.policy
	Input	: i.erp.order.policy
	Output	: o.bod.order.policy
	Return	: 0		if OK
		  DALHOOKERROR	if error
	Old Dll : tcbod.dll0031.convert.from.erp.order.policy
	EndDllUsage
	
	|* Order Policy
	#define ORDER_POLICY_TO_ORDER				"ToOrder"
	#define ORDER_POLICY_ANONYMOUS				"Anonymous"

	o.bod.order.policy = ""

	on case i.erp.order.policy
	case tcopol.anonymous:
		o.bod.order.policy = ORDER_POLICY_ANONYMOUS

		break
	case tcopol.on.order:
		o.bod.order.policy = ORDER_POLICY_TO_ORDER

		break
	default:
		#pragma used domain tcopol
		#pragma used field tcibd200.opol

		dal.set.error.message(
			"tcbods0040",
			|* tcbods0040  ???
			tt.field.desc( "tcibd200.opol" ),
			enum.descr$( "tcopol", i.erp.order.policy ))
			|* tcopol  ???

		return( DALHOOKERROR )
	endcase

	return( 0 )
}

function extern long txbod.dll9002.convert.from.erp.mdm.configuration.controlled(
		domain	tsmdm.cctr	i.configuration.controlled,
	ref		string		o.code(),
	ref		boolean		o.code.is.set )
{
	DllUsage
	Expl:	The purpose of this function is to convert the specified
		configuration controlled to a code.
	Pre:	Variable o.code() is declared as a based string.
	Post:	N.a.
	Input:	i.configuration.controlled
	Output:	o.code()	- Based string
		o.code.is.set 
	Return:	0/DALHOOKERROR
	Old Dll : tsbod.dll1000.convert.from.erp.mdm.configuration.controlled
	EndDllUsage
	
	#define	CONFIGURATION_CONTROLLED_SERIALIZED	"Serialized"
	#define	CONFIGURATION_CONTROLLED_ANONYMOUS	"Anonymous"
	#define	CONFIGURATION_CONTROLLED_CONSUMABLE	"Consumable"

	free.mem( o.code )
	o.code.is.set = false

	on case i.configuration.controlled
	case tsmdm.cctr.serialized:
		SET_BASED_VARIABLE( CONFIGURATION_CONTROLLED_SERIALIZED, o.code ) |* Ref
		break
	case tsmdm.cctr.anonymous:
		SET_BASED_VARIABLE( CONFIGURATION_CONTROLLED_ANONYMOUS, o.code ) |* Ref
		break
	case tsmdm.cctr.consumable:
		SET_BASED_VARIABLE( CONFIGURATION_CONTROLLED_CONSUMABLE, o.code ) |* Ref
		break
	default:
		dal.set.error.message(
			"tcbods0040",
			|* tcbods0040  ???
			tt.field.desc( "tsmdm200.seri" ),
			enum.descr$(
				domainof( i.configuration.controlled ),
				i.configuration.controlled ))
		|* %1$s '%2$s' is not supported.

		return( DALHOOKERROR )
	endcase

	if NOT_EMPTY( o.code ) then
		o.code.is.set = true
	endif

	return( 0 )
}

function extern boolean txbod.dll9002.accounting.entity.supported()
{
	DLLUsage
	Expl:	This function checks if a accounting entity is supported.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.code.list
	Output:	N.a.
	Return:	true	- if accounting entity is supported
		false	- if accounting entity is not supported
	Old Dll : tcbod.dll3300.accounting.entity.supported
	EndDLLUsage

		long		ret
	domain	tcmcs.str5	publish.ae			|#1711221.n
	domain	tcmcs.str50	list.id
	domain	tcmcs.str50	code.value
		boolean		accounting.entity.supported

	list.id = ""
	code.value = ""

	accounting.entity.supported = false

|t	STOP.MESSAGES
	ret = txbod.dll9002.get.list.id(
			list.id,
			code.value)

	if txbod.dll9002.code.list.supported(list.id) then

		ret = txmcs.dll9001.read.parm.for.comp.and.date(
				"tcbod000",
				0,
				get.compnr())

		if tcbod000.plcb = tcbod.plcb.acen then

			|* Some CodeDefinition are always published on tenant level
			on case trim$(list.id)
			case	CODE_BPTMM_TYPE_TRANSACTIONTYPE:
			case	CODE_CUSTOMER_RATING_CODE:			|#1856513.n
			case	CODE_FINANCIALCALENDARTYPE:
			case	CODE_ITEMTYPE:
			case	CODE_QMNCM_ORGN_ORDERORIGIN:
			case	CODE_QMNCM_SVTY_SEVERITY:
			case	CODE_QMPTC_ORGN_ORIGINOFINSPEC:
			case	CODE_LNREVENUERECOGNITIONBASEDON:|#1855884.n
			case	CODE_TCMCS_RSTP_REASONTYPE:
			case	CODE_TRANSPORTATIONMETHOD:
			case	CODE_TCKOWC_WORKCENTERTYPE:
			case	CODE_TSMDM_CCTR_CONFIGURATIONCONTROLLED:	|#LND2-11023.n
			case	CODE_SERVICECOSTTYPES:				|#LND2-11023.n
			case	CODE_UNITCODE:
			case	CODE_UNITCATEGORY:
			case	CODE_DIMENSION:
			case	LEDGER_UNIT_DIM_1:
			case	LEDGER_UNIT_DIM_2:
			case	CODE_MROCLASS:			|#1835825.n
			case	CODE_WHWMD_PCTR_PARTCHANGETAGREASON:		|#1875315.n
				|* accounting.entity.supported = false
				break
			default:
				accounting.entity.supported = true
			endcase
		else						|#1711221.sn
			|* Some CodeDefinition are always published on accounting entity level
			on case trim$(list.id)
			case	CODE_COSTCENTER:		|* Cost Centers
				publish.ae = txmcs.dll9001.get.tcmcs095.str.parameter(
						"BOD",
						0,
						100,
						"ccae")
				if trim$(publish.ae) = "true" then
					accounting.entity.supported = true
				endif
				break
			default:
				accounting.entity.supported = false
			endcase					|#1711221.en
		endif
	endif
|t	START.MESSAGES

	return(accounting.entity.supported)
}

function extern boolean txbod.dll9002.code.list.supported(
				const	string	i.code.list)
{
	DLLUsage
	Expl:	This function checks if a standard code list is supported.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.code.list
	Output:	N.a.
	Return:	true	- if the code list exists
		false	- if the code list does not exist
	Old Dll : tcbod.dll3300.code.list.supported
	EndDLLUsage

	long	ret

	boolean	code.list.supported

	string	dummy.code
	string	dummy.table

|t	STOP.MESSAGES

	code.list.supported = false

	ret = txbod.dll9002.get.root.table(
			i.code.list,		|* i.listid,
			dummy.code,	|* i.code.value,
			dummy.table,	|*o.root.table )
			code.list.supported)

|t	START.MESSAGES

	return(code.list.supported)
}

function extern long txbod.dll9002.get.root.table(
	const	string			i.listid,
	const	string			i.code.value,
	ref	string			o.root.table,
					... )
{
	DLLUsage
	Expl:	The purpose of this function is to return the root table of the
		CodeDefinitionBOD.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.list.id
	Output:	o.root.table
	Return:	0/DALHOOKERROR
	Old Dll : tcbod.dll3300.get.root.table
	EndDLLUsage

	domain	tcmcs.str50	o.dummy.description

	put.boolean.arg(4, true)

	o.root.table = ""

	on case trim$(i.listid)

	case 	CODE_ACTIVITYTEMPLATE:		|* Activity Templates (FP9)
		o.root.table = "tsacm101"
		break
	case	CODE_AREA:			|* Geographic Areas (FP5)
		o.root.table = "tcmcs045"
		break
	case	CODE_BUSINESSPARTNERTYPE:	|* Customer Types (FP5)
		o.root.table = "tcmcs029"
		break
	case	CODE_BUSINESSSECTOR:		|* Business Sectors (FP8)
		o.root.table = "tppdm055"
		break
	case	CODE_CASHFLOWREASON:
		o.root.table = "tcmcs005"
		break
	case	CODE_CHANNEL:			|* Markets (FP5)
		o.root.table = "tcmcs066"
		break
	case	CODE_COMMODITYCODE:		|* Commodity Codes (FP5)
		o.root.table = "tcmcs028"
		break
	case	CODE_CONTACTCATEGORIES:		|* Contact Categories (FP7)
		o.root.table = "tcmcs128"
		break
	case	CODE_CORRECTIVEACTIONTYPE:	|* Corrective Action Types (FP8)
		o.root.table = "qmcpl001"
		break
	case	CODE_LNCORRECTIVEACTIONCATEGORIES:
		|* Corrective Action Categories (FP15)
		o.root.table = "qmcpl002"
		break	
	case	CODE_COSTCENTER:		|* Cost Centers (FP5)
		o.root.table = "tcmcs065"
		break
	case	CODE_COSTCOMPONENT:		|* Cost Components (FP8)
		o.root.table = "tcmcs048"
		break
	case 	CODE_COVERAGETYPE:		|* Coverage Types (FP9)
		o.root.table = "tsmdm035"
		break
	case	CODE_DEFECTIVEMATERIALNOTICE:	|* Defective Material Notice
		o.root.table = "qmncm005"	|* Responsibility Codes (FP8)
		break
	case	CODE_DEPARTMENT:		|* "Departments" (FP7)
		o.root.table = "tcmcs065"	|* dummy table
		break
	case	CODE_DIMENSION:
		o.root.table = "tfbia801"
		|* tfbia802
		break
	case	CODE_DISPOSITIONCODE:		|* Disposition Codes (FP10)
		o.root.table = "qmncm006"
		break
								|#1875324.sn
	case	CODE_MATERIAL_DISPOSITIONCODE:	|* LN Material Disposition Codes (FP10)
		o.root.table = "qmncm007"
		break
								|#1875324.en
	case	CODE_ENTERPRISEUNIT:		|* Enterprise Units (FP5)
		o.root.table = "tcemm030"
		break
	case	CODE_FINANCINGMETHOD:		|* Financing Methods (FP8)
		o.root.table = "tppdm059"
		break
	case	CODE_FLEXDIMENSION:
		o.root.table = "tfgld010"
		break
	case	CODE_FREIGHTCLASS:		|* "Freight Classes" (FP8)
		o.root.table = "fmfmd030"
		break
	case	CODE_FREIGHTSERVICELEVEL:	|* Freight Service Levels (FP8)
		o.root.table = "tcmcs075"
		break
	case	CODE_GENERALTASK:		|* "General tasks" (FP8)
		o.root.table = "bpmdm050"
		break						
								|#LND2-11023.sn
	case	CODE_GENERICWARRANTIES:		|* LN Generic Warranties (FP16)
		o.root.table = "tsctm500"
		break
								|#LND2-11023.en
	case 	CODE_HOLDREASONCODE:		|* Hold Reason Codes (FP5)
		o.root.table = "tcmcs005"
		break
	case 	CODE_INVENTORYADJUSTMENTREASONCODE:	|* Inventory Adjustment Reason Codes (FP8)
		o.root.table = "tcmcs005"
		break
	case	CODE_INVOICEDELIVERYMETHOD:	|* Invoice Delivery Methods (FP8)
		o.root.table = "tcmcs056"
		break
	case 	CODE_INSPECTIONLEVEL:		|* Inspection Levels (FP9)
		o.root.table = "qmptc064"
		break
	case 	CODE_INSPECTIONSTANDARD:	|* Inspection Standards	(FP9)
		o.root.table = "qmptc074"
		break
	case 	CODE_ITEMASPECT:		|* Item Aspects	(FP9)
		o.root.table = "qmptc002"
		break
	case 	CODE_ITEMCHARACTERISTIC:	|* Item Characteristics (FP9)
		o.root.table = "qmptc001"
		break
	case 	CODE_ITEMCHARACTERISTICOPTION:	|* Item Characteristic Options (FP10)
		o.root.table = "qmptc014"
		break
	case	CODE_ITEMCONTROLCODE:		|* Item Control Codes (FP8)
		|* When called from tcbod.dll3300.code.list.supported i.code.value is empty
		if not isspace(i.code.value) then
			RETIFNOK(txbod.dll9002.read.item.control.codes.data(
				i.code.value,
				o.root.table,
				o.dummy.description))
		endif
		break
	case	CODE_ITEMGROUP:			|* Item Groups (FP5)
		o.root.table = "tcmcs023"
		break
	case	CODE_ITEMSIGNAL:		|* Item Signals (FP7)
		o.root.table = "tcmcs018"
		break
	case	CODE_JOURNALBOOKDIMENSION:
		o.root.table = "tfgld050"
		break
	case 	CODE_LABORCODE:			|* Labor Codes (FP9)
		o.root.table = "tsmdm015"
		break
	case	CODE_LABORCONTROLCODE:		|* Labor Control Codes (FP8)
		|* When called from tcbod.dll3300.code.list.supported i.code.value is empty
		if not isspace(i.code.value) then
			RETIFNOK(txbod.dll9002.read.labor.control.codes.data(
				i.code.value,
				o.root.table,
				o.dummy.description))
		endif
		break
	case	LEDGER_UNIT_DIM_1:		|* Ledger Unit 1
		o.root.table = "tcmcs001"
		break
	case	LEDGER_UNIT_DIM_2:		|* Ledger Unit 2
		o.root.table = "tcmcs001"
		break
	case	CODE_LINEOFBUSINESS:		|* Industries (FP5)
		o.root.table = "tcmcs031"
		break
	case	CODE_LNREASON:				|* LN Reasons	|#1699557.sn
		o.root.table = "tcmcs005"
		break							|#1699557.en
	case	CODE_LNWORKCELLPLANGROUP:		|* Work Cell Plan Groups 
		o.root.table = "tirpt042"
		break	
	case	CODE_MATERIALREVIEWBOARDCODE:	|* Material Review Board Codes (FP8)
		o.root.table = "qmncm003"
		break
	case	CODE_NAICS:			|* NAICS (FP7)
		o.root.table = "tcmcs125"
		break
	case	CODE_NONCONFORMANCESEVERITYCODE:|* Non Conformance Severity Codes (FP8)
		o.root.table = "qmncm002"
		break
	case	CODE_NONCONFORMANCETYPE:	|* Non Conformance Types (FP8)
		o.root.table = "qmncm001"
		break
	case	CODE_OPPORTUNITYSOURCES:	|* Opportunity Source (FP7)	|#1694181.sn
		o.root.table = "tcmcs124"
		break								|#1698141.en
	case	CODE_OPPORTUNITYSTAGE:		|* Sales Stages (FP5)
		o.root.table = "tdsmi003"
		break
	case	CODE_OVERHEADCODE:		|* Overhead Codes (FP8)
		o.root.table = "tppdm042"
		break
	case	CODE_PACKAGELABELTEMPLATECODE:	|* Package Label Template Codes (FP8)
		o.root.table = "whwmd520"
		break
	case	CODE_PARTYDIMENSION:
		o.root.table = "tccom100"
		break
	case	CODE_PAYMENTMETHODS:		|* PaymentMethods (FP5)		|#1846601.sn
		o.root.table = "tfcmg003"
		break								|#1846601.en
	case	CODE_PAYMENTTERM:		|* PaymentTerm (FP5)
		o.root.table = "tcmcs013"
		break
	case	CODE_PHASECODE:			|* Phase Codes (FP8)
		o.root.table = "tppdm085"
		break
	case 	CODE_PROBLEMCODE:		|* Problem Codes (FP9)
		o.root.table = "tsclm330"
		break
	case	CODE_PROCESSCODE:		|* Process Codes (FP8)
		o.root.table = "tirou003"
		break
	case	CODE_PRODUCTCLASS:		|* Item Classes (FP5)
		o.root.table = "tcmcs062"
		break
								|#1699557.so
|	case	CODE_PRODUCTIONORDERREASONS:	|* Production Order Reasons (FP5)
|		o.root.table = "tcmcs005"
|		break						|#1699557.eo
	case	CODE_PRODUCTLINE:		|* Product Lines (FP5)
		o.root.table = "tcmcs061"
		break
	case	CODE_PRODUCTSELECTIONCODE:	|* Product Selection Code (FP7)
		o.root.table = "tcmcs022"
		break
	case	CODE_PRODUCTTYPE:		|* Product Types (FP7)
		o.root.table = "tcmcs015"
		break
	case	CODE_PROJECTACQUIRINGMETHOD:	|* Project Acquiring Methods (FP8)
		o.root.table = "tppdm063"
		break
	case	CODE_PROJECTCATEGORY:		|* Project Categories (FP8)
		o.root.table = "tppdm075"
		break
	case	CODE_PROJECTGROUP:		|* Project Groups (FP8)
		o.root.table = "tppdm065"
		break
	case	CODE_PROJECTPROGRAM:		|* Project Programs (FP8)
		o.root.table = "tpctm010"
		break
	case	CODE_REASONFORCHARGE:		|* Reasons for Charge (FP8)
		o.root.table = "tcmcs021"
		break
	case	CODE_REBATEGROUP:		|* Item Rebate Groups (FP5)
		o.root.table = "tdcms018"
		break
	case	CODE_RECONGROUPDIMENSION:
		o.root.table = "tcfin020"
		break
	case	CODE_REFERENCEDESIGNATOR:	|* Reference Designator (FP8)
		o.root.table = "tcmcs090"
		break
	case	CODE_REJECTREASONS:		|* Reject Reasons (FP5)
		o.root.table = "tcmcs005"
		break
								|#LND2-11023.sn
	case	CODE_RESPONSETYPES:		|* LN Response Types (FP16)
		o.root.table = "tsclm020"
		break
								|#LND2-11023.en
	case	CODE_RETURNREASON:		|* Return Reasons (FP9)
		o.root.table = "tcmcs005"
		break
	case	CODE_REVENUECODES:		|* Revenue Codes (FP8)
		|* When called from tcbod.dll3300.code.list.supported i.code.value is empty
		if not isspace(i.code.value) then
			RETIFNOK(txbod.dll9002.read.project.revenue.data(
				i.code.value,
				o.root.table,
				o.dummy.description))
		endif
		break
	case	CODE_SALESTYPE:			|* Sales Types (FP8)
		o.root.table = "tcmcs202"
		break
	case 	CODE_SAMPLINGRULE:		|* Sampling Rules (FP9)
		o.root.table = "qmptc060"
		break
								|#LND2-11023.sn
	case	CODE_SERIALIZEDITEMGROUPS:	|* LN Serialized Item Groups (FP16)
		o.root.table = "tscfg010"
		break
	case	CODE_SERIALIZEDITEMWARRANTIES:	|* LN Serialized Item Warranties (FP16)
		o.root.table = "tsctm020"
		break
								|#LND2-11023.en
	case 	CODE_SERVICEAREA:		|* Service Areas (FP9)
		o.root.table = "tsmdm105"
		break
								|#LND2-11023.sn
	case 	CODE_SERVICECONTRACTTYPES:	|* Service Contract Types (FP16)
		o.root.table = "tsctm005"
		break
	case	CODE_SERVICEITEMGROUPS:		|* LN Service Item groups (FP16)
		o.root.table = "tsmdm210"
		break
								|#LND2-11023.en
	case 	CODE_SERVICETYPE:		|* Service Types (FP9)
		o.root.table = "tsmdm030"
		break
								|#LND2-11023.sn
	case 	CODE_SERVICEUSAGECLASSES:	|* Service Usage Classes (FP16)
		o.root.table = "tsspc030"
		break
								|#LND2-11023.en
	case	CODE_SKILL:			|* Skills (FP5)
		o.root.table = "tcppl010"
		break
	case 	CODE_SOLUTIONCODE:		|* Solution Codes (FP9)
		o.root.table = "tsclm335"
		break
	case	CODE_SOURCEOFDEFECTCODE:	|* Source of Defect Codes (FP8)
		o.root.table = "qmncm004"
		break
	case 	CODE_SUBDIVISION:		|* SubDivisions	(FP8)
		o.root.table = "tcmcs143"
		break
	case	CODE_SUNDRYCOSTSCONTROLCODE:	|* Sundry Cost Control Codes (FP8)
		|* When called from tcbod.dll3300.code.list.supported i.code.value is empty
		if not isspace(i.code.value) then
			RETIFNOK(txbod.dll9002.read.sundry.cost.control.codes.data(
				i.code.value,
				o.root.table,
				o.dummy.description))
		endif
		break
	case	CODE_TAXACCOUNTDIMENSION:
		o.root.table = "tfgld008"
		break
	case	CODE_TAXCODEDIMENSION:
		o.root.table = "tcmcs037"
		break
	case	CODE_TAXCOUNTRYDIMENSION:
		o.root.table = "tcmcs010"
		break
	case	CODE_TERRITORY:			|* Territories (FP7)
		o.root.table = "tcmcs127"
		break
	case 	CODE_TEST:			|* Tests (FP9)
		o.root.table = "qmptc006"
		break
	case	CODE_TITLE:			|* Titles (FP6)
		o.root.table = "tcmcs019"
		break
	case	CODE_UNITCODE:			|* Unit Codes (FP5)
		o.root.table = "tcmcs001"
		break
	case 	CODE_WAGEGROUP:			|* Wage Groups	(FP9)
		o.root.table = "tcppl030"
		break
	|* System Defined List IDs
	case	CODE_BPTMM_TYPE_TRANSACTIONTYPE:
	case	CODE_CUSTOMER_RATING_CODE:			|#1856513.n
	case	CODE_FINANCIALCALENDARTYPE:
	case	CODE_ITEMTYPE:
	case	CODE_QMNCM_ORGN_ORDERORIGIN:
	case	CODE_QMNCM_SVTY_SEVERITY:
	case	CODE_QMPTC_ORGN_ORIGINOFINSPEC:
	case	CODE_LNREVENUERECOGNITIONBASEDON:		|#1855884.n
	case	CODE_TCKOWC_WORKCENTERTYPE:			|#JVD.n
	case	CODE_TCMCS_RSTP_REASONTYPE:			|#1699557.n
	case	CODE_TRANSPORTATIONMETHOD:			|#1698141.n
	case	CODE_TSMDM_CCTR_CONFIGURATIONCONTROLLED:	|#LND2-11023.n
								|#1874675.sn
	case	CODE_TSCMM_CLST_CUSTOMERCLAIMLINESTATUS:
	case	CODE_TSCMM_CLMT_CLAIMMETHOD:
	case	CODE_TSCMM_CUSTGTO_CUSTOMERCLAIMTAGGEDTO:
								|#1874675.en
	case	CODE_SERVICECOSTTYPES:				|#LND2-11023.n
	case	CODE_MROCLASS:					|#1835825.n
	case	CODE_UNITCATEGORY:
	case	CODE_WHWMD_PCTR_PARTCHANGETAGREASON:		|#1875315.n
		|* All system defined list ids must be published from the same
		|* company, because of the variationID. Otherwise, a change
		|* will never become active if published with a lower
		|* variationID from a company with a lower first free number.
		o.root.table = "tcemm170"	|* Companies
		break
	default:
		if txbod.dll9002.list.id.exists(i.listid) then
			o.root.table = "tcbod011"
		else
			put.boolean.arg(4, false)
		endif
	endcase

	return(0)
}

function extern boolean txbod.dll9002.list.id.exists(
		domain	tcbod.list		i.list.id)
{
	DLLUsage
	Exp.	: This function determines if the listID/verb exists
	Pre	: n.a.
	Post	: n.a.
	Input	: i.list.id
		  i.verb
	Output	: -
	Return	: true/false
	Old Dll : tcbod.dll1010.list.id.exists
	EndDLLUsage

			boolean		list.id.exists
		domain	tcbod.verb	verb.for.importing

	list.id.exists = false

	select	tcbod010.verb :verb.for.importing
	from	tcbod010
	where	tcbod010._index1 = {:i.list.id}
	as set with 1 rows
	selectdo
		list.id.exists = true
	endselect

	return(list.id.exists)
}

function extern long txbod.dll9002.get.list.id(
	ref	domain	tcmcs.str50	o.list.id,
	ref	domain	tcmcs.str50	o.code.value)
{
	DllUsage
	Expl:	This function retrieves the static variable for listID of the
		CodeDefinitionGeneralBOD.
	Pre:	N.a.
	Post:	N.a.
	Input:	N.a.
	Output:	o.list.id
	Return:	N.a.
	Old Dll : tcbod.dll3320.get.list.id
	EndDllusage

	handle.list.id(
		GET_VALUE,
		o.list.id,
		o.code.value)

	return(0)
}



function extern long txbod.dll9002.read.item.control.codes.data(
	const	string			i.item,
	ref	string			o.table.name,
	ref	string			o.description )
{
	DllUsage
	Old Dll : tcbod.dll3320.read.item.control.codes.data
	EndDllUsage

		long	return.value
	domain	tccprj	project
	domain	tcitem	item.segment

	o.table.name = ""
	o.description = ""

	|* Check if item is a project item.
	if txpdm.dll9001.project.item.exists( i.item ) then
		txibd.dll9001.read.item.description( i.item, o.description )
			|* Ref: o.description

		o.table.name = "tppdm005"

		return( 0 )	|* Early return.
	endif

	|* Extract the project segment from the item.
	if txibd.dll9001.determine.segment(
			i.item,
			tcibd.apco.project,
			project ) = ENOREC then
		ASSERT( false, "Segment type for project is unknown." )
	endif

	|* Extract the item segment from the item.
	if txibd.dll9001.determine.segment(
			i.item,
			tcibd.apco.none,
			item.segment ) = ENOREC then
		ASSERT( false, "Segment type for item is unknown." )
	endif

	|* Check if item is a subcontracting item.
	return.value = txpdm.dll9001.check.item.subcontracting.exist(
			item.segment,
			project,
			o.description,	|* Ref
			2,		|* Read tppdm035 and tppdm635.
			2 )		|* Not compulsory

	on case return.value
	case 1:	|* Project Subcontracting
		o.table.name = "tppdm635"

		return( 0 )	|* Early return.
	case 2:|* Standard Subcontracting
		o.table.name = "tppdm035"

		return( 0 )	|* Early return.
	endcase

	|* Check if item is an equipment item.
	return.value = txpdm.dll9001.check.item.equipment.exist(
			item.segment,
			project,
			2,		|* Read tppdm025 and tppdm625.
			2,		|* Not compulsory
			o.description )	|* o.description

	on case return.value
	case 1:	|* Project Equipment
		o.table.name = "tppdm625"

		return( 0 )	|* Early return.
	case 2:	|* Standard Equipment
		o.table.name = "tppdm025"

		return( 0 )	|* Early return.
	endcase

	|* Item is not a project item, equipment item or subcontracting item.
	dal.set.error.message(
		"tcbods0196",
		|* tcbods0196  ???
		trim$( i.item ),
		enum.descr$( "tckitm", tckitm.subcontracting ),
		|* tckitm  ???
		enum.descr$( "tckitm", tckitm.equipment ) )
		|* tckitm  ???

	return( DALHOOKERROR )
}

function extern long txbod.dll9002.read.labor.control.codes.data(
	const		string		i.labor,
	ref		string		o.table.name,
	ref		string		o.description)
{
	DllUsage
	Old Dll : tcbod.dll3320.read.labor.control.codes.data
	EndDllUsage

		long	dummy.long
	domain	tcitem		item.part
	domain	tccprj		project.part

	o.table.name = ""
	o.description = ""

	|* To extract the project part from the itemcode
	dummy.long = txibd.dll9001.determine.segment(
			i.labor,
			tcibd.apco.project,
			project.part)
	|* To extract the itembase part from the itemcode
	dummy.long = txibd.dll9001.determine.segment(
			i.labor,
			tcibd.apco.none,
			item.part)

	txpdm.dll9001.read.labor.description(		
			project.part,
			item.part,		|* labor
			o.description)
	
	if isspace(project.part) then
		o.table.name = "tppdm015"
	else
		o.table.name = "tppdm615"
	endif

	return(0)
}

function extern long txbod.dll9002.read.project.revenue.data(
	const		string		i.project.revenue,
	ref		string		o.table.name,
	ref		string		o.description)
{
	DllUsage
	Old Dll : tcbod.dll3320.read.project.revenue.data
	EndDllUsage

		long	dummy.long
	domain	tcitem		item.part
	domain	tccprj		project.part

	o.table.name = ""
	o.description = ""

	|* To extract the project part from the itemcode
	dummy.long = txibd.dll9001.determine.segment(
			i.project.revenue,
			tcibd.apco.project,
			project.part)

	|* To extract the itembase part from the itemcode
	dummy.long = txibd.dll9001.determine.segment(
			i.project.revenue,
			tcibd.apco.none,
			item.part)

	txpdm.dll9001.read.revenue.description(
			project.part,		|* project
			item.part,		|* revenue
			o.description)

	if isspace(project.part) then
		o.table.name = "tppdm043"
	else
		o.table.name = "tppdm643"
	endif

	return(0)
}

function extern long txbod.dll9002.read.sundry.cost.control.codes.data(
	const		string		i.sundry.cost,
	ref		string		o.table.name,
	ref		string		o.description)
{
	DllUsage
	Old Dll : tcbod.dll3320.read.sundry.cost.control.codes.data
	EndDllUsage

		long	dummy.long
	domain	tcitem		item.part
	domain	tccprj		project.part

	o.table.name = ""
	o.description = ""

	|* To extract the project part from the itemcode
	dummy.long = txibd.dll9001.determine.segment(
			i.sundry.cost,
			tcibd.apco.project,
			project.part)

	|* To extract the itembase part from the itemcode
	dummy.long = txibd.dll9001.determine.segment(
			i.sundry.cost,
			tcibd.apco.none,
			item.part)

	txpdm.dll9001.read.sundry.cost.description(
			project.part,		|* project
			item.part,		|* sundry cost
			o.description)

	if isspace(project.part) then
		o.table.name = "tppdm040"
	else
		o.table.name = "tppdm640"
	endif

	return(0)
}

function extern long txbod.dll9002.set.list.id(
		domain	tcmcs.str50	i.list.id,
		domain	tcmcs.str50	i.code.value)
{
	DllUsage
	Expl:	This function sets a static variable for listID of the
		CodeDefinitionGeneralBOD.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.list.id
	Output:	N.a.
	Return:	N.a.
	Old Dll : tcbod.dll3320.set.list.id
	EndDllusage

	handle.list.id(
		SET_VALUE,
		i.list.id,
		i.code.value)

	return(0)
}
function extern long txbod.dll9002.publish.code.definition.flex.dimension(
			domain	tfgld.dimn	i.dimension.type,
			domain	tfgld.dimx	i.dimension,
			domain	tcmcs.str10	i.action.code)
{
	DllUsage
	Expl:	This function publishes the creation of a code definition
		flex dimension
	Pre:	N.a.
	Post:	N.a.
	Input:	i.dimension.type -> Dimension Type
		i.dimension	 -> Dimension
		i.action.code	 -> Action Code
	Output:	N.a.
	Return: 0 / DALHOOKERROR
	Old DlL : tcbod.dll0005.publish.code.definition.flex.dimension
	EndDllUsage

	domain	tcmcs.str50	identifier
	domain	tcmcs.str50	code
	long	ret
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID	


	RETIFNOK(txbia.dll9001.get.dimension.name.of.flexible.dim.definition(
			get.compnr(),
			i.dimension.type,
			code))

	RETIFNOK(txbod.dll9002.compose.type.code.identifier(
			code,
			i.dimension,
			identifier))
	|* Needed for function tcbod.dll3300.accounting.entity.supported
	RETIFNOK(txbod.dll9002.set.list.id(
			CODE_FLEXDIMENSION,
			identifier ))
	ret = BOD.Publish("CodeDefinitionFlexDimensionBOD",
			"tfgld010",
			i.action.code,
			0,
			"",
			identifier,	|* Document ID
			VAL_PROC_STAGE_OR_PUBLISH,
			o.ExceptionMessage,
			o.ExceptionID,
			i.dimension.type,
			i.dimension)
	return(0)
}
function extern long txbod.dll9002.compose.type.code.identifier(
			const	string		i.type,
			const	string		i.code,
		ref	domain	tcmcs.str50	o.identifier)
{
	DllUsage
	Expl:	This function composes the identifier for the
		CodeDefinitionBOD.
	Pre:	N.A.
	Post:	N.A.
	Input:	i.type
		i.code
	Output:	o.identifier
	Return:	0		if OK
		DALHOOKERROR	if error
	Old DlL : tcbod.dll0001.compose.type.code.identifier
	EndDllUsage

|*OBSOLETE
	|* prefixing of CodeDefinition Identifier not allowed anymore
	o.identifier = trim$(i.code)

	return(0)
}

function extern long txbod.dll9002.publish.code.definition.meta.flex.dimension(
			domain	tcmcs.byte	i.dummy.dseq,
			domain	tcmcs.str10	i.action.code)
{

	DllUsage
	Expl:	This function publishes the CodeDefinitionMetaFlexDimension
	Pre:	N.a.
	Post:	N.a.
	Input:	i.dummy.dseq	-> dummy dimension sequence
		i.action.code	-> Action Code
	Output:	N.a.
	Return: 0 / DALHOOKERROR
	Old Dll : tcbod.dll0005.publish.code.definition.meta.flex.dimension
	EndDllUsage

	domain	tcmcs.str50	identifier
	domain	tcmcs.byte	dimension.sequence
	domain	tcmcs.str30	dimension.name
	domain	tcmcs.str30	default.dimension.description
	
	long	l.ret,i
	domain tcmcs.s999m o.ExceptionMessage
	long	o.ExceptionID 

	RETIFNOK(txbod.dll9002.get.flexible.dimension.definition.data(
				dimension.sequence,
				dimension.name,
				default.dimension.description))
				
								|#1627268.sn
	|* Needed for function tcbod.dll3300.accounting.entity.supported
	RETIFNOK(txbod.dll9002.set.list.id(
			CODE_DIMENSION,
			identifier ))				|#1627268.en
			
	l.ret = BOD.Publish(				|* API CALL
			"CodeDefinitionMetaFlexDimensionBOD",
			"tfbia801",
			i.action.code,
			0,
			"",
			identifier,
			VAL_PROC_STAGE_OR_PUBLISH,
			o.ExceptionMessage,
			o.ExceptionID)
			
	if l.ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif
		
	return(0)
}

function extern long txbod.dll9002.get.flexible.dimension.definition.data(
	ref	domain	tcmcs.byte	o.dimension.sequence,
	ref	domain	tcmcs.str30	o.dimension.name,
	ref	domain	tfgld.desc	o.default.dimension.description )
{
	DllUsage
	Expl:	This function reads the dimension sequence data of a
		dimension sequence stored with function:
		'tfbia.dll0001.set.dimension.sequence(...)'.
	Pre:	N.a.
	Post:	N.a.
	Input:	N.a.
	Output:	o.dimension.sequence
		o.dimension.name
		o.default.dimension.description
	Return:	0/DALHOOKERROR
	Old Dll : tfbia.dll0001.get.flexible.dimension.definition.data
	EndDllusage

	o.dimension.sequence = get.dimension.sequence()

	select	tfbia801.name:o.dimension.name,
			tfbia801.defd:o.default.dimension.description
	from	tfbia801
	where	tfbia801.dseq = { :o.dimension.sequence }
	as set with 1 rows
	selectdo
		|* No action required.
		break
	selectempty
		o.dimension.sequence = 0
		o.dimension.name = ""
		o.default.dimension.description = ""

		dal.set.error.message(
			"tcbods0029",
			|* tcbods0029  ???
			tt.field.desc( "tfbia801.dseq" ) & ": " &
						str$( o.dimension.sequence ),
			ENOREC )
		|* %1$s can not be read. Error: %2$d.

		return( DALHOOKERROR )
	endselect

	return( 0 )
}

function extern long txbod.dll9002.check.parameters()
{
	DLLUsage
	Expl	: The Logistic Interface Parameters will be initialized.
	Pre	: retry point set
	Post	: abort or commit.transaction
	Input	: NA
	Output	: NA
	Return	: 0, succes; DALHOOKERROR otherwise.
	EndDLLUsage
	
	select	txbod001.*
	from	txbod001 for update
	selectdo
		return(0)
	selectempty
		db.retry.point()
		db.set.to.default(ttxbod001)
		txbod001.indt = 0
		txbod001.dsca = sprintf$( form.text$( "txmcs009501" ),
		|* Actual set defined on %1$s.
					  sprintf$( "%u002 %U002",
					  	    utc.num(), utc.num() ) )
		if db.insert(ttxbod001, db.retry) <> 0 then
			abort.transaction()
			return( DALHOOKERROR )
		endif
		|* Insert second record
		txbod001.indt = utc.num()
		txbod001.dsca = form.text$("txmcs009505")
		|* Automatic generated default setting.
		if db.insert(ttxbod001, db.retry) <> 0 then
			abort.transaction()
			return( DALHOOKERROR )
		endif

		commit.transaction()
	endselect

	return(0)
}
function extern long txbod.dll9002.convert.from.iso.unit.to.erp(
				domain	tcitem		i.item,
				domain	tcictc		i.iso.unit,
				boolean			i.check.unit.set,
				boolean			i.check.conv.fct,
			ref	domain	tccuni		o.erp.unit)
{
	DllUsage
	Expl	: This function converts the ISO unit code, to the ERP
		  unit code.
		  When item is empty, first unit found with the correct
		  iso code, is returned; when no unit is found, unit is
		  searched for that has empty iso code and with unit equal to
		  the iso code.
		  When item is filled, last unit found with the correct
		  iso code, and found unit is in unit set of item and has
		  conversion factor to the item's inventory unit, is returned.
		  When unit found equals inventory unit or weight unit of item,
		  this unit overrules other units and is returned;
		  when no unit is found, unit is searched for that has empty
		  iso code and with unit equal to the iso code.
		  Example 1:
		  - units with correct iso code and in unit set with valid
		    conversion factor: A, B and C
		  - inventory unit of item = B
		  - B is always returned
		  Example 2:
		  - units with correct iso code and in unit set with valid
		    conversion factor: A, B and C
		  - inventory unit of item = D
		  - C is returned
		  Example 3:
		  - no units with correct iso code
		  - there is a unit X that equals the iso code X
		  - X is returned
	Pre	: -
	Post	: -
	Input	: i.item
		  i.iso.unit
		  variable arguments:
		  	check.unit.set	- if unit set must be checked
		  	check.conv.fct	- if conv fct must be checked
	Output	: o.erp.unit
	Return	: 0		if OK
		  DALHOOKERROR	if error
	OLD DLL : tcbod.dll0031.convert.from.iso.unit.to.erp
	EndDllUsage

	long				ret

		domain	tccuni		erp.unit
		domain	tcuset		unit.set
		domain	tccuni		inventory.unit
		domain	tccuni		weight.unit
		domain	tcwght		dummy.weight
	static	domain	tccuni		s.erp.unit
	static	domain	tcictc		s.iso.unit
	static	domain	tcuset		s.unit.set
	static	domain	tccuni		s.inventory.unit
	static	domain	tccuni		s.weight.unit
	static	domain	tcitem		s.item

	o.erp.unit = ""

	if isspace(i.iso.unit) then
		return(0)
	endif

	if trim$(s.item) = trim$(i.item)	 and
	   trim$(s.iso.unit) = trim$(i.iso.unit) then
		o.erp.unit = s.erp.unit
		return(0)
	endif

	if not isspace(i.item) then
		if trim$(s.item) = trim$(i.item) then
			unit.set	= s.unit.set
			inventory.unit	= s.inventory.unit
			weight.unit	= s.weight.unit
		else
			unit.set = txibd.dll9001.get.item.unit.set(
					get.compnr(),
					i.item)
			inventory.unit = txibd.dll9001.get.item.inventory.unit(
					get.compnr(),
					i.item)
			txibd.dll9001.get.item.weight(
					get.compnr(),
					i.item,
					dummy.weight,
					weight.unit)
			s.item			= i.item
			s.unit.set		= unit.set
			s.inventory.unit	= inventory.unit
			s.weight.unit		= weight.unit
		endif
	else
		s.item			= ""
		s.unit.set		= ""
		s.inventory.unit	= ""
		s.weight.unit		= ""
	endif

	select	tcmcs001.cuni:erp.unit
	from	tcmcs001
	where	tcmcs001.icun = :i.iso.unit
	selectdo
		if isspace(i.item) then
			|* when no item, just take first unit
			o.erp.unit = erp.unit
			break
		else
			if erp.unit = inventory.unit	or
			   erp.unit = weight.unit	then
				|* when found unit is inventory unit or
				|* weight unit, this unit is returned.
				o.erp.unit = erp.unit
				break
			endif

			if erp.unit = weight.unit then
				|* when found unit is weight unit,
				|* always return weight unit
				o.erp.unit = erp.unit
				break
			endif

			if i.check.unit.set then
				ret = txibd.dll9001.unit.in.unitset(
						unit.set,
						erp.unit,
						"",	|i.type
						0,	|i.update.status
						true)	|i.mess
				if ret <> 0 then
					continue
				endif
			endif

			if i.check.conv.fct then
				ret = txibd.dll9001.check.conversion.factor(
						i.item,
						"",	|i.item.group,
						inventory.unit,
						erp.unit)
				if ret = 0 then
				|* when a valid unit found, save this value
					o.erp.unit = erp.unit
				endif
			else
				|* when a valid unit found, save this value
				o.erp.unit = erp.unit

			endif
		endif
	selectempty
	endselect

	if isspace(o.erp.unit) then

	|* find a unit with empty iso code, that equals the iso code
	select	tcmcs001.cuni:erp.unit
	from	tcmcs001
	where	tcmcs001.icun = ""
	selectdo
		if toupper$(trim$(erp.unit)) <> trim$(i.iso.unit) then
			continue
		endif

		if isspace(i.item) then
			|* when no item, just take first unit
			o.erp.unit = erp.unit
			break
		else
			if erp.unit = inventory.unit	or
			   erp.unit = weight.unit	then
				|* when found unit is inventory unit or
				|* weight unit, this unit is returned.
				o.erp.unit = erp.unit
				break
			endif

			if erp.unit = weight.unit then
				|* when found unit is weight unit,
				|* always return weight unit
				o.erp.unit = erp.unit
				break
			endif

			if i.check.unit.set then
				ret = txibd.dll9001.unit.in.unitset(
						unit.set,
						erp.unit,
						"",	|i.type
						0,	|i.update.status
						true)	|i.mess
				if ret <> 0 then
					continue
				endif
			endif

			if i.check.conv.fct then
				ret =
				txibd.dll9001.check.conversion.factor(
						i.item,
						"",	|i.item.group,
						inventory.unit,
						erp.unit)
				if ret = 0 then
				|* when a valid unit found,
				|* save this value
					o.erp.unit = erp.unit
				endif
			else
				|* when a valid unit found,
				|* save this value
				o.erp.unit = erp.unit

			endif
		endif
	endselect

	endif

	if isspace(o.erp.unit) then
		dal.set.error.message(	"txbods0016",
		|* No unit found for ISO Code %1$s.
					i.iso.unit)
		return(DALHOOKERROR)
	endif

	s.iso.unit = i.iso.unit
	s.erp.unit = o.erp.unit

	return(0)
}


|******************************** Internal functions ***************************

function domain tcmcs.byte get.dimension.sequence()
{
	domain	tcmcs.byte	dimension.sequence

	handle.dimension.sequence(
		GET_VALUE,
		dimension.sequence )	|* Ref

	return( dimension.sequence )
}

function handle.dimension.sequence(
			long		i.method,
	ref	domain	tcmcs.byte	io.dimension.sequence )
{
	static	domain	tcmcs.byte	s.dimension.sequence

	on case i.method
	case SET_VALUE:
		s.dimension.sequence = io.dimension.sequence

		break
	case GET_VALUE:
		io.dimension.sequence = s.dimension.sequence

		break
	endcase
}

function long get.sub.entity.indicators.user.area(
		domain	tcitem	i.ERPSalesDataItem,
		domain	tcitem	i.ERPProductionDataItem,
		domain	tcitem	i.ERPCostingDataItem,
		domain	tcitem	i.ERPWarehousingDataItem,
		domain	tcitem	i.ERPProjectDataItem,

		domain	tcitem	i.ERPQualityDataItem,
		domain	tcitem	i.ERPPurchaseDataItem,
		domain	tcitem	i.ERPOrderingDataItem,
		domain	tcitem	i.ERPPlanningDataItem,
		domain	tcitem	i.ERPServiceDataItem,
		domain	tcitem	i.ERPFreightDataItem,
		domain	tcitem	i.ERPItem,			|#1660100.n
		domain	tckitm	i.ERPItemType,			|#1660100.n
		domain	tccprj	i.ERPProject,			|#1660100.n
	ref		string	io.name.stack(,),
	ref		string	io.type.stack(,),
	ref		string	io.value.stack(,),
	ref		long	io.nr.positions )
{
|	#define	NR_SUB_ENTITY_INDICATORS	11		|#1660100.o
	#define	NR_SUB_ENTITY_INDICATORS	12		|#1660100.n
	#define	SUB_ENTITY_IND_MAX_LENGTH_NAME	25
	#define	SUB_ENTITY_IND_MAX_LENGTH_TYPE	15
	#define	SUB_ENTITY_IND_MAX_LENGTH_VALUE	5

	long	counter
	long	position
	long	hold.nr.positions
	string	name(SUB_ENTITY_IND_MAX_LENGTH_NAME)
	string	type(SUB_ENTITY_IND_MAX_LENGTH_TYPE)
	string	value(SUB_ENTITY_IND_MAX_LENGTH_VALUE)
	domain	tccprj	project					|#1660100.n

	hold.nr.positions = io.nr.positions

	allocate.memory.user.area.stacks(
		NR_SUB_ENTITY_INDICATORS,
		SUB_ENTITY_IND_MAX_LENGTH_NAME,
		SUB_ENTITY_IND_MAX_LENGTH_TYPE,
		SUB_ENTITY_IND_MAX_LENGTH_VALUE,
		io.name.stack,		|* Ref (io)
		io.type.stack,		|* Ref (io)
		io.value.stack,		|* Ref (io)
		io.nr.positions )	|* Ref (io)

	type = PROP_TYPE_INDICATOR

	STOP.MESSAGES

	for counter = 1 to NR_SUB_ENTITY_INDICATORS
		value = PROP_NAMEVALUE_FALSE 

		on case counter
		case 1: |* Sales data
			name = PROP_NAME_SALES_INDICATOR

			if not isspace( i.ERPSalesDataItem ) then
				value = PROP_NAMEVALUE_TRUE
			endif

			break
		case 2: |* Production data
			name = PROP_NAME_PRODUCTION_INDICATOR

			if not isspace( i.ERPProductionDataItem ) then
				value = PROP_NAMEVALUE_TRUE
			endif

			break
		case 3: |* Costing data
			name = PROP_NAME_COSTING_INDICATOR

			if not isspace( i.ERPCostingDataItem ) then
				value = PROP_NAMEVALUE_TRUE
			endif

			break
		case 4: |* Warehousing data
			name = PROP_NAME_WAREHOUSING_INDICATOR

			if not isspace( i.ERPWarehousingDataItem ) then
				value = PROP_NAMEVALUE_TRUE
			endif

			break
		case 5: |* Project data
			name = PROP_NAME_PROJECT_INDICATOR

|			if not isspace( i.ERPProjectDataItem ) or 	|#1660100.o

			|* Check if item is a TP or PCS item.		|#1660100.sn
			if txibd.dll9001.customized.item( i.ERPItem, project ) or
			(i.ERPItemType = tckitm.subcontracting and
			    txibd.dll9001.subc.present.in.project(
 	 			i.ERPItem,
				i.ERPProject)) or
			 (i.ERPItemType = tckitm.equipment and
			    txibd.dll9001.equip.present.in.project(
 	 			i.ERPItem,
				i.ERPProject))	then			|#1660100.en

				value = PROP_NAMEVALUE_TRUE
			endif

			break
		case 6:	|* Quality data
			name = PROP_NAME_QUALITY_INDICATOR

			if not isspace( i.ERPQualityDataItem ) then
				value = PROP_NAMEVALUE_TRUE
			endif

			break
		case 7: |* Purchase data
			name = PROP_NAME_PURCHASE_INDICATOR

			if not isspace( i.ERPPurchaseDataItem ) then
				value = PROP_NAMEVALUE_TRUE
			endif

			break
		case 8: |* Ordering data
			name = PROP_NAME_ORDERING_INDICATOR

			if not isspace( i.ERPOrderingDataItem ) then
				value = PROP_NAMEVALUE_TRUE
			endif

			break
		case 9: |* Planning data
			name = PROP_NAME_PLANNING_INDICATOR

			if not isspace( i.ERPPlanningDataItem ) then
				value = PROP_NAMEVALUE_TRUE
			endif

			break
		case 10: |* Service data
			name = PROP_NAME_SERVICE_INDICATOR

			if not isspace( i.ERPServiceDataItem ) then
				value = PROP_NAMEVALUE_TRUE
			endif

			break
		case 11: |* Freight data
			name = PROP_NAME_FREIGHT_INDICATOR

			if not isspace( i.ERPFreightDataItem ) then
				value = PROP_NAMEVALUE_TRUE
			endif

			break
		case 12: |* Tool data				|#1660100.sn
			name = PROP_NAME_TOOL_INDICATOR
|			if tcint.dlltitrp.check.tool.present(i.ERPItem) then	|#1895264.o
			if tool.type.exists(i.ERPItem) then			|#1895264.n
				value = PROP_NAMEVALUE_TRUE
			endif

			break					|#1660100.en
		default:
			|* Programming error, therefore error message is
			|* hardcoded.
			ASSERT(	false,
				"Number of sub entity indicators too high." )

			break
		endcase

		position = hold.nr.positions + counter

		io.name.stack(1,position) = name
		io.type.stack(1,position) = type
		io.value.stack(1,position) = value
	endfor

	START.MESSAGES

	return( 0 )
}

function boolean tool.type.exists(				|#1895264.sn
	const	domain	tcitem			i.tool.type)
{
	|* The function tcint.dlltitrp.check.tool.present gives problems if Tools 
	|* is not implemented, therefor this function is created. 


	domain	tcitem	bind.tool.type			|* Bind Variable.
	
	if	not isspace(i.tool.type)
	then	
		select	titrp001.tltp:bind.tool.type
		from	titrp001
		where	titrp001._index1 = {:i.tool.type}
		as set with 1 rows
		selectdo
			return(true)
		endselect
	endif
	
	return(false)
}

function extern domain tcbool txibd.dll9001.subc.present.in.project(
					domain	tcitem		i.item,
					domain	tccprj		i.cprj)
{
	DLLUSAGE
		Input:	i.item		Item Code
			i.cprj		Project Code
		Output:	-
		Return:	0 - Subcontracting not in TP
			1 - Subcontracting in TP
		Usage : 
		if projectcode filled then
			level = 2 : Read 'standard' as well as 'project' tables.
		else
			level = 0 : Read only 'standard' table.
	Old Dll : tcibd.dll0011.subc.present.in.project
	EndDllusage

	domain	tcibd.csub	io.csub.code	|* Subcontracting Code
	domain	tccom.desc	dummy.descr	|* Dummy Description

	dummy.descr = ""			|* Initialize dummy.descr
	
		long		ret.val				
	static	domain	tcitem	hold.item
	static	domain	tccomp	hold.company
		domain	tccomp	current.company

	dummy.descr = ""			|* Initialize dummy.descr

	current.company = get.compnr()
	if hold.company <> current.company or
	   hold.item <> i.item then
		ret.val = txibd.dll9001.determine.segment(i.item, 
						tcibd.apco.none,
						io.csub.code)
		ret.val = txpdm.dll9001.check.item.subcontracting.exist(
						io.csub.code,
						i.cprj,
						dummy.descr,
						isspace(i.cprj) ? 0 : 1,
								|#200-99865.en
						0)	|* Reference Type
		hold.item = i.item
		hold.company = current.company
	endif						
	if ret.val = 1 or ret.val = 2 then			
		|* The variable ret.val can have the following values:
		|* 0: If item is not used anywhere
		|* 1: If item is customized item used in TP package.
		|* 2: If item is standard item used in TP package.
		|* 3: If item is used in PCS module.
		return(true)
	else
		return(false)
	endif							
}

function extern domain tcbool txibd.dll9001.equip.present.in.project(
					domain	tcitem		i.item,
					domain	tccprj		i.cprj)
{
	DLLUSAGE
		Input:	i.item		Item Code
			i.cprj		Project Code
		Output:	-
		Return:	0 - Equipment not present in TP
			1 - Equipment present in TP
		Usage : 
		if projectcode filled then
			level = 2 : Read 'standard' as well as 'project' tables.
		else
			level = 0 : Read only 'standard' table.
	Old Dll : tcibd.dll0011.equip.present.in.project
	EndDllusage

		domain	tcitem	equipment.code		|* Equipment Code
		domain	tcdsca	dummy.descr		|* Dummy Description
	static	domain	tcbool	ret.val			|* Return Value
	static	domain	tcitem	hold.item	
	static	domain	tccomp	hold.company
		domain	tccomp	current.company
	
	dummy.descr = ""			|* Initialize dummy.descr

	current.company = get.compnr()
	if hold.company <> current.company or
	   hold.item <> i.item then

		ret.val = txibd.dll9001.determine.segment(i.item,
						tcibd.apco.none, 
						equipment.code)
		ret.val = txpdm.dll9001.check.item.equipment.exist(
						equipment.code,
						i.cprj, 
						isspace(i.cprj) ? 0 : 2,
						0, 	|* Reference Type
						dummy.descr)
		hold.item = i.item
		hold.company = current.company
	endif
	return(ret.val ? true : false)
}


function handle.list.id(
			long		i.method,
	ref	domain	tcmcs.str50	io.list.id,
	ref	domain	tcmcs.str50	io.code.value)
{
	static	domain	tcmcs.str50	s.list.id
	static	domain	tcmcs.str50	s.code.value

	on case i.method
	case SET_VALUE:
		s.list.id = io.list.id
		s.code.value = io.code.value
		break
	case GET_VALUE:
		io.list.id = s.list.id
		io.code.value = s.code.value
		break
	endcase
}

function long get.accounting.entity.for.reference.node(
		long	i.company,
	const	string	i.code,
	const	string	i.list.id,
	const	string	i.tag.name,
	ref	long	io.xml.node )
{
		boolean		accounting.entity.is.set
		boolean		location.is.set
		boolean		lid.is.set
	domain	tcbod.acen	accounting.entity
	domain	tcbod.lctn	location
	domain	tcbod.loid	lid
	domain	tcitem		erp.item			|#1867118.sn
		string		b.code(1) based

	free.mem( b.code )

	|* Because the conversion to the BOD item is already done, the item must
	|* be converted to the ERP item.
	if trim$(i.list.id) = CODE_ITEMCONTROLCODE then
		RETIFNOK(txbod.dll9002.convert.to.erp.item_API(
				i.code,
				erp.item))

		SET_BASED_VARIABLE( erp.item, b.code )
	else
		SET_BASED_VARIABLE( i.code, b.code )
	endif	

	RETIFNOK(txbod.dll9002.set.list.id( i.list.id, b.code ))

	if txbod.dll9002.accounting.entity.supported() then
		RETIFNOK(txbod.dll9002.get.id.attributes.by.noun(
				i.company,
				"CodeDefinitionBOD",	|* Noun
|				i.code,			|* i.noun.identifier	|#1867118.o
				b.code,			|* i.noun.identifier	|#1867118.n
				accounting.entity,	|* Ref
				accounting.entity.is.set, |* Ref
				location,		|* Ref
				location.is.set,	|* Ref
				lid,			|* Ref
				lid.is.set))		|* Ref

		|* The location and lid are not set for CodeDefinition BODs.
		location.is.set = false
		lid.is.set = false

		RETIFNOK(set.attributes(
				io.xml.node,
				i.tag.name,
				accounting.entity,
				accounting.entity.is.set,
				location,
				location.is.set,
				lid,
				lid.is.set))
	endif

	return( 0 )
}

function long txbod9001.handle.before.execute.function(
	const	string	i.script,
	const	string	i.function,
		boolean	i.return.load.error,
	ref	long	o.dll.id,
	ref	long	o.function.id,
	ref	string	o.object,
	ref	long	o.retval )
{
	FunctionUsage
	Expl:	This function loads a specified DLL function. The DLL object
		to load will be extracted from the specified function.

		Example:
		Variable 'i.function' = "bobod.dll0001.publish.bod".
		Variable 'o.object' = "oboboddll0001"
	Pre:	N.a.
	Post:	N.a.
	Input:	i.script
		i.function
		i.return.error.load
	Output:	o.dll.id	- Recieved DLL ID of 'load_dll()'
		o.function.id	- Recieved function ID of 'get_function()'
		o.object	- Object extracted from variable 'i.function'
		o.retval	- Return value
	Return:	0/DALHOOKERROR
	EndFunctionUsage

	|**********************************************************************
	|* Load DLL/function
	|**********************************************************************
|t	if not i.return.load.error then
|		dal.set.messages.off()
|t	endif

	o.retval = txbod9001.load.dll.function(
			i.script,
			i.function,
			o.dll.id,	|* Ref
			o.function.id,	|* Ref
			o.object )	|* Ref

|t	if not i.return.load.error then
|		dal.set.messages.on()
|t	endif

	if o.retval <> 0 then
		|* Error occurred in load of DLL/function.
		if not i.return.load.error then
			|* Do not return the error of the load DLL/function.
			o.retval = 0
		endif

		|* Force to stop further processing.
		return( DALHOOKERROR )
	endif

	return( 0 )
}
function long txbod9001.load.dll.function(
	const	string	i.script,
	const	string	i.function,
	ref	long	o.dll.id,
	ref	long	o.function.id,
	ref	string	o.object)
{
	o.dll.id = 0
	o.function.id = 0
	o.object = ""

	if isspace( i.script ) then
		|* Get the object from the function call.
		o.object = txbod.dll9002.get.object.name.function( i.function )
	else
		o.object = "o" & trim$( i.script )
	endif

	|* Load the specified DLL.
	o.dll.id = load_dll( o.object, DLL_SILENT_ERR )

	RETIFNOK( txbod.dll9002.check.return.value.parse.and.exec(
			i.script,
			"",	|* Function name
			"",	|* Function call
			o.dll.id = 0 ? -1 : o.dll.id ))

	|* Load the specified function.
	o.function.id = get_function( o.dll.id, i.function )

	RETIFNOK( txbod.dll9002.check.return.value.parse.and.exec(
			i.script,
			i.function,
			"",	|* Function call
			o.function.id = 0 ? -2 : o.function.id ))

	return( 0 )
}

function long get.item.location.location.classification(
		domain	tcitem		i.ItemMasterHeader_ItemID_ID,
		domain	tckitm		i.ERPItemType,
		domain	tcmcs.cpcl	i.ERPProductClass,
		domain	tcmcs.cpln	i.ERPProductLine,
		domain	tcabcc		i.ERPABCCode,
		domain	tcdscc		i.ERPSize,
		domain	tcccde		i.ERPCommodityCode,
		domain	tccitg		i.ERPItemGroup,
		domain	tdcms.cmgp	i.ERPSalesRebateGroup,
		domain	tcitem		i.ERPPurchaseDataItem,
	ref	domain	tcmcs.long	o.ItemMasterHeader_Classification,
	ref		boolean		io.ItemMasterHeader_Classification.isSet,
		domain	tcdscb		i.ERPMaterial,
		domain	tcdscb		i.ERPStandard,
		domain	tcctyp		i.ERPProductType,
		domain	tccsel		i.ERPSelectionCode,
		domain	tccsig		i.ERPItemSignal,
		domain	tcitem		i.ERPControlCodeMaterial,
		domain	tcopol		i.ERPOrderPolicy,
		domain	tcmcs.rgrp	i.ERPRoutingGroup )
{

		long		size.stack
		long		stack.position
		long		return.value
		string		b.type.stack(1,1) based
		string		b.value.stack(1,1) based
		boolean		is.project.item		|* TP or PCS
		boolean		is.project.object
	domain	tcmcs.str25	item.type
	domain	tcmcs.str25	order.policy
	domain	tcitem		project.object
	domain	tcmcs.str50	bod.project.object
	domain	tsmdm.csgr	service.item.group
	domain	tsmdm.cctr	configuration.controlled
	
	string	b.code(1)	based
	boolean	code.is.set

	#define INIT_HOOK_ON_GET_HEADER_CLASSIFICATION
^		free.mem( b.type.stack )
^		free.mem( b.value.stack )
^		free.mem( b.code)

	#define ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( i_RETURN_VALUE )
^		if i_RETURN_VALUE <> 0 then
^			INIT_HOOK_ON_GET_HEADER_CLASSIFICATION
^			return( i_RETURN_VALUE )
^		endif

	#define	SET_MRO	(not isspace( i.ERPPurchaseDataItem ) and not is.project.item)

	INIT_HOOK_ON_GET_HEADER_CLASSIFICATION
	size.stack = 0
	o.ItemMasterHeader_Classification = 0
	io.ItemMasterHeader_Classification.isSet = false

	|* An project object can be:
	|* - Project Item (tppdm005)
	|* - Standard Equipment (tppdm025) - Project Equipment (tppdm625)
	|* - Standard Subcontracting (tppdm035) - Project Equipment (tppdm635)
	return.value = get.project.object(
			i.ItemMasterHeader_ItemID_ID,
			i.ERPItemType,
			i.ERPControlCodeMaterial,
			is.project.item,	|* Ref: TP or PCS item.
			is.project.object,	|* Ref
			project.object )	|* Ref

	ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

	|* Type and value must be stored on the same position in the stacks.
	|* Variable 'stack.position'' is used for that.

	if i.ERPItemType <> empty then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_ITEMTYPE,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.convert.from.erp.item.type(
				i.ERPItemType,
				item.type )	|* Ref

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				item.type,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	if not isspace(i.ERPItemGroup) then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_ITEMGROUP,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				i.ERPItemGroup,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	if not isspace( i.ERPMaterial ) then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_MATERIAL,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				i.ERPMaterial,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	if not isspace( i.ERPStandard ) then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_STANDARD,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				i.ERPStandard,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	if not isspace( i.ERPSize ) then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_SIZE,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				i.ERPSize,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	if not isspace( i.ERPProductType ) then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_PRODUCTTYPE,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				i.ERPProductType,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	if not isspace( i.ERPProductClass ) then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_PRODUCTCLASS,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				i.ERPProductClass,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	if not isspace( i.ERPProductLine ) then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_PRODUCTLINE,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				i.ERPProductLine,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	if not isspace( i.ERPSelectionCode ) then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_PRODUCTSELECTIONCODE,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				i.ERPSelectionCode,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	if not isspace(i.ERPCommodityCode) then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_COMMODITYCODE,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				i.ERPCommodityCode,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	if not isspace( i.ERPItemSignal ) then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_ITEMSIGNAL,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				i.ERPItemSignal,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	if not isspace( i.ERPSalesRebateGroup ) then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_REBATEGROUP,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				i.ERPSalesRebateGroup,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	if not isspace( i.ERPABCCode ) then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_ABCCODE,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				i.ERPABCCode,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	if SET_MRO then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_MROCLASS,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				ASTERISK,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	if is.project.object then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_ITEMCONTROLCODE,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.convert.from.erp.item_API(
				project.object,
				bod.project.object )	|* Ref

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				bod.project.object,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	if i.ERPOrderPolicy <> empty then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_ORDERPOLICY,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.convert.from.erp.order.policy(
				i.ERPOrderPolicy,
				order.policy )	|* Ref

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				order.policy,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	if not isspace( i.ERPRoutingGroup ) then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_ROUTETYPE,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				i.ERPRoutingGroup,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	|* get tsmdm200.csgr en tsmdm200.seri
	if txmdm.dll9001.service.item.data.present(
				i.ItemMasterHeader_ItemID_ID) then

		txmdm.dll9001.read.service.item.group.item(
				i.ItemMasterHeader_ItemID_ID,
				service.item.group)

		if not isspace(service.item.group) then
			stack.position = size.stack
	
			return.value = txbod.dll9002.add.string.to.stack(
					CODE_SERVICEITEMGROUPS,
					b.type.stack,	|* Ref (io)
					stack.position )|* Ref (io)
	
			ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	
			return.value = txbod.dll9002.add.string.to.stack(
					service.item.group,
					b.value.stack,	|* Ref (io)
					size.stack )	|* Ref (io)
	
			ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
		endif

		txmdm.dll9001.read.configuration.controlled(
				i.ItemMasterHeader_ItemID_ID,
				configuration.controlled)

		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_TSMDM_CCTR_CONFIGURATIONCONTROLLED,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

		RETIFNOK(txbod.dll9002.convert.from.erp.mdm.configuration.controlled(
				configuration.controlled,
				b.code,
				code.is.set ))

		return.value = txbod.dll9002.add.string.to.stack(
				b.code,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )
	endif

	return.value = txbod.dll9002.get.classification.node(
			size.stack,
			b.type.stack,					|* Ref
			b.value.stack,					|* Ref
			o.ItemMasterHeader_Classification,		|* Ref
			io.ItemMasterHeader_Classification.isSet )	|* Ref

	ERROR_HOOK_ON_GET_HEADER_CLASSIFICATION( return.value )

	INIT_HOOK_ON_GET_HEADER_CLASSIFICATION

	return( 0 )
}

function long get.project.object(
	const	domain	tcitem		i.item,
	const	domain	tckitm		i.item.type,
	const	domain	tcitem		i.control.code.material,
	ref		boolean		o.is.project.item,
	ref		boolean		o.is.project.object,
	ref	domain	tcitem		o.project.object )
{
	domain	tccprj	project
	domain	tcitem	item

	|* Get item segemnt.
	RETIFNOK( txibd.dll9001.determine.segment(
			i.item,
			tcibd.apco.none,
			item ))	|* Ref

	|* Check if item is a TP or PCS item.
	o.is.project.item = txibd.dll9001.customized.item( i.item, project )
				|* Ref: project
	o.is.project.object = false
	o.project.object = ""

	on case i.item.type
	case tckitm.subcontracting:	|* Standard/project subcontracting
		o.project.object = get.project.object.subcontracting(
					project,
					item )

		break
	case tckitm.equipment:	|* Standard/project equipment
		o.project.object = get.project.object.equipment(
					project,
					item )

		break
	default:	|* Material.
		if txpdm.dll9001.project.item.exists( i.item ) then
			o.project.object = i.control.code.material
		endif

		break
	endcase

	|* If project object is filled, the item is a project object.
	if not isspace( o.project.object ) then
		o.is.project.object = true
	endif

	return( 0 )
}

function string get.project.object.subcontracting(
	const	domain	tccprj	i.project,
	const	domain	tcitem	i.item )
{
	domain	tcibd.csub	control.code

	|* Subcontracting item exists in TP.
	txpdm.dll9001.read.subcontracting.control.code(
		i.project,
		i.item,
		control.code )	|* Ref

	if txpdm.dll9001.reference.type.subcontracting.is.project(
			i.project,
			control.code ) then
		return( i.project & control.code )
	else
		return( control.code )
	endif
}

function string get.project.object.equipment(
	const	domain	tccprj	i.project,
	const	domain	tcitem	i.item )
{
	domain	tcmcs.str10	control.code

	|* Equipment item present in TP.
	txpdm.dll9001.read.equipment.control.code(
		i.project,
		i.item,
		control.code)	|* Ref

	if txpdm.dll9001.reference.type.equipment.is.project(
			i.project,
			control.code ) then
		return( i.project & control.code )
	else
		return( control.code )
	endif
}

function long get.erp.planning.horizon(
		domain	tcitem		i.ERPItem,
	ref	domain	tcmcs.str25	o.ERPPlanningHorizon,
	ref		boolean		io.ERPPlanningHorizon.isSet )
{
	domain	cpcom.hori	dummy.order.horizon
	domain	tctope		dummy.order.horizon.unit
	domain	cpcom.hori	planning.horizon
	domain	tctope		planning.horizon.unit

	o.ERPPlanningHorizon = ""
	io.ERPPlanningHorizon.isSet = false

	RETIFNOK( txrpd.dll9001.get.horizons.BOD(
			i.ERPItem,
			"",
			dummy.order.horizon.unit,	|* Ref
			dummy.order.horizon,		|* Ref
			planning.horizon.unit,		|* Ref
			planning.horizon ) )		|* Ref
			
							
	if planning.horizon.unit <> empty then
		RETIFNOK( txbod.dll9002.convert.from.erp.period.type.to.iso(
				(planning.horizon * 1.0),
				planning.horizon.unit,
				o.ERPPlanningHorizon,	|* Ref
				io.ERPPlanningHorizon.isSet ))

	endif

	return( 0 )
}


function long get.erp.order.horizon(
		domain	tcitem		i.ERPItem,
	ref	domain	tcmcs.str25	o.ERPOrderHorizon,
	ref		boolean		io.ERPOrderHorizon.isSet )
{

	domain	cpcom.hori	order.horizon
	domain	tctope		order.horizon.unit
	domain	cpcom.hori	dummy.planning.horizon
	domain	tctope		dummy.planning.horizon.unit

	o.ERPOrderHorizon = ""
	io.ERPOrderHorizon.isSet = false
 
	RETIFNOK( txrpd.dll9001.get.horizons.BOD(
			i.ERPItem,
			 "",
			order.horizon.unit,		|* Ref
			order.horizon,			|* Ref
			dummy.planning.horizon.unit,	|* Ref
			dummy.planning.horizon ) )	|* Ref

	if order.horizon.unit <> empty then
		RETIFNOK( txbod.dll9002.convert.from.erp.period.type.to.iso(
				(order.horizon * 1.0),
				order.horizon.unit,
				o.ERPOrderHorizon,	|* Ref
				io.ERPOrderHorizon.isSet ))
							

	endif

	return( 0 )
}

function long get.item.location.warehouse.classification(
		domain	tcabcc		i.ERPABCCode,
	ref	domain	tcmcs.long	o.Classification,
	ref		boolean		io.Classification.isSet )
{
		long		size.stack
		long		stack.position
		long		return.value
		string		b.type.stack(1,1) based
		string		b.value.stack(1,1) based
		string		b.code(1)	based

	#define INIT_HOOK_ON_GET_CLASSIFICATION
^		free.mem( b.type.stack )
^		free.mem( b.value.stack )
^		free.mem( b.code)

	#define ERROR_HOOK_ON_GET_CLASSIFICATION( i_RETURN_VALUE )
^		if i_RETURN_VALUE <> 0 then
^			INIT_HOOK_ON_GET_CLASSIFICATION
^			return( i_RETURN_VALUE )
^		endif

	#define CODE_ABCCODE			"ABC Codes"

	if not isspace( i.ERPABCCode ) then
		stack.position = size.stack

		return.value = txbod.dll9002.add.string.to.stack(
				CODE_ABCCODE,
				b.type.stack,	|* Ref (io)
				stack.position )|* Ref (io)

		ERROR_HOOK_ON_GET_CLASSIFICATION( return.value )

		return.value = txbod.dll9002.add.string.to.stack(
				i.ERPABCCode,
				b.value.stack,	|* Ref (io)
				size.stack )	|* Ref (io)

		ERROR_HOOK_ON_GET_CLASSIFICATION( return.value )
	endif

	return.value = txbod.dll9002.get.classification.node(
			size.stack,
			b.type.stack,					|* Ref
			b.value.stack,					|* Ref
			o.Classification,		|* Ref
			io.Classification.isSet )	|* Ref

	ERROR_HOOK_ON_GET_CLASSIFICATION( return.value )

	INIT_HOOK_ON_GET_CLASSIFICATION

	return( 0 )
}

function long set.header.indicator.must.be.updated(			|#2002920.sn
			boolean		i.update.producible.indicator,
			boolean		i.update.purchasable.indicator,
			boolean		i.update.sellable.indicator,
			boolean		i.update.stockable.indicator)
{
	|* This function sets a static variable for for the update indicators.

	handle.indicators(
		SET_VALUE,
		i.update.producible.indicator,
		i.update.purchasable.indicator,
		i.update.sellable.indicator,
		i.update.stockable.indicator)

	return(0)
}

function handle.indicators(
			long		i.method,
	ref		boolean		io.update.producible.indicator,
	ref		boolean		io.update.purchasable.indicator,
	ref		boolean		io.update.sellable.indicator,
	ref		boolean		io.update.stockable.indicator)
{
	static		boolean		s.update.producible.indicator
	static		boolean		s.update.purchasable.indicator
	static		boolean		s.update.sellable.indicator
	static		boolean		s.update.stockable.indicator

	on case i.method
	case SET_VALUE:
		s.update.producible.indicator = io.update.producible.indicator
		s.update.purchasable.indicator = io.update.purchasable.indicator
		s.update.sellable.indicator = io.update.sellable.indicator
		s.update.stockable.indicator = io.update.stockable.indicator
		break
	case GET_VALUE:
		io.update.producible.indicator = s.update.producible.indicator
		io.update.purchasable.indicator = s.update.purchasable.indicator
		io.update.sellable.indicator = s.update.sellable.indicator
		io.update.stockable.indicator = s.update.stockable.indicator
		break
	endcase
}

function long order.companies.in.array(			|#1897956.sn
|		domain	tcmcs.long	i.no.of.companies,	|#1994725.o
	ref	domain	tcmcs.long	i.no.of.companies,	|#1994725.n
		domain	tcncmp		i.current.company,
	const	domain	tcncmp		i.unsorted.shared.company.array(),
	ref	domain	tcncmp		i.shared.company.array())
{
	|* This function sorts the company array, the last company must
	|* be the current company

		long		no.of.fin.comp			|#1994725.n
		long		l.index
		long		i

	l.index = 0
	no.of.fin.comp = 0					|#1994725.n

	|* Free allocated memory.
	free.mem(i.shared.company.array)
	alloc.mem(i.shared.company.array, i.no.of.companies)

	for i = 1 to i.no.of.companies
		if i.unsorted.shared.company.array(i) = i.current.company then
			continue
		endif

		if not txemm.dll9001.is.logistic.company(	|#1994725.sn
				i.unsorted.shared.company.array(i) ) then
			no.of.fin.comp = no.of.fin.comp + 1
			continue
		endif						|#1994725.en

		l.index = l.index + 1
		i.shared.company.array(l.index) = i.unsorted.shared.company.array(i)

	endfor

	l.index = l.index + 1
	i.shared.company.array(l.index) = i.current.company
	i.no.of.companies = i.no.of.companies - no.of.fin.comp	|#1994725.n

	return(0)
}								|#1897956.en


function long set.item.location.warehouse.user.area.properties(	|#1933631.sn
		domain	tcsftm		i.safety.time,
		domain	tctope		i.safety.time.unit,
		domain	tcprct		i.service.level,
	ref	domain	tcmcs.long	o.user.area,
	ref		boolean		o.user.area.isSet)
{

	long	nr.positions
	long	dummy.value
	long	return.value

	long	dummy.stack.long(1) based
	string	name.stack(1,1) based
	string	type.stack(1,1) based
	string	value.stack(1,1) based
	string	dummy.stack.string(1,1) based

	|* Reset local and output variables.
	#define INIT_VARIABLES_ITEMLOCATION_USERAREA_PROPERTIES
^		nr.positions = 0
^		free.mem( name.stack )
^		free.mem( type.stack )
^		free.mem( value.stack )
^		free.mem( dummy.stack.long )
^		free.mem( dummy.stack.string )
^		if o.user.area <> 0 then
^			dummy.value = xmlDelete( o.user.area )
^			o.user.area = 0
^		endif
^		o.user.area.isSet = false

	#define ERROR_ITEMLOCATION_USERAREA_PROPERTIES( i_RETURN_VALUE )
^		if i_RETURN_VALUE <> 0 then
^			INIT_VARIABLES_ITEMLOCATION_USERAREA_PROPERTIES
^			return( i_RETURN_VALUE )
^		endif

	INIT_VARIABLES_ITEMLOCATION_USERAREA_PROPERTIES	

	return.value = get.item.data.by.warehouse.user.area(
			i.safety.time,
			i.safety.time.unit,
			i.service.level,
			name.stack,	|* Ref (io)
			type.stack,	|* Ref (io)
			value.stack,	|* Ref (io)
			nr.positions )	|* Ref (io)

	ERROR_ITEMLOCATION_USERAREA_PROPERTIES( return.value )

	if nr.positions > 0 then
		|* Allocate memory for dummy stacks.
		dummy.value = alloc.mem( dummy.stack.long, nr.positions )
		dummy.value = alloc.mem( dummy.stack.string, 1, nr.positions )

		return.value = txbod.dll9002.get.user.area.node(
			nr.positions,
			name.stack,
			type.stack,
			value.stack,
			dummy.stack.string,			|* Description
			dummy.stack.long,			|* Start date
			dummy.stack.long,			|* End date
			o.user.area,		|* Ref
			o.user.area.isSet )	|* Ref

		ERROR_ITEMLOCATION_USERAREA_PROPERTIES( return.value )
	endif

	free.mem( name.stack )
	free.mem( type.stack )
	free.mem( value.stack )
	free.mem( dummy.stack.long )
	free.mem( dummy.stack.string )

	return( 0 )
}								|#1933631.en

function long get.item.data.by.warehouse.user.area(		|#1933631.sn
		domain	tcsftm		i.safety.time,
		domain	tctope		i.safety.time.unit,
		domain	tcprct		i.service.level,
	ref		string		io.name.stack(,),
	ref		string		io.type.stack(,),
	ref		string		io.value.stack(,),
	ref		long		io.nr.positions )
{
		string		b.name(1) based
		string		b.type(1) based
		string		b.value(1) based
	domain	tcmcs.str25	o.iso.duration
		boolean		o.iso.duration.is.set

	#define	NR_POSITIONS	1

|	if NOT.ZERO(i.safety.time) then
	if i.safety.time <> 0  then
	
							
		RETIFNOK(txbod.dll9002.convert.from.erp.period.type.to.iso(
				i.safety.time,
				i.safety.time.unit,
				o.iso.duration,
				o.iso.duration.is.set))	
							

		SET_BASED_VARIABLE( PROP_NAME_SAFETY_LEAD_TIME, b.name )
		SET_BASED_VARIABLE( PROP_TYPE_STRING, b.type )
		SET_BASED_VARIABLE( o.iso.duration, b.value )

		allocate.memory.user.area.stacks(
			NR_POSITIONS,
			len( b.name ),
			len( b.type ),
			len( b.value ),
			io.name.stack,		|* Ref (io)
			io.type.stack,		|* Ref (io)
			io.value.stack,		|* Ref (io)
			io.nr.positions )	|* Ref (io)

		io.name.stack(1,io.nr.positions) = b.name
		io.type.stack(1,io.nr.positions) = b.type
		io.value.stack(1,io.nr.positions) = b.value
	endif

	if i.service.level <> 0 then

		SET_BASED_VARIABLE( PROP_NAME_SERVICE_LEVEL_PERCENTAGE, b.name )
		SET_BASED_VARIABLE( PROP_TYPE_INTEGER_NUMERIC, b.type )
		SET_BASED_VARIABLE( str$(i.service.level), b.value )

		allocate.memory.user.area.stacks(
			NR_POSITIONS,
			len( b.name ),
			len( b.type ),
			len( b.value ),
			io.name.stack,		|* Ref (io)
			io.type.stack,		|* Ref (io)
			io.value.stack,		|* Ref (io)
			io.nr.positions )	|* Ref (io)

		io.name.stack(1,io.nr.positions) = b.name
		io.type.stack(1,io.nr.positions) = b.type
		io.value.stack(1,io.nr.positions) = b.value
	endif

	return( 0 )
}		

function allocate.memory.user.area.stacks(
		long	i.nr.positions,
		long	i.length.name,
		long	i.length.type,
		long	i.length.value,
	ref	string	io.name.stack(,),
	ref	string	io.type.stack(,),
	ref	string	io.value.stack(,),
	ref	long	io.nr.positions )
{
	long	nr.dimensions
	long    dimension.stack(4)
	long	dummy.value

	#define	LENGTH_STACK_POSITION	dimension.stack(1)
	#define	NR_STACK_POSITIONS	dimension.stack(2)

	io.nr.positions = io.nr.positions + i.nr.positions

	|* Handle stack: io.name.stack
	array.info( io.name.stack, nr.dimensions, dimension.stack )

	if LENGTH_STACK_POSITION < i.length.name or
	   NR_STACK_POSITIONS < io.nr.positions then
		dummy.value = alloc.mem(
				io.name.stack,
				max( i.length.name, LENGTH_STACK_POSITION ),
				io.nr.positions )
	endif

	|* Handle stack: io.type.stack
	array.info( io.type.stack, nr.dimensions, dimension.stack )

	if LENGTH_STACK_POSITION < i.length.type or
	   NR_STACK_POSITIONS < io.nr.positions then
		dummy.value = alloc.mem(
				io.type.stack,
				max( i.length.type, LENGTH_STACK_POSITION ),
				io.nr.positions )
	endif

	|* Handle stack: io.value.stack
	array.info( io.value.stack, nr.dimensions, dimension.stack )

	if LENGTH_STACK_POSITION < i.length.value or
	   NR_STACK_POSITIONS < io.nr.positions then
		dummy.value = alloc.mem(
				io.value.stack,
				max( i.length.value, LENGTH_STACK_POSITION ),
				io.nr.positions )
	endif
}


function long set.item.location.user.area.properties(
		domain	tcitem		i.sales.data.item,
		domain	tcitem		i.production.data.item,
		domain	tcitem		i.costing.data.item,
		domain	tcitem		i.warehousing.data.item,
		domain	tcitem		i.project.data.item,
		domain	tcitem		i.quality.data.item,
		domain	tcitem		i.purchase.data.item,
		domain	tcitem		i.ordering.data.item,
		domain	tcitem		i.planning.data.item,
		domain	tcitem		i.service.data.item,
		domain	tcitem		i.freight.data.item,
		domain	tcitem		i.item,
		domain	tckitm		i.item.type,
		domain	tccprj		i.project,
		domain	tccuni		i.inventory.unit,	|#1933631.n
		domain	tcpric		i.sales.price,		|#1933631.n
		domain	tccuni		i.sales.price.unit,	|#1933631.n
	ref	domain	tcmcs.long	o.user.area,
	ref		boolean		o.user.area.isSet)
{

	long	nr.positions
	long	dummy.value
	long	return.value					|#1919739.n
	domain	tcpric		l.sales.price			|#1933631.sn
	domain	tcccur		dummy.currency
	domain	tciccc		l.iso.reference.currency
	domain	tciccc		dummy.iso.currency		|#1933631.en

	long	dummy.stack.long(1) based
	string	name.stack(1,1) based
	string	type.stack(1,1) based
	string	value.stack(1,1) based
	string	dummy.stack.string(1,1) based

	|* Reset local and output variables.
	#define INIT_VARIABLES_ITEMLOCATION_USERAREA_PROPERTIES	|#1919739.sn
^		nr.positions = 0
^		free.mem( name.stack )
^		free.mem( type.stack )
^		free.mem( value.stack )
^		free.mem( dummy.stack.long )
^		free.mem( dummy.stack.string )
^		if o.user.area <> 0 then
^			dummy.value = xmlDelete( o.user.area )
^			o.user.area = 0
^		endif
^		o.user.area.isSet = false

	#define ERROR_ITEMLOCATION_USERAREA_PROPERTIES( i_RETURN_VALUE )
^		if i_RETURN_VALUE <> 0 then
^			INIT_VARIABLES_ITEMLOCATION_USERAREA_PROPERTIES
^			return( i_RETURN_VALUE )
^		endif

	INIT_VARIABLES_ITEMLOCATION_USERAREA_PROPERTIES		
	
	return.value = get.sub.entity.indicators.user.area(	
			i.sales.data.item,
			i.production.data.item,
			i.costing.data.item,
			i.warehousing.data.item,
			i.project.data.item,
			i.quality.data.item,
			i.purchase.data.item,
			i.ordering.data.item,
			i.planning.data.item,
			i.service.data.item,
			i.freight.data.item,
			i.item,
			i.item.type,
			i.project,
			name.stack,	|* Ref (io)
			type.stack,	|* Ref (io)
			value.stack,	|* Ref (io)
			nr.positions )	|* Ref (io)	

	ERROR_ITEMLOCATION_USERAREA_PROPERTIES( return.value )	|#1919739.n

	|* Allocate memory for dummy stacks.
	dummy.value = alloc.mem( dummy.stack.long, nr.positions )
	dummy.value = alloc.mem( dummy.stack.string, 1, nr.positions )

	return.value = txbod.dll9002.get.user.area.node(	|#1919739.n
			nr.positions,
			name.stack,
			type.stack,
			value.stack,
			dummy.stack.string,			|* Description
			dummy.stack.long,			|* Start date
			dummy.stack.long,			|* End date
			o.user.area,		|* Ref
			o.user.area.isSet )	|* Ref		|#1919739.n
|			o.user.area.isSet ))	|* Ref		|#1919739.o

	ERROR_ITEMLOCATION_USERAREA_PROPERTIES( return.value )	|#1919739.sn

	free.mem( name.stack )
	free.mem( type.stack )
	free.mem( value.stack )
	free.mem( dummy.stack.long )
	free.mem( dummy.stack.string )				|#1919739.en

	|* only if sales data is available			|#1933631.sn
	if not isspace( i.sales.data.item ) and
|	   NOT.ZERO(i.sales.price) then
	i.sales.price <> 0 then
		if trim$(i.sales.price.unit) <> trim$(i.inventory.unit) then
|t			l.sales.price = txipu.dll9001.convert.pric.to.new.pric.unit(
|					i.sales.data.item,	|* Item,
|					i.sales.price.unit,	|* Old price unit
|					i.sales.price,		|* Price
|					i.inventory.unit,	|* New price unit
|t					domainof(tdisa001.pris))
		else
			l.sales.price = i.sales.price
		endif

		RETIFNOK( txbod.dll9002.get.local.and.reference.currency(
				get.compnr(),			|* financial company,
				dummy.currency,			|* reference currency
				l.iso.reference.currency,	|* Ref
				dummy.currency,			|* local currency
				dummy.iso.currency))		|* iso local currency

		RETIFNOK(txbod.dll9002.get.user.area.extended.node(
				UA_NAME,	PROP_NAME_SALESPRICE_AMOUNT,
				UA_TYPE,	PROP_TYPE_AMOUNT,
				UA_VALUE,	str$(l.sales.price),
				UA_ATTR_NAME,	ATTR_CURRENCY_ID,
				UA_ATTR_VALUE, 	l.iso.reference.currency,
				o.user.area,
				o.user.area.isSet))	
	endif							|#1933631.en

	return( 0 )
}

function long create.item.id.node(
	const	string	i.role,
	const	string	i.business.partner,
	const	string	i.business.partner.item.code mb,
	ref	long	o.xml.node,
	ref	long	o.xml.node.is.set )
{
	long	node.id
	domain	tcbod.name	public.noun			
	domain	tcbod.acen	bp.accounting.entity
		boolean		bp.accounting.entity.is.set	
		
	long	ret, i
	domain	tcmcs.s999m	o.ExceptionMessage
	long	o.ExceptionID

	o.xml.node = 0
	o.xml.node.is.set = false

	|* Create XML group ItemID.
	o.xml.node = xmlNewNode( "ItemID" )

	if o.xml.node = 0 then
		dal.set.error.message(	"tcgens0025", "ItemID" )
		|* tcgens0025  ???
		return( DALHOOKERROR )
	endif

	|* Add element ID to XML group ItemID.
	node.id = xmlNewDataElement(
			"ID",
			trim$( i.business.partner.item.code ),
			o.xml.node )

	if node.id = 0 then
		dal.set.error.message( "tcgens0025", "ID" )
		|* tcgens0025  ???
		return( DALHOOKERROR )
	endif

	|* Add attribute schemeName to element ID
	if xmlSetAttribute( node.id, "schemeName", trim$( i.role )) = 0 then
		dal.set.error.message( "tcgens0026", "schemaName", i.role )
		|* tcgens0026  ???
		return( DALHOOKERROR )
	endif

	|* Add attribute schemeAgencyID to element ID.
	if xmlSetAttribute(
			node.id,
			"schemeAgencyID",
			trim$( i.business.partner )) = 0 then
		dal.set.error.message(
			"tcgens0026",
			|* tcgens0026  ???
			"schemeAgencyID",
			trim$( i.business.partner ))
		|* Creation attribute '%1$s' of XML element '%2$s' failed.
		return( DALHOOKERROR )
	endif
								|#1857402.sn
	on case i.role
	case SOLD_TO:
		public.noun = "CustomerPartyMasterBOD"
		break
	case BUY_FROM:
		public.noun = "SupplierPartyMasterBOD"
		break
	default:
		dal.set.error.message(	"tcbods0210",
		|* tcbods0210  ???
					trim$(public.noun))
		return(DALHOOKERROR)
	endcase
|							|* ValOP2CE_01.so
|	RETIFNOK( tcbod.dll0041.get.accounting.entity(
|			get.compnr(),			|* Logical company
|			public.noun,			|* Public noun
|			i.business.partner,		|* Public noun identifier
|			bp.accounting.entity,		|* Ref
|			bp.accounting.entity.is.set) )	|* Ref
							|* ValOP2CE_01.eo
			
							|* ValOP2CE_01.sn
		ret =  BOD.GetIdAccountingEntity(
			 get.compnr(),
			 public.noun,
			 0,
			 i.business.partner,
			 "tcmcs003",
			 bp.accounting.entity,
			 bp.accounting.entity.is.set,
			 o.ExceptionMessage,
			 o.ExceptionID )
				
		if ret <> 0 then
		|* Exception(s) found.
			for i = 1 to Exception.NumberOfMessages(o.ExceptionID)
				dal.set.error.message("@"& o.ExceptionMessage(i))
			endfor
			Exception.Delete(o.ExceptionID)
			return(DALHOOKERROR)
		endif					|* ValOP2CE_01.en

	if xmlSetAttribute(
			node.id,
			"accountingEntity",
			trim$( bp.accounting.entity )) = 0 then
		dal.set.error.message(
			"tcgens0026",
			|* tcgens0026  ???
			"accountingEntity",
			trim$( bp.accounting.entity ))
		|* Creation attribute '%1$s' of XML element '%2$s' failed.
		return( DALHOOKERROR )
	endif	
							|#1857402.en
	o.xml.node.is.set = true

	return( 0 )
}


function get.supplier.item(	domain	tccom.bpid	i.ship.from.bp,
				domain	tccom.bpid	i.buy.from.bp,
				domain	tcitem		i.item,
				domain	tccitt		i.item.code.system,
			ref	domain	tccom.bpid	o.supplier,
			ref	domain	tcaitm		o.supplier.item)
{
	long	ret

		domain	tccitt		item.code.system
		domain	tccom.bpid	buy.from.bp

	static	domain	tcitem		stat.item
	static	domain	tccom.bpid	stat.ship.from.bp
	static	domain	tccom.bpid	stat.buy.from.bp
	static	domain	tcitem		stat.supplier.item
	static	domain	tccom.bpid	stat.supplier

	item.code.system = ""
	o.supplier.item = ""

	if stat.item = i.item			and
	   stat.ship.from.bp = i.ship.from.bp	and
	   stat.buy.from.bp = i.buy.from.bp	then
		o.supplier.item = stat.supplier.item
		o.supplier = stat.supplier
		return
	endif

|t	STOP.MESSAGES

	if isspace(i.item.code.system) then
		ret = txibd.dll9001.default.business.partner.item.code(
				i.ship.from.bp,
				item.code.system)	
	else
		item.code.system = i.item.code.system
	endif

	if not isspace(item.code.system) then

		ret = txibd.dll9001.tcibd004.read.alternative.item.code(
				i.item,
				item.code.system,
				i.ship.from.bp,
				o.supplier.item)	
		o.supplier = i.ship.from.bp
	endif

	if isspace(o.supplier.item) then
		if isspace(i.buy.from.bp) then
			txcom.dll9001.determine.default.buy.from(
				i.ship.from.bp,
				buy.from.bp)
		else
			buy.from.bp = i.buy.from.bp
		endif

		o.supplier = buy.from.bp

		if i.ship.from.bp <> buy.from.bp then

			ret = txibd.dll9001.default.business.partner.item.code(
					buy.from.bp,
					item.code.system)
							

			if not isspace(item.code.system) then
				ret = txibd.dll9001.tcibd004.read.alternative.item.code(
					i.item,
					item.code.system,
					buy.from.bp,
					o.supplier.item)
							
			endif
		endif
	endif

	stat.item = i.item
	stat.ship.from.bp = i.ship.from.bp
	stat.buy.from.bp = i.buy.from.bp
	stat.supplier.item = o.supplier.item
	stat.supplier = o.supplier

|t	START.MESSAGES
}

function get.customer.item(	domain	tccom.bpid	i.ship.to.bp,
				domain	tccom.bpid	i.sold.to.bp,
				domain	tcitem		i.item,
				domain	tccitt		i.item.code.system,
			ref	domain	tccom.bpid	o.customer,
			ref	domain	tcaitm		o.customer.item)
{
	long	ret

		domain	tccitt		item.code.system
		domain	tccom.bpid	sold.to.bp

	static	domain	tcitem		stat.item
	static	domain	tccom.bpid	stat.ship.to.bp
	static	domain	tccom.bpid	stat.sold.to.bp
	static	domain	tcitem		stat.customer.item
	static	domain	tccom.bpid	stat.customer

	item.code.system = ""
	o.customer.item = ""

	if stat.item = i.item			and
	   stat.ship.to.bp = i.ship.to.bp	and
	   stat.sold.to.bp = i.sold.to.bp	then
		o.customer.item = stat.customer.item
		o.customer = stat.customer
		return
	endif

|t	STOP.MESSAGES

	if isspace(i.item.code.system) then
		txwmd.dll9001.get.business.partners.packaging.item.code(
				i.item,
				i.ship.to.bp,
				i.sold.to.bp,
				o.customer.item,
				o.customer)			

	else
		item.code.system = i.item.code.system
	endif

	if not isspace(item.code.system) then

		ret = txibd.dll9001.tcibd004.read.alternative.item.code(
				i.item,
				item.code.system,
				i.ship.to.bp,
				o.customer.item)	
		o.customer = i.ship.to.bp
	endif

	if isspace(o.customer.item) then
		if isspace(i.sold.to.bp) then
			txcom.dll9001.determine.default.sold.to(
					i.ship.to.bp,
					sold.to.bp)
		else
			sold.to.bp = i.sold.to.bp
		endif

		o.customer = sold.to.bp

		if i.ship.to.bp <> sold.to.bp then

			ret = txibd.dll9001.default.business.partner.item.code(
					sold.to.bp,
					item.code.system)
							
			if not isspace(item.code.system) then

				ret = txibd.dll9001.tcibd004.read.alternative.item.code(
					i.item,
					item.code.system,
					sold.to.bp,
					o.customer.item)
							
			endif
		endif
	endif

	stat.item = i.item
	stat.ship.to.bp = i.ship.to.bp
	stat.sold.to.bp = i.sold.to.bp
	stat.customer.item = o.customer.item
	stat.customer = o.customer

|t	START.MESSAGES
}


function long get.root.table(
	ref	string	o.root.table )
{
	FunctionUsage
	Expl:	The purpose of this function is to return the root table of the
		'ItemMasterCommon' BOD.
	Pre:	N.a.
	Post:	N.a.
	Input:	N.a.
	Output:	o.root.table
	Return:	0/DALHOOKERROR
	EndFunctionUsage

	o.root.table = "tcibd001"

	return( 0 )
}
								
function long handle.business.partner.external.item.codes(
	const	string	i.business.partner,
	const	string	i.business.partner.item.code mb,
	ref	long	o.ItemMasterHeader_ItemID(),
	ref	boolean	o.ItemMasterHeader_ItemID.isSet(),
	ref	long	o.ItemMasterHeader_ItemID.size )
{
	long	xml.node
	boolean	xml.node.is.set

	|* Add schemeName Customer if sold to role is present.
	if txcom.dll9001.sold.to.bp.present( i.business.partner ) then
		RETIFNOK( create.item.id.node(
				SOLD_TO,
				i.business.partner,
				i.business.partner.item.code,
				xml.node,		|* Ref
				xml.node.is.set ))	|* Ref

		|* Put the XML nod on the stack if filled.
		if xml.node.is.set then
			RETIFNOK( txbod.dll9002.add.node.to.stack(
					xml.node,
					o.ItemMasterHeader_ItemID,	 |* Ref
					o.ItemMasterHeader_ItemID.isSet, |* Ref
					o.ItemMasterHeader_ItemID.size ))|* Ref
		endif
	endif

|* Under discussion, therefore disabled for now.

	|* Add schemeName Supplier if buy from role is present.
	if txcom.dll9001.buy.from.bp.present( i.business.partner ) then
		RETIFNOK( create.item.id.node(
				BUY_FROM,
				i.business.partner,
				i.business.partner.item.code,
				xml.node,		|* Ref
				xml.node.is.set ))	|* Ref
		|* Put the XML nod on the stack if filled.
		if xml.node.is.set then
			RETIFNOK( txbod.dll9002.add.node.to.stack(
					xml.node,
					o.ItemMasterHeader_ItemID,	 |* Ref
					o.ItemMasterHeader_ItemID.isSet, |* Ref
					o.ItemMasterHeader_ItemID.size ))|* Ref
		endif
	endif

|* Under discussion, therefore disabled for now.

	return( 0 )
}

function long set.attributes(
				long		i.xml.node,
			const	string		i.element.name,
			domain	tcbod.acen	i.accounting.entity,
				boolean		i.accounting.entity.is.set,
			domain	tcbod.lctn	i.location,
				boolean		i.location.is.set,
			domain	tcbod.loid	i.lid,
				boolean		i.lid.is.set)
{
	if i.accounting.entity.is.set then
		NEW_ATTRIBUTE(	i.xml.node,
				i.element.name,
				"accountingEntity",
				i.accounting.entity)
	endif

	if i.location.is.set then
		NEW_ATTRIBUTE(	i.xml.node,
				i.element.name,
				"location",
				i.location)
	endif

	if i.lid.is.set then
		NEW_ATTRIBUTE(	i.xml.node,
				i.element.name,
				"lid",
				i.lid)
	endif

	return(0)
}

function long check.supported.attribute.name(	
				const	string	i.property.type,
				const	string	i.attr.name)
{
	boolean	error.set
	
	error.set = false
	
	on case trim$(i.property.type)
	case	PROP_TYPE_AMOUNT:
		if i.attr.name <> ATTR_CURRENCY_ID then
		   	error.set = true
		endif
		break
	case	PROP_TYPE_CODE:
		if i.attr.name <> ATTR_LIST_ID			and
		   i.attr.name <> ATTR_ACCOUNTING_ENTITY	then
		   	error.set = true
		endif
		break
	case	PROP_TYPE_MASTERDATA_REFERENCE:
		if i.attr.name <> ATTR_NOUN_NAME		and
		   i.attr.name <> ATTR_REVISION_ID		and
		   i.attr.name <> ATTR_ACCOUNTING_ENTITY	then
		   	error.set = true
		endif
		break
	case	PROP_TYPE_QUANTITY:
		if i.attr.name <> ATTR_UNIT_CODE then
		   	error.set = true
		endif
	endcase
	
	if error.set then
		dal.set.error.message( "txbods0068", i.attr.name, i.property.type )
		|* txbods0068  ???
		return(DALHOOKERROR)
	endif
	
	return(0)
}

function long check.supported.property.type(	const	string	i.property.type)
{
	on case trim$(i.property.type)
	case	PROP_TYPE_AMOUNT:
	case	PROP_TYPE_CODE:
	case	PROP_TYPE_DATE:
	case	PROP_TYPE_DATETIME:
	case	PROP_TYPE_INDICATOR:
	case	PROP_TYPE_INTEGER_NUMERIC:
	case	PROP_TYPE_MASTERDATA_REFERENCE:
	case	PROP_TYPE_NUMERIC:
	case	PROP_TYPE_QUANTITY:
	case	PROP_TYPE_STRING:
	case	PROP_TYPE_TIME:
		break
	default:
		dal.set.error.message( "txbods0065", trim$(i.property.type) )
		|* txbods0065  ???
		return(DALHOOKERROR)
	endcase
	
	return(0)
}

function long convert.value(	const	string	i.property.type,
				const	string	i.value,
			ref	boolean		o.skip,
			ref	string		o.value())
{
	string	iso.date(30)

	free.mem( o.value )
	o.skip = false

	on case trim$( i.property.type )
	case PROP_TYPE_DATETIME:
		if lval( i.value ) = 0 then
			o.skip = true
		else
							|* ValOP2CE_01.so						
|			RETIFNOK(tlbct.interface.utc.to.string(	
|					lval( i.value ),
|					iso.date))
							|* ValOP2CE_01.eo
							
			|* Replaced with utc.to.iso()				
			iso.date = utc.to.iso(lval( i.value ))	|* ValOP2CE_01.n

			SET_BASED_VARIABLE( iso.date, o.value ) |* Ref
		endif

		break
	case PROP_TYPE_DATE:
		if lval( i.value ) = 0 then
			o.skip = true
		else
							|* ValOP2CE_01.so						
|			RETIFNOK(tlbct.interface.date.to.string(	
|					lval( i.value ),
|					iso.date))
							|* ValOP2CE_01.eo
							
			|* Replaced with date.to.iso()				
  			iso.date = date.to.iso(lval( i.value ))	|* ValOP2CE_01.n

			SET_BASED_VARIABLE( iso.date, o.value ) |* Ref
		endif

		break
	case PROP_TYPE_TIME:
		if isspace( i.value ) then
			o.skip = true

			break
		endif

		|* Continue with 'default' to set o.value.
	default:
		|* Type of variable i.value is string.
		SET_BASED_VARIABLE( i.value, o.value ) |* Ref

		break
	endcase

	return(0)
}



function long get.default.warehouse.BOD(	
				domain	tcitem	i.item,
				domain	tccwar	i.warehouse,
			ref	domain	tccwar	o.default.warehouse)
{
	FunctionUsage
	Expl:	This function retrives the plan item's default warehouse.
		The function cprpd.dll0010.get.plan.item.BOD determines the Plan
		Item.
	Pre:	N.A
	Post:	N.A
	Input:	i.item			-	Item
		i.warehouse		-	Warehouse (could be empty)
	Output:	o.default.warehouse	-	Default Warehouse
	Return: 0			-	Ok
		DALHOOKERROR		-	Plan Item not found
	Source : tcint.dllcprpd.get.default.warehouse.BOD
	EndFunctionUsage

	domain	cpitem	plan.item
	domain	tcncmp	site

	o.default.warehouse = ""
	site = get.compnr()
	|----------------------------------------------------------------------
	|* Empty Cluster passed on (does not matter as only the item code is
	|* required to retrieve the item ordering data).
	|----------------------------------------------------------------------
|t	if get.order.system(
|			CREATE.PLAN.ITEM( i.item ) ) <> tcosys.mps then
|		return(DALHOOKERROR)
|	endif
	RETIFNOK(
		txrpd.dll9001.get.plan.item.by.item.warehouse(
					site,
					i.item,
					i.warehouse,
					plan.item)
 		)

	o.default.warehouse = txrpd.dll9001.get.plan.item.warehouse(
					plan.item,
					site)
	return(0)
} 								

function domain tcosys get.order.system(
		domain	cpitem		i.plan.item )
{
	if not get.item.ordering.data(
			get.compnr(),
			GET.PLAN.ITEM.ITEM( i.plan.item ) ) then
		return( empty )
	endif

	return( g.ibd200.osys )
}

function domain tccwar get.warehouse(
		domain  cpitem  i.plni )
{

	domain	tccwar	warehouse

	warehouse = ""

	if get.item.ordering.data( get.compnr(),
			GET.PLAN.ITEM.ITEM( i.plni ) ) then
		warehouse = g.ibd200.cwar
	endif

	return( warehouse )
}
function  domain tcemm.clus get.cluster(
		domain	tcncmp		i.site,
		domain	tccwar		i.warehouse )
{
	FunctionUsage
	Expl:	Get the cluster of the warehouse.
	Pre:
	Post:
	Input:	i.site, logistical site code
		i.cwar, warehouse code
	Output:	cluster code (returns "" if no cluster found)
	Return:	cluster code
	EndFunctionUsage

	domain	tcemm.clus	cluster fixed

	if not txemm.dll9001.get.cluster.of.warehouse(i.warehouse,
						i.site,
						cluster,
						false) 	
	then
		cluster = ""
	endif
	
	return( cluster )
}

function long get.plan.item.data(
				domain	cpitem	i.plan.item,
				domain	tcncmp	i.company )
{
	long	index

	PLAN_ITEM_FIELD_DEFINITION

	|* First check the last index
	if last.index > 0 and
	   g.plan.items( 1, last.index ) = i.plan.item and
	   last.company = i.company then
		return( last.index )
	endif

	if last.company = i.company then

		|* It was not the last index, check the cache.
		for index = 1 to MAX_CACHE
			if isspace( g.plan.items( 1, index ) ) then

				|* cache position is empty, stop searching
				break
			endif

			|* Check if the item is found
			if g.plan.items( 1, index ) = i.plan.item and
			   g.companies( index ) = i.company then
				return( index )
			endif
		endfor
	endif

	|* Plan Item is not found in the cache, let's try the table
	select	SELECT_PLAN_ITEM_DATA
	from	cprpd100
	where	cprpd100._index1 = { :i.plan.item }
	and	cprpd100._compnr = :i.company
	as set with 1 rows
	selectdo
		STORE_PLAN_ITEM_DATA

		return( last.index )
	endselect

	return( 0 )
}

function void determine.action.code(
			domain	tcmcs.long	i.mode,
		ref	domain	tcmcs.str10	o.action.code)
{
	on case i.mode
	case DAL_NEW:
		o.action.code = ACTION_CODE_ADD
		break
	case DAL_UPDATE:
		o.action.code = ACTION_CODE_REPLACE
		break
	case DAL_DESTROY:
		o.action.code = ACTION_CODE_REPLACEDELETE
		break
	endcase
	
}


function long check.subscription.exists(
	const		long		i.company,
	const	domain	tcbod.uvrb	i.use.verb,
	const		string		i.bod )
{
	#define RESET_ROUTINE_CHECK_SUBSCRIPTION_EXISTS( i_RETURN_VALUE )
^		dummy.value = xmlDelete( xml.publishable.event.actions )
^		xml.publishable.event.actions = 0
^		free.mem( b.data )
^
^		return( i_RETURN_VALUE )

		long		xml.publishable.event.actions
		long		return.value
		long		dummy.value
		string		b.data(1) based
	domain	tcmcs.str70	public.bod

	|* Get XML with publishable event actions.
	RETIFNOK( get.xml.publishable.event.actions(
			i.bod,
			xml.publishable.event.actions ))	|* Ref

	if xml.publishable.event.actions > 0 then
		if xmlAllocData(
				b.data,	|* Ref
				xml.publishable.event.actions ) <> 0 then
			dal.set.error.message( "txbods0036" )
			|* txbods0036  ???

			RESET_ROUTINE_CHECK_SUBSCRIPTION_EXISTS( DALHOOKERROR )
		endif

		return.value = txbod.dll9002.get.bod.public(
				i.bod,
				public.bod )	|* Ref

		if return.value <> 0 then
			RESET_ROUTINE_CHECK_SUBSCRIPTION_EXISTS( return.value )
		endif

		public.bod = txbod.dll9002.convert.noun.name.to.without.bod(
				public.bod )

		on case i.use.verb
		case PD_USE_VERB_SHOW:
			if pos( b.data, VERB_SHOW ) > 0 then
				|* 'Show'-method is implemented.
				if txbod.dll9002.subscription.exists(
						i.company,
						i.bod,
						VERB_SHOW ) then
				    RESET_ROUTINE_CHECK_SUBSCRIPTION_EXISTS( 0 )
				else
				    dal.set.error.message(
					"txbods0109",
					|* txbods0109  ???
					VERB_SHOW,
					public.bod,
					i.company )
				    |* No subscription exists for Verb '%1$s',
				    |* Noun '%2$s' and Company '%3$d'.
				endif
			endif

			break
		case PD_USE_VERB_PROCESS_SYNC:
			STORE.MESSAGES

			if pos( b.data, VERB_SYNC ) > 0 then
				|* 'Sync'-method is implemented.
				if txbod.dll9002.subscription.exists(
						i.company,
						i.bod,
						VERB_SYNC ) then
				    RESET_ROUTINE_CHECK_SUBSCRIPTION_EXISTS( 0 )
				else
				    dal.set.error.message(
					"txbods0109",
					|* txbods0109  ???
					VERB_SYNC,
					public.bod,
					i.company )
				    |* No subscription exists for Verb '%1$s',
				    |* Noun '%2$s' and Company '%3$d'.
				endif
			endif

			if pos( b.data , VERB_PROCESS ) > 0 then
				|* 'Process'-method is implemented.
				if txbod.dll9002.subscription.exists(
						i.company,
						i.bod,
						VERB_PROCESS ) then
					|* Subscription found. Reset
					RESTORE.MESSAGES

				    RESET_ROUTINE_CHECK_SUBSCRIPTION_EXISTS( 0 )
				else
				    |* Set error messages for checked verbs.
				    dal.set.error.message(
					"txbods0109",
					|* txbods0109  ???
					VERB_PROCESS,
					public.bod,
					i.company )
				    |* No subscription exists for Verb '%1$s',
				    |* Noun '%2$s' and Company '%3$d'.
				endif
			endif

			break
		default:
			ASSERT(	false,
				"Use Verb '" &
				enum.descr$( "tcbod.uvrb", i.use.verb ) &
				|* tcbod.uvrb  ???
				"' is not supported." )

			break
		endcase
	else
		dal.set.error.message(
			"txbods0109",
			|* txbods0109  ???
			VERB_SYNC & "/" & VERB_PROCESS,
			public.bod,
			i.company )
		|* No subscription exists for Verb '%1$s', Noun '%2$s' and
		|* Company '%3$d'.
	endif

	|* Return error message. Error messages already set.
	RESET_ROUTINE_CHECK_SUBSCRIPTION_EXISTS( DALHOOKERROR )
}
function long get.xml.publishable.event.actions(
	const	string	i.bod,
	ref	long	o.xml.event.actions )
{
	long	dll.id
	long	function.id
	string	function.name(LENGTH_FUNCTION_NAME)
	string	dll.code(LENGTH_DLL_CODE)
	string	object.code(LENGTH_OBJECT_CODE)

	o.xml.event.actions = 0

	RETIFNOK( get.code.bod.dll( "st", i.bod, dll.code ))
		|* Ref: dll.code

	object.code = "o" & trim$( dll.code )

	|* Load the DLL.
	dll.id = load_dll( object.code )

	if dll.id = 0 then
		dal.set.error.message( "txbods0016", dll.code )
		|* No unit found for ISO Code %1$s.

		return( DALHOOKERROR )
	endif

	|* Load the function.
	function.name = "GetPublishableEventActions"

	function.id = get_function(
			dll.id,
			dll.code(1;5) & "." &		|* E.g.: boinh.
			trim$( dll.code(6) ) & "." &	|* E.g.: bl810st00.
			trim$( function.name ))

	if function.id = 0 then
		|* Function not found. No publishable event actions present.
		return( 0 )
	endif

	|* Execute the function.
	RETIFNOK(txbod.dll9002.check.return.of.exec(
			exec_function(
				dll.id,
				function.id,
				o.xml.event.actions ),	|* Ref
			dll.code,
			function.name ))

	return( 0 )
}
function long get.code.bod.dll(
		string	i.visibility(2),
	const	string	i.bod,
	ref	string	o.code )
{
	string	identifier(8)

	o.code = ""

	RETIFNOK( txbod.dll9002.get.bod.identifier(
			i.bod,
			identifier ))	|* Ref

	o.code = identifier(1;5) & "bl" & identifier(6;3) &
		 trim$( i.visibility ) & "00"

	return( 0 )
}


function long determine.logical.id(
				domain	tcncmp		i.company,
				domain	tcmcs.str50	i.verb,
				domain	tcbod.name	i.noun,
			ref	domain	tcbod.loid	o.logical.id)
{
	long	len.noun

	domain	tcbod.name	noun
	domain	tcmcs.str132m	error.mess

	long	i
	static	domain	tcmcs.long	cache.counter

	static	domain	tcncmp		s.company(1)		based
	static	domain	tcmcs.str50	s.verb(1)		based
	static	domain	tcbod.name	s.noun(1)		based
	static	domain	tcbod.loid	s.logical.id(1)		based

	static	long			s.tcmcs.str50.length
	static	long			s.tcbod.name.length
	static	long			s.tcbod.loid.length
	static	boolean			s.domain.read

	if not s.domain.read then
		s.tcmcs.str50.length = txcom.dll9001.domain.length(
							"tcmcs.str50")
		s.tcbod.name.length = txcom.dll9001.domain.length(
							"tcbod.name")
		s.tcbod.loid.length = txcom.dll9001.domain.length(
							"tcbod.loid")
		s.domain.read = true
	endif

	for i = 1 to cache.counter
		if s.company(i)	= i.company		and
		   trim$(s.verb(1,i)) = trim$(i.verb)	and
		   trim$(s.noun(1,i)) = trim$(i.noun)	then
			o.logical.id = s.logical.id(1,i)

			return(0)
		endif
	endfor

	cache.counter = cache.counter + 1
	if alloc.mem(	s.company,
			cache.counter) <> 0 or
	   alloc.mem(	s.verb,
			s.tcmcs.str50.length,
			cache.counter) <> 0 or
	   alloc.mem(	s.noun,
			s.tcbod.name.length,
			cache.counter) <> 0 or
	   alloc.mem(	s.logical.id,
			s.tcbod.loid.length,
			cache.counter) <> 0 then
		dal.set.error.message( "txbod0001" )
		|* txbod0001  ???

		return( DALHOOKERROR )
	endif

	len.noun = pos(i.noun, "BOD") - 1
	if len.noun < 1 then
		len.noun = len(i.noun)
	endif
	noun = i.noun(1;len.noun)

	o.logical.id = ""
|c	o.logical.id = esb.admin.get.logicalid.for.company(
|						i.company,
|						noun,
|						i.verb,
|c						error.mess)
	if isspace(o.logical.id) then
		dal.set.error.message("@" & error.mess)
		return(DALHOOKERROR)
	endif

	s.company(cache.counter)	= i.company
	s.verb(1,cache.counter)		= i.verb
	s.noun(1,cache.counter)		= i.noun
	s.logical.id(1,cache.counter)	= o.logical.id

	return(0)
}

function boolean get.financial.company.of.entity(
		domain	tcncmp		i.logistic.company,
		domain	tcemm.enty	i.entity.type,
		domain	tcemm.enio	i.entity,
	ref	domain	tcncmp		o.financial.company)
{
	FunctionUSAGE
	EXPL:	Get the financial company of the enterprise unit linked to
		entity.
	PRE:	-
	POST:	The output value is not defined in case the key entity is
		not found.
	INPUT:	i.logistic.company, company number
		i.entity type, entity type
		i.entity, entity
	OUTPUT:	o.financial.company, financial company of the enterprise unit
				     linked to the entity.
	RETURN:	true, financial company is found; false otherwise.
	ENDFunctionUSAGE

	domain	tcemm.grid	enterprise.unit

	if txemm.dll9001.get.enterprise.unit.of.entity(
					i.entity.type,
					i.logistic.company,
					i.entity,
					enterprise.unit ) and
	   txemm.dll9001.get.enterprise.unit.financial.company(
					enterprise.unit,
					o.financial.company ) then
		return( true )
	endif

	return( false )
}

function long retrieve.workcenter.of.default.routing(
					domain	tcqiv2		i.quan,
					domain	tcitem		i.item fixed,
					domain  tcuef.effn 	i.effn,
				ref	domain	tccwoc		o.cwoc fixed)
{
	Functionusage
	Expl:	To return the work center of the last operation of the
		default routing of a specified item/quantity combination.
		Effectivity of the routing is checked against the current date.
	Pre:
	Post:
	Input:  - i.quan -> Quantity that must be checked
		- i.item -> The main item of the routings to be searched
	Output: - o.cwoc -> The work center of the last operation ot the
			    default routing that was selected. When no
			    default routing can be found, a DALHOOKERROR is
			    returned. When the default routing has no
			    operations an empty work center is returned.
	Return Val: 0		 - workcenter determined(may be empty in case no
				   operations for the routing).
		    DALHOOKERROR - routing not found for item/quantity
		    		   combination.
	Source DLL : tirou.dll0002.retrieve.workcenter.of.default.routing
	EndFunctionusage

	domain	tiqro1		dummy.runi	| routing unit
	domain	tcitem		dummy.mitm	| itm for rou102
	domain	tirou.opro	dummy.opro	| routing rou102
	domain	tirou.opro	default.opro	| default opro
	domain	tcdate		search.date	| current date for searching

	RETIFNOK(determine.routing(
					i.quan,
					i.item,
					i.effn,
					dummy.runi,
					dummy.mitm,
					default.opro,
					dummy.opro))
	if isspace(default.opro) then
		dal.set.error.message(				
			"txrous0017",
			|* txrous0017  ???
			trim$(i.item),
			i.effn)
		|* No Default Routing found for Item %1$s,
		|* Effectivity Unit %2$d 			
		return(DALHOOKERROR)
	else
		search.date = utc.num()
		select	tirou102.cwoc:o.cwoc,
			tirou102.mitm, tirou102.opro, tirou102.opno,
			tirou102.seqn	| these fields selected due to order by
		from	tirou102
		where  	tirou102._index1 = {:i.item, :default.opro}
		and	((tirou102.indt <= :search.date) and
			(tirou102.exdt >  :search.date))
		and	not exists (
				select	rou102.*
				from	tirou102 rou102
				where	rou102._index1 = {tirou102.mitm,
						  tirou102.opro,
						  tirou102.opno}
				and    ((rou102.indt <= :search.date)and
					(rou102.exdt >  :search.date))
				and	rou102.seqn < tirou102.seqn
				    )
		order by tirou102._index1 desc
		as set with 1 rows		|* For Performance
		selectdo
		selectempty
			o.cwoc = ""
		endselect
	endif
	return(0)
}

function long determine.routing(
			domain	tiqep1	   i.quantity,
			domain	tcitem	   i.item,
			domain	tcuef.effn i.eff.unit,
		ref	domain	tiqro1	   o.routing.unit,
		ref	domain	tcitem	   o.rou102.mitm,|itm for rou102
		ref	domain	tirou.opro o.rou101.opro,|routing rou101
		ref	domain	tirou.opro o.rou102.opro)|routing rou102
{
	Functionusage
	Expl.	: A routing determined based on one of the following
		  conditions.
		  1. If the order method is fixed order quantity then the
		     quantity will be updated with fixed order quantity
		     of the item else it updates with the economic order
		     quantity of the item ordering data.
		  2. If item is order quantity dependent then
		     it determines the quantity dependent routing.
		  3. If the routing is empty then default routing will be
		     determine.
	 	  4. If routing is specified and Standard routing is "yes"
		     then standard routing will be determined.
		  5. If routing is specified and standard routing is "no"
		     then it will determine routing which is Non-standard
		     routing from table tirou101.opro.
		  6. If effectivity unit number is not equal to 0, then it is
		     checked whether the determined routing is valid for that
		     unit. Only valid routing is returned.
	Pre	: -
	Post	: -
	Input	: i.quantity		- Quantity.
		  i.item		- Main item.
		  i.eff.unit		- Effectivity unit number.
	Output	: o.routing.unit	- Routing unit.
		  o.rou102.mitm		- main item for rou102
		  o.rou101.opro		- routing for rou101
		  o.rou102.opro		- routing for rou102
		  0/DALHOOKERROR
	Source Dll : tirou.dll1004.determine.routing
	EndFunctionusage

	|* Declaration of local variables.
	boolean		qty.dep.routing		|* Order-Quantity Dependent.
	domain	tiqep1	quantity		|* Quantity.
	domain	tcyesno	exceptions.present	|* Exceptions Present.
	domain	tcyesno	stand.configuration	|* Standard Configuration.
	domain	tcdsca	dummy.dsca		|* Dummy Variable.

	|* Get Routing parameters
	read.tirou000()

	|* Initialize variables.
	quantity = i.quantity
	o.rou101.opro = ""
	o.rou102.opro = ""
	o.routing.unit = 1
	o.rou102.mitm = i.item

	|* Read quantity dependent routing.
	qty.dep.routing = quantity.dependent.routing(
					i.item)

	|*  1. If the order method is fixed order quantity then the
	|*     quantity will be updated with fixed order quantity
	|*     of the item else it updates with the economic order
	|*     quantity of the item ordering data.
|	if	IS.ZERO(quantity)				
	if txmcs.dll9001.double.cmp.equal.to("tiqep1","tiqep1",quantity,0.0)  |* IS ZERO
	then RETIFNOK(txrou.dll9001.determine.order.qty(
					i.item,
					quantity))
	endif

	|*  2. If item is order quantity dependent then
	|*     it determines the quantity dependent routing.
	if	qty.dep.routing
	then	|* Order-Quantity Dependent Routing
		quantity.dependent.routing(
					i.item)
		|* To return the proper routing according to the quantity and
		|*    effectivity unit(if i.effn > 0) entered.
	endif

	|*  3. If the routing is empty then default routing will be
	|*     determined.
	if 	isspace(o.rou101.opro)
	and	found.routing.code(
					i.item,
					tirou000.dfrt,
					dummy.dsca)
	then
		o.rou101.opro = tirou000.dfrt	|* Default Routing
		select	tirou101.stcf:stand.configuration,
			tirou101.unef:exceptions.present
		from	tirou101		|* Routing Code by Item
		where	tirou101._index1 = {:i.item,
					    :o.rou101.opro}
		as set with 1 rows
		selectdo
	|*  6. If effectivity unit number is not equal to 0, then it is
	|*     checked whether the determined routing is valid for that
	|*     unit. Only valid routing is returned.
			if 	not rou.code.valid.for.unit(
					i.item,
					o.rou101.opro,
					stand.configuration,
					exceptions.present,
					i.eff.unit)
			then	o.rou101.opro = ""
			endif
		endselect
	endif

	if 	not isspace(o.rou101.opro)
	then	txrou.dll9001.fill.item.routing.runi(
					i.item,
					o.rou101.opro,
					o.rou102.mitm,
					o.rou102.opro,
					o.routing.unit)
	|* This function returns the item routing and routing quantity
	|* for a given manufactured item and routing. Routing and routing
	|* quantity will be retrieved from Routing Code by Item
	|* (tirou101).

	|*  4. If routing is specified and Standard routing is "yes"
	|*     then standard routing will be determined.
	|*  5. If routing is specified and standard routing is "no"
	|*     then it will determine routing which is Non-standard
	|*     routing from table tirou101.opro.
	endif
	if 	isspace(o.rou102.opro)
	then	o.rou102.opro = o.rou101.opro
	endif

	return(0)
}

function read.tirou000()
{
	Functionusage
	Expl.	: Must check whether the Routing (ROU) parameters have been set
		  with a proper default Routing Code or not. If not, then a
		  message is displayed and the process is terminated.
	Pre	: -
	Post	: -
	Input	: -
	Output	: -
	Return	: Void.
	EndFunctionusage

	RETURN_IF_ALREADY_READ

	if txmcs.dll9001.read.parm("tirou000") <> 0 then
		emergency.exit(form.text$("tirous0000"))
		|* tirous0000  ???
	endif
}

function boolean quantity.dependent.routing(
					domain	tcitem	i.item)
{
	Functionusage
	Expl.	: This function checks if the item has a quantity dependent
		  routing defined.
	Pre	: -
	Post	: -
	Input	: i.item	- Item.
	Output	: -
	Return	: True	- Quantity Dependent Routing.
		  False - No Quantity Dependent Routing.
	Source Dll : tiipd.dll0003.quantity.dependent.routing
	EndFunctionusage

	|* Declaration of local variables.
		domain	tcncmp	current.company		|* Current Company.
	static	domain	tcncmp	hold.company		|* Hold Company.
	static	domain	tcitem	hold.item		|* Hold Item.
	static	domain	tcyesno	hold.qty.dep.routing	|* Hold Result.

	current.company = get.compnr()
	if	i.item <> hold.item
	  or	current.company <> hold.company
	then	hold.qty.dep.routing = tcyesno.no
		if	not isspace(i.item)
		then	select	tiipd001.oqdr:hold.qty.dep.routing
			from	tiipd001
			where	tiipd001._index1 = {:i.item}
			as set with 1 rows
			selectdo
			endselect
		endif
		hold.item = i.item
		hold.company = current.company
	endif

	return(hold.qty.dep.routing = tcyesno.yes)
}

function domain tcbool rou.code.valid.for.unit(
			domain	tcitem		i.mitm,
			domain	tirou.opro	i.opro,

			domain	tcyesno		i.stcf,
			domain	tcyesno		i.unef,
			domain	tcuef.effn	i.effn)
{

	|* first do the checks based on object flags,
	|* to do an early return if possible
	CHECK.OBJECT.FLAGS.AND.UNIT

	|* determine object key
	object.key.ok = txuef.dll9001.create.compressed.key(
				object.key,
			 	"tirou101",
				i.mitm,
				i.opro)
	RETURN.IF.OBJECT.KEY.NOT.OK

	|* read Effectivity Statements and determine validity
	object.valid = check.object.eff.statements.for.unit(
			object.key, i.effn, i.stcf)
	return(object.valid)
}

function check.object.flags(
			domain	tcyesno	    i.stand.conf,
			domain	tcyesno	    i.eff.stats,
			domain	tcuef.effn  i.eff.unit,
		ref	domain	tcbool	    o.valid,
		ref	domain	tcbool	    o.return)
{
	FunctionUsage
	Expl:	This function checks the object flags, to see
		if an early return is possible.

	input:
		i.stand.conf: Standard Configuration flag
		i.eff.stats : Effectivity Statements Present on object
		i.eff.unit  : Effectivity Unit number

	Output: o.valid	    : object is valid (true/false)
		o.return    : checking completed (true / false)
	EndFunctionUsage


	|* init output values
	o.return = false

	|* Effectivity Unit = 0 indicates: standard configuration.
	|* Therefor the standard configuration flag determines the validity.
	if i.eff.unit = 0 then
		o.valid  = (i.stand.conf = tcyesno.yes)
		o.return = true
		return					
	endif

	|* No effectivity statements present.
	|* Validity is determined by flag 'Standard Configuration' only.
	if i.eff.stats = tcyesno.no then
		o.valid  = (i.stand.conf = tcyesno.yes)
		o.return = true
	endif
}

function domain tcbool check.object.eff.statements.for.unit(
			domain	tcuef.obje  i.object,
			domain	tcuef.effn  i.eff.unit,
			domain	tcyesno	    i.std.conf)

{
	FunctionUsage
	Expl:	This function is used to check if the effectivity statements
		for an object define the object as valid or invalid.
	Input:
		i.object	: Object (concatenated key)
		i.eff.unit	: Effectivity Unit number
		i.std.conf	: Standard Configuraton
	Return:
		true 		: object is valid
		false		: object is not valid
	EndFunctionUsage

	long		range.width		|* width of current range
	long		hold.range.width	|* width of smallest range
	domain	tcyesno	hold.range.valid	|* valid flag of smallest range

	|* First search object's effectivity statements (tcuef005)
	|* for specific effectivity units (overrules stnd conf.)
	select	tcuef005.effn, tcuef005.vald
	from	tcuef005
	where	tcuef005._index2 = {:i.object}
	and	tcuef005.effn = :i.eff.unit
	as set with 1 rows
	selectdo
		return(tcuef005.vald = tcyesno.yes)
	endselect

	|* No specific effectivity statement found.
	|* Next search object's effectivity statements (tcuef005)
	|* for Requirements (which holds i.eff.unit)
	|* If more then one Requirement is defined for this object,
	|* then the Requirement with the smallest number of effectivity numbers
	|* (= the most specific one) determines the result (valid / not valid).
								
	hold.range.width = MAX.VALUE

	select	tcuef005.*
	from	tcuef005, tcuef007
	where	tcuef005._index2 = {:i.object}
	  and	tcuef005.eopt <> ""
	  and 	tcuef005.eopt refers to tcuef007.eopt
	  and	tcuef007.effn = :i.eff.unit
	selectdo
		|* determine number of eff.units in this requirement
		range.width = tcuefdll0001.eopt.get.nr.eff.units(tcuef005.eopt)
		if range.width < 0 then
			|* not found. Read table data
			range.width = 0
			select 	count(tcuef007.effn):range.width
			from	tcuef007
			where	tcuef007._index1 = {:tcuef005.eopt}
			selectdo
			endselect

			|* add result to arrays
			eopt.add.row(tcuef005.eopt, range.width)
		endif

		|* store 'valid' info for the most specific requirement
		|* (= requirement with the smallest number of eff. units)
		if range.width < hold.range.width then
			hold.range.valid = tcuef005.vald
			hold.range.width = range.width
		endif
	endselect

	if hold.range.width < MAX.VALUE then
		return(hold.range.valid = tcyesno.yes)
	endif

	|* No overruling statements found. Standard Configuration flag
	|* is returned.
	return(i.std.conf = tcyesno.yes)

}

function long tcuefdll0001.eopt.get.nr.eff.units(
				domain	tcuef.eopt	i.eopt )
{
	| returns negative value when not found

	long	i

	for i = tcuefdll0001.eopt.nr.rows to 1 step -1
		if tcuefdll0001.eopt(1,i) = i.eopt then
			return(tcuefdll0001.nr.eff.units(i))
		endif
	endfor

	return(-1)
}

function boolean found.routing.code(
					domain	tcitem		i.item,
					domain	tirou.opro	i.routing,
				ref	domain	tcdsca		o.description)
{
	Functionusage
	Expl.	: To return a true/false answer if the specific routing exists.
	Pre	: -
	Post	: -
	Input	: i.item	- Item of the routing that will be checked.
		  i.routing	- The routing code that will be checked.
	Output	: o.description	- Description of routing.
	Return	: True	- Routing exists.
		  False	- Routing does not exist.
	EndFunctionusage

	|* Initialize output variables.
	o.description = ""
	
	select	tirou101.dsca:o.description
	from 	tirou101
	where 	tirou101._index1 = {:i.item,
				    :i.routing}
	as set with 1 rows
	selectdo
		return(true)
	endselect
	
	return(false)
}

function eopt.add.row(
			domain	tcuef.eopt	i.eopt,
				long		nr.eff.units)
{
		long 	i
	static 	long	len.eopt
		long	ret
		long	dummy

	tcuefdll0001.eopt.nr.rows = tcuefdll0001.eopt.nr.rows + 1

	if tcuefdll0001.eopt.nr.rows > tcuefdll0001.eopt.nr.rows.allocated then
		if len.eopt = 0 then
			ret = rdi.domain.string("tcuef.eopt", len.eopt, dummy)
		endif

		tcuefdll0001.eopt.nr.rows.allocated =
			tcuefdll0001.eopt.nr.rows.allocated + 100

		ret = alloc.mem(tcuefdll0001.eopt, len.eopt,
					tcuefdll0001.eopt.nr.rows.allocated)
		ret = alloc.mem(tcuefdll0001.nr.eff.units,
					tcuefdll0001.eopt.nr.rows.allocated)
	endif


	i = tcuefdll0001.eopt.nr.rows

	tcuefdll0001.eopt(1,i) = i.eopt
	tcuefdll0001.nr.eff.units(i) = nr.eff.units
} 

function emergency.exit(string msg(512) mb)
{
	message(msg)
	job.process.error = true
|t	stop()
}

 
function long retrieve.bod.data(
			const	string			i.noun,
			ref	domain	tcbod.impl	o.identifier,
			ref	domain	tcbod.name	o.public.noun,
			ref	domain	tcbod.impl	o.public.identifier,
			ref	domain	tcbod.type	o.bod.type)
{
	RETIFNOK(txbod.dll9002.get.bod.data(
				i.noun,
				o.identifier,
				o.public.noun,
				o.public.identifier,
				o.bod.type))

	o.public.noun = trim$(o.public.noun)

	return(0)
}

function handle.visibility.bods(
	const		string	i.bod,
	const		long	i.group.no,
	const		string	i.field.name,
	ref	domain	tcyesno	o.visible)
{
	o.visible = tcyesno.yes

	if not txbod.dll9002.bod.implemented( i.bod ) then
		if i.group.no > 0 then
			group.invisible( i.group.no )

			o.visible = tcyesno.no
		endif

		if not isspace( i.field.name ) then
			inputfield.invisible( i.field.name )

			o.visible = tcyesno.no
		endif
	endif
}


function set.enum.values.for.mode(
	string	i.field.name(18) )
{
	if not txbod.dll9002.publishing.allowed() then
		|* Publishing of BODs is prevented.
		|* Only show next options:
		|* 	- Count
		|* 	- Simulate
		set.initial.enum.values.for.field(
			i.field.name,
			PD_MODE_COUNT,
			PD_MODE_SIMULATE )
	endif
}

function long get.business.object.name(
	const	string	i.bod,
	const	string	i.label,
	ref	string	o.name )
{
	|* Supported:
	|* 1. Public BOD name
	|* 	- Get the public BOD name of the specified BOD.
	|* 	i.bod = BOD name
	|* 	i.label = PUBLIC BOD NAME
	|*
	|* 2. Label only
	|* 	- Use label for business object name
	|* 	i.bod = BOD name
	|* 	i.label = <Public BOD name>-<label>
	|*
	|* 3. Label 'pb'-field
	|* 	- Use label of 'pb'-field as label.
	|* 	i.bod = BOD name
	|* 	i.label = <Name 'pb'-field>
	|*
	|* 4. Concatenation public BOD name and label
	|* 	- Concatenate public BOD name and label with hyphen.
	|* 	- If label starts with '(', concatenate public BOD name and
	|* 	  label with space.
	|* 	i.bod = BOD name
	|* 	i.label = <text>

	string	label(200)
	string	dummy.label

	o.name = ""

	if not isspace( i.bod ) then
		RETIFNOK( txbod.dll9002.get.bod.public(
				i.bod,
				o.name ))	|* Ref

		o.name = txbod.dll9002.convert.noun.name.to.without.bod(
				o.name )
	endif

	|* 1. Public BOD name.
	if str.equals( trim$( i.label ), LABEL_PUBLIC_BOD_NAME ) then
		|* Label is equal to 'PUBLIC BOD NAME'. Public BOD name is
		|* already set. Return 0.
		if isspace( o.name ) then
			ASSERT(	false,
				"No BOD specified. Public BOD name cannot be " &
				"received. " )
		endif

		return( 0 )
	endif

	|* 2. Label only
	if str.startswith( trim$( i.label ), trim$( o.name )) and
	   pos( i.label, "-" ) > 0 then
		|* Label starts with public BOD name. Return label.
		o.name = trim$( i.label )

		return( 0 )
	endif

	|* 3. Label 'pb'-field
	if str.startswith( trim$( i.label ), PREFIX_PB_FIELD ) then
		|* Label starts with 'pd.'. Get the label of the 'pd'-field.
		if get.current.field.label(
				trim$( i.label ),
				1,
				label,			|* Ref: label 1
				dummy.label,		|* Ref: label 2
				dummy.label ) <> 0 then	|* Ref: label 3
			|* Error. Label of field not found.
			label = ""
		endif
	else
		label = i.label
	endif

	|* 4. Concatenation public BOD name and label
	if not isspace( label ) then
		if str.startswith( trim$( i.label ), "(" ) then
			|* Concatenate public BOD name and label with space.
			o.name = o.name & " " & trim$( label )
		else
			|* Concatenate public BOD name and label with hyphen.
			o.name = o.name & "-" & trim$( label )
		endif
	endif

	return( 0 )
}



function boolean get.skip.publishing.bods()
{
	boolean	being.skipped

	skip.publishing.bods(	false,			|get value
				being.skipped)		|value

	return(being.skipped)
}

function skip.publishing.bods(	boolean	i.set.value,
			ref	boolean	io.value)
{
	static	boolean	s.value

	if i.set.value then
		s.value = io.value
	else
		io.value = s.value
	endif
}
function boolean prevent.bod.publishing()
{
	domain	tcyesno	prevent.publishing

	static	boolean			s.prevent.bod.publishing
	static	domain	tcncmp		s.company

	if s.company = get.compnr() then
		return(s.prevent.bod.publishing)
	endif

	s.company = get.compnr()
	s.prevent.bod.publishing = false

	select	tcbod000.prbp:prevent.publishing
	from	tcbod000
	where	tcbod000._index1 = {0}
	as set with 1 rows
	selectdo
		if prevent.publishing = tcyesno.yes then
			s.prevent.bod.publishing = true
		endif
	selectempty
		s.prevent.bod.publishing = true
	endselect

	return(s.prevent.bod.publishing)
}

function boolean do.add.label.sequence(
	const	long	i.group,
	const	string	i.label,
	ref	string	io.hold.label,
	ref	boolean	o.restart.numbering,
			... )
{
	string	label(70)

	o.restart.numbering = false
	
|t	if not is.field.group.invisible( i.group ) then
		|* Group is visible.
		if get.arg.type(5)= DB.LONG then
			label = get.string.arg(6)

			if trim$( i.label ) = trim$( label ) then
				|* Use label sequence, because:
				|* - Next set of arguments is for groups
				|* - Labels of actual set and next set are equal

				|* Restart numbering if this label:
				|* - Is the first label
				|*   (io.hold.label is mempty )
				|* - Differs from the previous label.
				if isspace( io.hold.label ) or
				   not str.equals(
						trim$( i.label ),
						trim$( io.hold.label )) then
					o.restart.numbering = true
				endif

				io.hold.label = label

				return( true )
			endif
		endif
 
		if trim$( i.label ) = trim$( io.hold.label ) then
			|* Use label sequence because labels of previous set and
			|* actual set are equal.
			return( true )
		endif

		io.hold.label = ""
|t	endif

	|* Label of actual set is not equal to previous of next label.
	|* Do not use label sequence.
	return( false )
}

function long bod.metadata.exists(
		domain	bobod.name	i.name)
{
	FunctionUsage
	Expl	: This function checks if the bod is supported in this FP.
		  It checks standard BODs defined in this DLl as well as
		  custom BODs defined in table bobod100.
		  Error message is set when no metadata found for the BOD.
	pre	: NA
	post	: NA
	Input	: i.name	- BOD name (e.g. CodeDefinitionBOD)
	Output	: NA
	return	: 0		- OK
		  DALHOOKERROR	- error
	EndFunctionUsage

	domain	bobod.impl	dummy.identifier
		long		dummy.visibility
	domain	bobod.type	dummy.type
	domain	boyesno		dummy.support.ae
	domain	bobod.name	dummy.parent.bod
	string			dummy.parm.string(PARM_STRING)

	RETIFNOK( get.bod.metadata.by.name(
			i.name,
			dummy.identifier,	|* Ref
			dummy.visibility,	|* Ref
			dummy.type,		|* Ref
			dummy.parent.bod,	|* Ref
			dummy.support.ae,	|* Ref
			dummy.parm.string ))

	return( 0 )
}



function long get.bod.metadata.by.name(				
	const	domain	bobod.name	i.name,
	ref	domain	bobod.impl	o.identifier,
	ref		long		o.visibility,
	ref	domain	bobod.type	o.type,
	ref	domain	bobod.name	o.parent.bod,
	ref	domain	boyesno		o.support.accounting.entity,
	ref	string			o.parm.string)		
{
		long		position				
	domain	bobod.name	name				
								
	for position = 1 to s.g.bods.in.stack			
		name = s.g.name.stack(1,position)

		if not isspace( name ) and
		   trim$( name ) = trim$( i.name ) then
			o.identifier = s.g.identifier.stack(1,position)
			o.visibility = s.g.visibility.stack(position)
			o.type = s.g.type.stack(position)
	
			o.parent.bod = trim$(s.g.parent.bod.stack(1,position))	
								
			o.support.accounting.entity =
						s.g.support.ae.stack(position)
			o.parm.string = s.g.parm.stack(1,position)	

			return( 0 )
		endif
	endfor

								
	g.reshuffle.cache = true
	s.g.metadata.cached = false

	if not isspace(i.name) then
		RETIFNOK( cache.metadata.bods(BODS_ALL, i.name) )
	endif

	if s.g.metadata.cached then
		o.identifier = s.g.identifier.stack(1,s.g.bods.in.stack)
		o.visibility = s.g.visibility.stack(s.g.bods.in.stack)
		o.type = s.g.type.stack(s.g.bods.in.stack)
		o.parent.bod = trim$(s.g.parent.bod.stack(1,s.g.bods.in.stack))
		o.support.accounting.entity =
					s.g.support.ae.stack(s.g.bods.in.stack)
		o.parm.string = s.g.parm.stack(1,s.g.bods.in.stack)
	else
		s.g.metadata.cached = true
								

		dal.set.error.message(			
			"txbods0030",
			|* txbods0030  ???
			trim$( i.name ))
								
			|* No metadata found for BOD '%1$s' in library used for
			|* metadata (%2$s).

		return( DALHOOKERROR )
								
	endif

	return(0)
								
}



function long get.number.of.positions.stack(
	const	domain	bobod.name	i.stack() )
{
	long    dummy.nr.dimensions
	long    size.dimensions(4)

	array.info(
		i.stack,
		dummy.nr.dimensions,
		size.dimensions )

	return( size.dimensions(2) )
}

function long cache.metadata.bods(	long			i.kind.of.bods,
					domain	bobod.name	i.name)
{
	|* A = Name
	|* B = Identifier
	|* C = Visibility
	|* D = Type
	|* E = Support accounting entity
	|* F = Parent BOD
								|#2043711.so


		long	receive.verbs
		long	send.verbs
								|#2043711.en
		long	position
		long	i
		long	cust.position
		string	parm.string(PARM_STRING)

	if not s.g.metadata.cached then
		position = s.g.bods.in.stack

|* Legend:
|* 1. Name
|* 2. Identifier
|* 3. Visibility
|* 4. BOD type
|* 5. Parent BOD
|* 6. Support accounting entity
								|#2043711.sn
|* 7. Verbs Inbound				ex.: B_LOAD+B_SYNC+B_PROCESS
|* 8. Verbs Outbound				ex.: B_SYNC		(POST, SHOW and ACKNOWLEDGE are not needed)
|* 9. BOD release to ION as connection point	ex.: YES
								|#2043711.en
								|#2043711.so
||* one call can exist of 42 BODs
||* TO IMPROVE MAINTAINABILITY: DONOT ADD NEW BODS IN THIS CACHE_BODS FUNCTION
||* BUT ADD THEM AT THE BOTTOM OF EACH BOD TYPE (MASTERDATA, TRANSACTIONAL,
||* BALANCE OR SYSTEM) SECTION
|		CACHE_BODS(
||* 1.				   		2.	    3.	      	   4.				5.					6.
|"AccountingBookDefinitionBOD",			"bogld001", PUBLIC_BOD,	   bobod.type.masterdata,	"AccountingBookDefinitionBOD",		YES,
|"AccountingBookDefinitionActualBOD",		"bogld003", PROTECTED_BOD, bobod.type.masterdata,	"AccountingBookDefinitionBOD",		YES,
|"AccountingBookDefinitionBudgetBOD",		"bofbs003", PROTECTED_BOD, bobod.type.masterdata,	"AccountingBookDefinitionBOD",		YES,
|"AccountingChartBOD",				"bogld002", PUBLIC_BOD,    bobod.type.masterdata,	"AccountingChartBOD",			YES,
|"AccountingEntityBOD",				"boemm170", PUBLIC_BOD,	   bobod.type.masterdata,	"AccountingEntityBOD",			NO,
|"AccountingJournalBOD",				"bobia030", PUBLIC_BOD,	   bobod.type.masterdata,	"AccountingJournalBOD",			YES,
|"BillFromPartyMasterBOD",			"bocom127", PUBLIC_BOD,    bobod.type.masterdata,	"BillFromPartyMasterBOD",		YES,
|"BillFromPartyMasterInBOD",			"bocom172", PROTECTED_BOD, bobod.type.masterdata,	"BillFromPartyMasterBOD",		YES,
|"BillOfMaterialsBOD",				"boedm110", PUBLIC_BOD,    bobod.type.masterdata,	"BillOfMaterialsBOD",			YES,
|"BillOfMaterialsInBOD",				"boedm111", PROTECTED_BOD, bobod.type.masterdata,	"BillOfMaterialsBOD",			YES,
|"BillOfResourcesBOD",				"bobom001", PUBLIC_BOD,    bobod.type.masterdata,	"BillOfResourcesBOD",			YES,
|"BillOfResourcesBOMBOD",			"bobom010", PROTECTED_BOD, bobod.type.masterdata,	"BillOfResourcesBOD",			YES,
|"BillOfResourcesBOMInBOD",			"bobom011", PROTECTED_BOD, bobod.type.masterdata, 	"BillOfResourcesBOD",			YES,	|#1610082.n
|"BillOfResourcesROUBOD",			"borou101", PROTECTED_BOD, bobod.type.masterdata,	"BillOfResourcesBOD",			YES,
|"BillOfResourcesROUInBOD",			"borou102", PROTECTED_BOD, bobod.type.masterdata, 	"BillOfResourcesBOD",			YES,	|#1610082.n
|"BillOfResourcesAssemblyBOD",			"boapl220", PROTECTED_BOD, bobod.type.masterdata, 	"BillOfResourcesBOD",			YES, 	|#1972563.n
|"BillToPartyMasterBOD",				"bocom117", PUBLIC_BOD,    bobod.type.masterdata,	"BillToPartyMasterBOD",			YES,
|"BillToPartyMasterInBOD",			"bocom162", PROTECTED_BOD, bobod.type.masterdata,	"BillToPartyMasterBOD",			YES,
|								|#1961196.sn
|								|#1968416.so
||"BusinessPlanBOD",				"bormp300", PUBLIC_BOD,    bobod.type.transactional, "BusinessPlanBOD",			YES,
||"BusinessPlanInBOD",				"bormp301", PROTECTED_BOD, bobod.type.transactional, "BusinessPlanBOD",			YES,
|								|#1968416.eo
|								|#1961196.en
|								|#1968416.sn
|"BusinessPlanBOD",				"bormp300", PUBLIC_BOD,    bobod.type.masterdata, 	"BusinessPlanBOD",			YES,
|"BusinessPlanInBOD",				"bormp301", PROTECTED_BOD, bobod.type.masterdata, 	"BusinessPlanBOD",			YES,
|								|#1968416.en
|"CarrierPartyBOD",				"bomcs083", PUBLIC_BOD,    bobod.type.masterdata,	"CarrierPartyBOD",			YES,
|"ChartOfAccountsBOD",				"bogld008", PUBLIC_BOD,    bobod.type.masterdata,	"ChartOfAccountsBOD",			YES,
|"CodeDefinitionBOD",				"bomcs300", PUBLIC_BOD,    bobod.type.masterdata,	"CodeDefinitionBOD",			NO,
|"CodeDefinitionCashFlowReasonDimensionBOD",	"bomcs313", PROTECTED_BOD, bobod.type.masterdata,	"CodeDefinitionBOD",			YES,
|"CodeDefinitionDepartmentBOD",			"bomcs314", PROTECTED_BOD, bobod.type.masterdata,	"CodeDefinitionBOD",			YES,
|"CodeDefinitionFlexDimensionBOD",		"bogld010", PROTECTED_BOD, bobod.type.masterdata,	"CodeDefinitionBOD",			YES,
|"CodeDefinitionGeneralBOD",			"bomcs320", PROTECTED_BOD, bobod.type.masterdata,	"CodeDefinitionBOD",			YES,
|"CodeDefinitionGeneralInBOD",			"bomcs321", PROTECTED_BOD, bobod.type.masterdata,	"CodeDefinitionBOD",			YES,
|"CodeDefinitionJournalBookDimensionBOD",	"bogld050", PROTECTED_BOD, bobod.type.masterdata,	"CodeDefinitionBOD",			YES,
|"CodeDefinitionMetaFixedDimensionBOD",		"bobia020", PROTECTED_BOD, bobod.type.masterdata,	"CodeDefinitionBOD",			YES,
|"CodeDefinitionMetaFlexDimensionBOD",		"bobia010", PROTECTED_BOD, bobod.type.masterdata,	"CodeDefinitionBOD",			YES,
|"CodeDefinitionPartyDimensionBOD",		"bocom105", PROTECTED_BOD, bobod.type.masterdata,	"CodeDefinitionBOD",			YES,
|"CodeDefinitionProductionReasonBOD",		"bomcs315", PROTECTED_BOD, bobod.type.masterdata,	"CodeDefinitionBOD",			YES,
|"CodeDefinitionRebateGroupBOD",			"bocms301", PROTECTED_BOD, bobod.type.masterdata,	"CodeDefinitionBOD",			YES,
|"CodeDefinitionReconGroupDimensionBOD",		"bofin020", PROTECTED_BOD, bobod.type.masterdata,	"CodeDefinitionBOD",			YES
|)
|
||* Maximum number of 255 arguments reached. Continue with next macro.
||* TO IMPROVE MAINTAINABILITY: DONOT ADD NEW BODS IN THIS CACHE_BODS FUNCTION
||* BUT ADD THEM AT THE BOTTOM OF EACH BOD TYPE (MASTERDATA, TRANSACTIONAL,
||* BALANCE OR SYSTEM) SECTION
|		CACHE_BODS(
||* 1.						2.	    3.	      	   4.			  	5.					6.
|"CodeDefinitionTaxAccountDimensionBOD",		"bogld070", PROTECTED_BOD, bobod.type.masterdata,	"CodeDefinitionBOD",			YES,
|"CodeDefinitionTaxCodeDimensionBOD",		"bomcs311", PROTECTED_BOD, bobod.type.masterdata,	"CodeDefinitionBOD",			YES,
|"CodeDefinitionTaxCountryDimensionBOD",		"bomcs312", PROTECTED_BOD, bobod.type.masterdata,	"CodeDefinitionBOD",			YES,
|"CodeDefinitionUnitBOD",			"bomcs310", PROTECTED_BOD, bobod.type.masterdata,	"CodeDefinitionBOD",			YES,
|"ConfiguredAssetMasterBOD",			"bobsc101", PUBLIC_BOD,    bobod.type.masterdata,	"ConfiguredAssetMasterBOD",		YES,
|"ConfiguredAssetMasterGroupBOD",		"bobsc100", PROTECTED_BOD, bobod.type.masterdata,	"ConfiguredAssetMasterBOD",		YES,
|"ConfiguredAssetMasterSerialBOD",		"bobsc102", PROTECTED_BOD, bobod.type.masterdata,	"ConfiguredAssetMasterBOD",		YES,
|"ConfiguredAssetMasterNonSerialBOD",		"bobsc103", PROTECTED_BOD, bobod.type.masterdata,	"ConfiguredAssetMasterBOD",		YES,
|"ConstrainedResourceBOD",			"borou010", PUBLIC_BOD,    bobod.type.masterdata,	"ConstrainedResourceBOD",		YES,
|"ContactMasterBOD",				"bocom140", PUBLIC_BOD,    bobod.type.masterdata,	"ContactMasterBOD",			YES,
|"ContactMasterInBOD",				"bocom141", PROTECTED_BOD, bobod.type.masterdata,	"ContactMasterBOD",			YES,
|"CurrencyBOD",					"bomcs031", PUBLIC_BOD,    bobod.type.masterdata,	"CurrencyBOD",				YES,
|"CurrencyExchangeRateMasterBOD",		"bomcs214", PUBLIC_BOD,    bobod.type.masterdata,	"CurrencyExchangeRateMasterBOD",	YES,
|"CurrencyExchangeRateMasterInBOD",		"bomcs216", PROTECTED_BOD, bobod.type.masterdata,	"CurrencyExchangeRateMasterBOD",	YES,
|"CurrencyExchangeRateMasterOutBOD",		"bomcs215", PROTECTED_BOD, bobod.type.masterdata,	"CurrencyExchangeRateMasterBOD",	YES,
|"CurrencyRateTypeBOD",				"bomcs213", PUBLIC_BOD,    bobod.type.masterdata,	"CurrencyRateTypeBOD",			YES,
|"CustomerPartyMasterBOD",			"bocom115", PUBLIC_BOD,    bobod.type.masterdata,	"CustomerPartyMasterBOD",		YES,
|"CustomerPartyMasterSoldToBOD",			"bocom110", PROTECTED_BOD, bobod.type.masterdata,	"CustomerPartyMasterBOD",		YES,
|"CustomerPartyMasterSoldToInBOD",		"bocom160", PROTECTED_BOD, bobod.type.masterdata,	"CustomerPartyMasterBOD",		YES,
|"FinancialCalendarBOD",				"bogld005", PUBLIC_BOD,    bobod.type.masterdata,	"FinancialCalendarBOD",			YES,
|"FinancialCalendarCommonBOD",			"boccp070", PROTECTED_BOD, bobod.type.masterdata,	"FinancialCalendarBOD",			YES,
|"FinancialCalendarPlanningBOD",			"bormp420", PROTECTED_BOD, bobod.type.masterdata,	"FinancialCalendarBOD",			YES,
|"ItemMasterBOD",				"boibd501", PUBLIC_BOD,    bobod.type.masterdata,	"ItemMasterBOD",			YES,
|"ItemMasterCommonBOD",				"boibd505", PROTECTED_BOD, bobod.type.masterdata,	"ItemMasterBOD",			YES,
|"ItemMasterRevisionBOD",			"boedm100", PROTECTED_BOD, bobod.type.masterdata,	"ItemMasterBOD",			YES,
|"ItemMasterCommonInBOD",			"boibd506", PROTECTED_BOD, bobod.type.masterdata,	"ItemMasterBOD",			YES,
|"LnResourceCalendarBOD",			"boccp020", PUBLIC_BOD,    bobod.type.masterdata, 	"LnResourceCalendarBOD",		YES,		|#1960878.n
|"LnUserDefinedStructureBOD",			"bopdm095", PUBLIC_BOD,	   bobod.type.masterdata,	"LnUserDefinedStructureBOD",		YES,
|"LocationBOD",					"bomcs290", PUBLIC_BOD,    bobod.type.masterdata,	"LocationBOD",				YES,
|"LocationDepartmentBOD",			"bomcs292", PROTECTED_BOD, bobod.type.masterdata,	"LocationBOD",				YES,
|"LocationProjectBOD",				"bopdm600", PROTECTED_BOD, bobod.type.masterdata,	"LocationBOD",				YES,
|"LocationSiteBOD",				"boemm010", PROTECTED_BOD, bobod.type.masterdata,	"LocationBOD",				YES,
|"LocationWarehouseBOD",				"bomcs291", PROTECTED_BOD, bobod.type.masterdata,	"LocationBOD",				YES
|)
|
||* Maximum number of 255 arguments reached. Continue with next macro.
||* TO IMPROVE MAINTAINABILITY: DONOT ADD NEW BODS IN THIS CACHE_BODS FUNCTION
||* BUT ADD THEM AT THE BOTTOM OF EACH BOD TYPE (MASTERDATA, TRANSACTIONAL,
||* BALANCE OR SYSTEM) SECTION
|		CACHE_BODS(
||* 1.						2.	    3.	      	   4.			  	5.					6.
|"ManufacturerPartyMasterBOD",			"bomcs060", PUBLIC_BOD,	   bobod.type.masterdata,	"ManufacturerPartyMasterBOD",		YES,
|"ManufacturerPartyMasterInBOD",			"bomcs063", PROTECTED_BOD, bobod.type.masterdata,	"ManufacturerPartyMasterBOD",		YES,
|"ManufacturingPartBOD",				"boipu045", PUBLIC_BOD,	   bobod.type.masterdata,	"ManufacturingPartBOD",			YES,
|"ManufacturingPartInBOD",			"boipu046", PROTECTED_BOD, bobod.type.masterdata,	"ManufacturingPartBOD",			YES,
|"PayFromPartyMasterBOD",			"bocom118", PUBLIC_BOD,	   bobod.type.masterdata,	"PayFromPartyMasterBOD",		YES,
|"PayFromPartyMasterInBOD",			"bocom163", PROTECTED_BOD, bobod.type.masterdata,	"PayFromPartyMasterBOD",		YES,
|"PersonBOD",					"bocom002", PUBLIC_BOD,    bobod.type.masterdata,	"PersonBOD",				YES,
|"PersonEmployeeBOD",				"bocom003", PROTECTED_BOD, bobod.type.masterdata,	"PersonBOD",				YES,
|"PersonInBOD",					"bocom004", PROTECTED_BOD, bobod.type.masterdata,	"PersonBOD",				YES,
|"ProjectMasterBOD",				"bomcs360", PUBLIC_BOD,    bobod.type.masterdata,	"ProjectMasterBOD",			YES,
|"ProjectMasterInBOD",				"bopdm040", PROTECTED_BOD, bobod.type.masterdata,	"ProjectMasterBOD",			YES,
|"ProjectMasterTPBOD",				"bopdm010", PROTECTED_BOD, bobod.type.masterdata,	"ProjectMasterBOD",			YES,
|"ProjectMasterPCSBOD",				"bopcs010", PROTECTED_BOD, bobod.type.masterdata,	"ProjectMasterBOD",			YES,
|"RemitToPartyMasterBOD",			"bocom128", PUBLIC_BOD,	   bobod.type.masterdata,	"RemitToPartyMasterBOD",		YES,
|"RemitToPartyMasterInBOD",			"bocom173", PROTECTED_BOD, bobod.type.masterdata,	"RemitToPartyMasterBOD",		YES,
|"SerialStructureBOD",				"bocfg210", PUBLIC_BOD,	   bobod.type.masterdata, 	"SerialStructureBOD",			YES,	|#1551010.n
|"SerialStructureAsBuiltBOD",			"bomfc010", PROTECTED_BOD, bobod.type.masterdata, 	"SerialStructureBOD",			YES,	|#1588573.n
|"SerialStructureInBOD",				"bocfg211", PROTECTED_BOD, bobod.type.masterdata, 	"SerialStructureBOD",			YES,	|#1551010.n
|"ShipFromPartyMasterBOD",			"bocom126", PUBLIC_BOD,	   bobod.type.masterdata,	"ShipFromPartyMasterBOD",		YES,
|"ShipFromPartyMasterInBOD",			"bocom171", PROTECTED_BOD, bobod.type.masterdata,	"ShipFromPartyMasterBOD",		YES,
|"ShipToPartyMasterBOD",				"bocom116", PUBLIC_BOD,	   bobod.type.masterdata,	"ShipToPartyMasterBOD",			YES,
|"ShipToPartyMasterInBOD",			"bocom161", PROTECTED_BOD, bobod.type.masterdata,	"ShipToPartyMasterBOD",			YES,
|"SupplierPartyMasterBOD",			"bocom125", PUBLIC_BOD,    bobod.type.masterdata,	"SupplierPartyMasterBOD",		YES,
|"SupplierPartyMasterBuyFromBOD",		"bocom119", PROTECTED_BOD, bobod.type.masterdata,	"SupplierPartyMasterBOD",		YES,
|"SupplierPartyMasterInBOD",			"bocom170", PROTECTED_BOD, bobod.type.masterdata,	"SupplierPartyMasterBOD",		YES,
|"LaborCostMasterBOD",				"bopdm020", PUBLIC_BOD,	   bobod.type.masterdata,	"LaborCostMasterBOD",			YES,
|"LaborCostMasterProjectBOD",			"bopdm021", PROTECTED_BOD, bobod.type.masterdata,	"LaborCostMasterBOD",			YES,
|"SecurityPermissionMasterBOD",			"bobod101", PUBLIC_BOD,	   bobod.type.masterdata,	"SecurityPermissionMasterBOD",		NO,
|"SecurityRoleMasterBOD",			"bobod102", PUBLIC_BOD,	   bobod.type.masterdata,	"SecurityRoleMasterBOD",		NO,
|"SecurityUserMasterBOD",			"bobod103", PUBLIC_BOD,	   bobod.type.masterdata,	"SecurityUserMasterBOD",		NO,
|"SecurityUserMasterInBOD",			"bobod104", PROTECTED_BOD, bobod.type.masterdata,	"SecurityUserMasterBOD",		NO,
|"SundryCostMasterBOD",				"bopdm030", PUBLIC_BOD,	   bobod.type.masterdata,	"SundryCostMasterBOD",			YES,
|"SundryCostMasterProjectBOD",			"bopdm031", PROTECTED_BOD, bobod.type.masterdata,	"SundryCostMasterBOD",			YES,
|"UOMGroupBOD",					"bomcs350", PUBLIC_BOD,	   bobod.type.masterdata,	"UOMGroupBOD",				YES
|)
|
|								|#1546145.sn
||* Maximum number of 255 arguments reached. Continue with next macro.
||* TO IMPROVE MAINTAINABILITY: ADD NEW BODS OF BOD TYPE MASTERDATA IN THIS
||* CACHE_BODS FUNCTION
|		CACHE_BODS(
||* 1.						2.	    3.	      	   4.			  	5.					6.
|"AssetMasterBOD",				"bomcs295", PUBLIC_BOD,	   bobod.type.masterdata,	"AssetMasterBOD",			YES,
|"AssetMasterServiceCarBOD",			"bomdm145", PROTECTED_BOD, bobod.type.masterdata,	"AssetMasterBOD",			YES,
|"PersonnelBOD",					"bocom006", PUBLIC_BOD,    bobod.type.masterdata,	"PersonnelBOD",				YES,
|"PersonnelInBOD",				"bocom007", PROTECTED_BOD, bobod.type.masterdata,	"PersonnelBOD",				YES,
|"PriceListBOD",					"bopcg010", PUBLIC_BOD,	   bobod.type.masterdata,	"PriceListBOD",				YES,
|"WorkCenterBOD",				"borou001", PUBLIC_BOD,    bobod.type.masterdata,    	"WorkCenterBOD",			YES,	|$1603484.n
|"LnItemMasterDefaultsBOD",			"boibd502", PUBLIC_BOD,	   bobod.type.masterdata, 	"LnItemMasterDefaultsBOD",		YES,	|#1668721.n
|"LnAssemblyLineBOD",				"boasl130", PUBLIC_BOD,	   bobod.type.masterdata, 	"LnAssemblyLineBOD",			YES,	|#1966038.n
|"LnProductVariantBOD",				"bopcf100", PUBLIC_BOD,    bobod.type.masterdata,	"LnProductVariantBOD",			YES,	|#1970481.sn
|"LnProductVariantAssemblyBOD",			"boapl300", PROTECTED_BOD, bobod.type.masterdata, 	"LnProductVariantBOD",			YES,
|"LnProductVariantPCFBOD",			"bopcf500", PROTECTED_BOD, bobod.type.masterdata,	"LnProductVariantBOD",			YES,	|#1970481.en
|"ChartOfAccountsInBOD",				"bogld009", PROTECTED_BOD, bobod.type.masterdata,	"ChartOfAccountsBOD",			YES, 	|#1604354.n
|"WorkCellBOD",					"borpt045", PROTECTED_BOD, bobod.type.masterdata,	"WorkCenterBOD",			YES,	|#1832454.n
|"StationBOD",					"boasl145", PROTECTED_BOD, bobod.type.masterdata,	"WorkCenterBOD",			YES,	|#1832454.n
|"SerialStructureAsBuilt2BOD",			"bomfc011", PROTECTED_BOD, bobod.type.masterdata,	"SerialStructureBOD",			YES,	|#1832454.n
|"WorkShiftMasterBOD",				"boppl101", PUBLIC_BOD,	   bobod.type.masterdata,	"WorkShiftMasterBOD",			YES,	|#1952025.n
|"WorkShiftMasterWTSBOD",			"boppl100", PROTECTED_BOD, bobod.type.masterdata,	"WorkShiftMasterBOD",			YES,	|#1952025.n
|"EmployeeWorkScheduleBOD",			"bomdm030", PUBLIC_BOD,	   bobod.type.masterdata,	"EmployeeWorkScheduleBOD",		YES,	|#2013959.n
|"ConstrainedResourceMachineTypeBOD",		"borou011", PROTECTED_BOD, bobod.type.masterdata,	"ConstrainedResourceBOD",		YES	|#2025368.n
|)								|#1546145.en
|
||* one call can exist of 42 BODs
||* TO IMPROVE MAINTAINABILITY: DONOT ADD NEW BODS IN THIS CACHE_BODS FUNCTION
||* BUT ADD THEM AT THE BOTTOM OF EACH BOD TYPE (MASTERDATA, TRANSACTIONAL,
||* BALANCE OR SYSTEM) SECTION
|
|		CACHE_BODS(
||* 1.				   		2.	    3.	      	   4.			   	5.					6.
|"AdvanceShipNoticeBOD",				"boinh804", PUBLIC_BOD,	   bobod.type.transactional,	"AdvanceShipNoticeBOD",			YES,
|"AdvanceShipNoticeOrderBOD",			"boinh805", PROTECTED_BOD, bobod.type.transactional,	"AdvanceShipNoticeBOD",			YES,
|"CarrierRouteBOD",				"boinh818", PUBLIC_BOD,    bobod.type.transactional,	"CarrierRouteBOD",			YES,
|"ContractBOD",					"bopur032", PUBLIC_BOD,    bobod.type.transactional,	"ContractBOD",				YES,
|"ContractPurchaseBOD",				"bopur033", PROTECTED_BOD, bobod.type.transactional,	"ContractBOD",				YES,
|"ContractSalesBOD",				"bosls032", PROTECTED_BOD, bobod.type.transactional,	"ContractBOD",				YES,
|"CorrectiveActionPlanBOD",			"bocpl100", PUBLIC_BOD,    bobod.type.transactional,	"CorrectiveActionPlanBOD",		YES,
|"CreditTransferBOD",				"bocmg109", PUBLIC_BOD,	   bobod.type.transactional,	"CreditTransferBOD",			YES,
|"CustomerCallBOD",				"boclm100", PUBLIC_BOD,	   bobod.type.transactional,	"CustomerCallBOD",			YES,
|"CustomerCallInBOD",				"boclm101", PROTECTED_BOD, bobod.type.transactional,	"CustomerCallBOD",			YES,
|"CustomerForeCastBOD",				"bovmi006", PROTECTED_BOD, bobod.type.transactional,	"PlanningScheduleBOD",			YES,
|"CustomerRemittanceAdviceBOD",			"bocmg250", PUBLIC_BOD,	   bobod.type.transactional,	"CustomerRemittanceAdviceBOD",		YES,
|"CustomerRemittanceAdviceInBOD",		"bocmg251", PROTECTED_BOD, bobod.type.transactional,	"CustomerRemittanceAdviceBOD",		YES,
|"CustomerReturnBOD",				"bosls046", PUBLIC_BOD,    bobod.type.transactional,	"CustomerReturnBOD",			YES,
|"DefectiveMaterialNoticeBOD",			"boncm100", PUBLIC_BOD,    bobod.type.transactional,	"DefectiveMaterialNoticeBOD",		YES,
|"EmployeeWorkTimeBOD",				"botmm100", PUBLIC_BOD,    bobod.type.transactional,	"EmployeeWorkTimeBOD",			YES,
|"EmployeeWorkTimeAssemblyBOD",			"botmm160", PROTECTED_BOD, bobod.type.transactional,	"EmployeeWorkTimeBOD",			YES,
|"EmployeeWorkTimeGeneralBOD",			"botmm150", PROTECTED_BOD, bobod.type.transactional,	"EmployeeWorkTimeBOD",			YES,
|"EmployeeWorkTimeInBOD",			"botmm101", PROTECTED_BOD, bobod.type.transactional,	"EmployeeWorkTimeBOD",			YES,
|"EmployeeWorkTimePCSProjectBOD",		"botmm170", PROTECTED_BOD, bobod.type.transactional,	"EmployeeWorkTimeBOD",			YES,
|"EmployeeWorkTimeProjectBOD",			"botmm110", PROTECTED_BOD, bobod.type.transactional,	"EmployeeWorkTimeBOD",			YES,
|"EmployeeWorkTimeProductionBOD",		"botmm120", PROTECTED_BOD, bobod.type.transactional,	"EmployeeWorkTimeBOD",			YES,
|"EmployeeWorkTimeServiceOrderBOD",		"botmm130", PROTECTED_BOD, bobod.type.transactional,	"EmployeeWorkTimeBOD",			YES,
|"EmployeeWorkTimeWorkOrderBOD",			"botmm140", PROTECTED_BOD, bobod.type.transactional,	"EmployeeWorkTimeBOD",			YES,
|"InspectDeliveryBOD",				"boinh808", PUBLIC_BOD,    bobod.type.transactional,	"InspectDeliveryBOD",			YES,
|"InspectionOrderBOD",				"boptc100", PUBLIC_BOD,	   bobod.type.transactional,	"InspectionOrderBOD",			YES,
|"InspectionOrderOrderBOD",			"boptc120", PROTECTED_BOD, bobod.type.transactional,	"InspectionOrderBOD",			YES,
|"InspectionOrderStorageBOD",			"boptc220", PROTECTED_BOD, bobod.type.transactional,	"InspectionOrderBOD",			YES,
|"InventoryAdjustmentBOD",			"boinh810", PUBLIC_BOD,    bobod.type.transactional,	"InventoryAdjustmentBOD",		YES,
|"InventoryAdjustmentAdjustmentBOD",		"boinh811", PROTECTED_BOD, bobod.type.transactional,	"InventoryAdjustmentBOD",		YES,
|"InventoryAdjustmentCycleCountBOD",		"boinh812", PROTECTED_BOD, bobod.type.transactional,	"InventoryAdjustmentBOD",		YES,
|"InventoryConsumptionBOD",			"bowmd801", PUBLIC_BOD,    bobod.type.transactional,	"InventoryConsumptionBOD",		YES,
|"InventoryCountBOD",				"bowmd803", PUBLIC_BOD,    bobod.type.transactional,	"InventoryCountBOD",			YES,
|"InventoryHoldBOD",				"bowmd802", PUBLIC_BOD,    bobod.type.transactional,	"InventoryHoldBOD",			YES,
|"InvoiceBOD",					"boacr701", PUBLIC_BOD,    bobod.type.transactional,	"InvoiceBOD",				YES,
|"InvoiceSalesFP8BOD",				"bosli701", PROTECTED_BOD, bobod.type.transactional,	"InvoiceBOD",				YES,
|"InvoiceSalesBOD",				"bosli705", PROTECTED_BOD, bobod.type.transactional,	"InvoiceBOD",				YES,
|"InvoiceSalesACRBOD",				"boacr705", PROTECTED_BOD, bobod.type.transactional,	"InvoiceBOD",				YES,
|"InvoiceSalesInBOD",				"bosli710", PROTECTED_BOD, bobod.type.transactional,	"InvoiceBOD",				YES,
|"InvoiceWarehousingBOD",			"boinh819", PROTECTED_BOD, bobod.type.transactional,	"InvoiceBOD",				YES,
|"LnCostPegTransferBOD",				"boinh140", PUBLIC_BOD,	   bobod.type.transactional,	"LnCostPegTransferBOD",			YES,
|"LnMessageBOD",					"bobod020", PUBLIC_BOD,	   bobod.type.transactional,	"LnMessageBOD",				YES
|)
|
||* Maximum number of 255 arguments reached. Continue with next macro.
||* TO IMPROVE MAINTAINABILITY: DONOT ADD NEW BODS IN THIS CACHE_BODS FUNCTION
||* BUT ADD THEM AT THE BOTTOM OF EACH BOD TYPE (MASTERDATA, TRANSACTIONAL,
||* BALANCE OR SYSTEM) SECTION
|		CACHE_BODS(
||* 1.						2.	    3.	      	   4.			   	5					6.
|"LnMaintenanceSalesOrderBOD",			"bomsc100", PUBLIC_BOD,	   bobod.type.transactional,	"LnMaintenanceSalesOrderBOD",		YES,	|#1983091.n
|"PackageLabelBOD",				"bowmd530", PUBLIC_BOD,    bobod.type.transactional,	"PackageLabelBOD",			YES,
|"PayableTransactionBOD",			"boacp700", PUBLIC_BOD,    bobod.type.transactional,	"PayableTransactionBOD",		YES,
|"PayrollAdviceBOD",				"bobod110", PUBLIC_BOD,	   bobod.type.transactional,	"PayrollAdviceBOD",			YES,	|#1551010.n
|"PayrollAdviceInBOD",				"bobod111", PROTECTED_BOD, bobod.type.transactional,	"PayrollAdviceBOD",			YES,	|#1551010.n
|"PlanningScheduleBOD",				"bovmi001", PUBLIC_BOD,    bobod.type.transactional,	"PlanningScheduleBOD",			YES,
|"PlanningSchedulePartsForecastBOD",		"bovmi003", PROTECTED_BOD, bobod.type.transactional,	"PlanningScheduleBOD",			YES,
|"PlanningScheduleReleaseBOD",			"bosls060", PROTECTED_BOD, bobod.type.transactional,	"PlanningScheduleBOD",			YES,
|"ProductionOrderBOD",				"bosfc100", PUBLIC_BOD,    bobod.type.transactional,	"ProductionOrderBOD",			YES,
|"ProductionOrderASCBOD",			"boasc010", PROTECTED_BOD, bobod.type.transactional,	"ProductionOrderBOD",			YES,
|"ProductionOrderSFCBOD",			"bosfc110", PROTECTED_BOD, bobod.type.transactional,	"ProductionOrderBOD",			YES,
|"ProductionOrderSFCInBOD",			"bosfc111", PROTECTED_BOD, bobod.type.transactional,	"ProductionOrderBOD",			YES,
|"ProductionOrderSOCBOD",			"bosoc205", PROTECTED_BOD, bobod.type.transactional,	"ProductionOrderBOD",			YES,
|"ProjectContractBOD",				"boctm010", PUBLIC_BOD,    bobod.type.transactional,	"ProjectContractBOD",			YES,
|"ProjectContractDeliverableBOD",		"bopdm050", PUBLIC_BOD,    bobod.type.transactional,	"ProjectContractDeliverableBOD",	YES,
|"ProjectContractInstallmentBOD",		"bopin020", PUBLIC_BOD,    bobod.type.transactional,	"ProjectContractInstallmentBOD",	YES,
|"ProjectCostsBOD",				"boppc030", PUBLIC_BOD,    bobod.type.transactional,	"ProjectCostsBOD",			YES,
|"ProjectCostsHistoryBOD",			"boppc031", PROTECTED_BOD, bobod.type.transactional,	"ProjectCostsBOD",			YES,
|"ProjectCostsInterimResultsBOD",		"boppc032", PROTECTED_BOD, bobod.type.transactional,	"ProjectCostsBOD",			YES,
|"ProjectExtensionBOD",				"boptc010", PUBLIC_BOD,    bobod.type.transactional,	"ProjectExtensionBOD",			YES,
|"ProjectBudgetBOD",				"boptc020", PUBLIC_BOD,    bobod.type.transactional,	"ProjectBudgetBOD",			YES,
|"ProjectEstimateBOD",				"boest010", PUBLIC_BOD,    bobod.type.transactional,	"ProjectEstimateBOD",			YES,
|"ProjectBidBOD",				"boest020", PUBLIC_BOD,    bobod.type.transactional,	"ProjectBidBOD",			YES,
|"ProjectRevenueBOD",				"boppc050", PUBLIC_BOD,    bobod.type.transactional,	"ProjectRevenueBOD",			YES,
|"ProjectRevenueHistoryBOD",			"boppc051", PROTECTED_BOD, bobod.type.transactional,	"ProjectRevenueBOD",			YES,
|"ProjectRevenueInterimResultsBOD",		"boppc052", PROTECTED_BOD, bobod.type.transactional,	"ProjectRevenueBOD",			YES,
|"ProjectRevenueManualBOD",			"boppc053", PROTECTED_BOD, bobod.type.transactional,	"ProjectRevenueBOD",			YES,
|"ProjectProgressBOD",				"boppc040", PUBLIC_BOD,    bobod.type.transactional,	"ProjectProgressBOD",			YES,
|"PurchaseOrderBOD",				"bopur047", PUBLIC_BOD,    bobod.type.transactional,	"PurchaseOrderBOD",			YES,
|"PurchaseOrderInBOD",				"bopur049", PROTECTED_BOD, bobod.type.transactional,	"PurchaseOrderBOD",			YES,
|"SupplierRMABOD",				"bopur050", PUBLIC_BOD,    bobod.type.transactional,	"SupplierRMABOD",			YES,
|"SupplierShipmentScheduleBOD",			"bopur051", PUBLIC_BOD,    bobod.type.transactional,	"SupplierShipmentScheduleBOD",		YES,
|"SupplierPlanningScheduleBOD",			"bopur060", PUBLIC_BOD,    bobod.type.transactional,	"SupplierPlanningScheduleBOD",		YES,
|"QuoteBOD",					"bosls012", PUBLIC_BOD,    bobod.type.transactional,	"QuoteBOD",				YES,
|"QuoteSalesBOD",				"bosls011", PROTECTED_BOD, bobod.type.transactional,	"QuoteBOD",				YES,
|"QuoteSalesInBOD",				"bosls013", PROTECTED_BOD, bobod.type.transactional,	"QuoteBOD",				YES,
|"ReceivableTransactionBOD",			"boacr700", PUBLIC_BOD,    bobod.type.transactional,	"ReceivableTransactionBOD",		YES
|)
|
||* Maximum number of 255 arguments reached. Continue with next macro.
||* TO IMPROVE MAINTAINABILITY: DONOT ADD NEW BODS IN THIS CACHE_BODS FUNCTION
||* BUT ADD THEM AT THE BOTTOM OF EACH BOD TYPE (MASTERDATA, TRANSACTIONAL,
||* BALANCE OR SYSTEM) SECTION
|		CACHE_BODS(
||* 1.						2.	    3.	      	   4.			   	5					6.
|"ReceiveDeliveryBOD",				"boinh801", PUBLIC_BOD,    bobod.type.transactional,	"ReceiveDeliveryBOD",			YES,
|"ReceiveDeliveryPurchaseBOD",			"bopur046", PROTECTED_BOD, bobod.type.transactional,	"ReceiveDeliveryBOD",			YES,
|"ReceiveDeliverySalesBOD",			"bosls045", PROTECTED_BOD, bobod.type.transactional,	"ReceiveDeliveryBOD",			YES,
|"ReceiveDeliveryWarehousingBOD",		"boinh802", PROTECTED_BOD, bobod.type.transactional,	"ReceiveDeliveryBOD",			YES,
|"ReceiveDeliveryWarehousingInBOD",		"boinh820", PROTECTED_BOD, bobod.type.transactional,	"ReceiveDeliveryBOD",			YES,	|#1988772.n
|"RemittanceAdviceBOD",				"bocmg103", PUBLIC_BOD,	   bobod.type.transactional,	"RemittanceAdviceBOD",			YES,
|"RequisitionBOD",				"bopur022", PUBLIC_BOD,    bobod.type.transactional,	"RequisitionBOD",			YES,
|"RequisitionInBOD",				"bopur023", PROTECTED_BOD, bobod.type.transactional,	"RequisitionBOD",			YES,
|"RFQBOD",					"bopur011", PUBLIC_BOD,    bobod.type.transactional,	"RFQBOD",				YES,
|"RFQSubLineBOD",				"bopur121", PROTECTED_BOD, bobod.type.transactional, 	"RFQBOD",				YES,	|#1994623.n
|"SalesOrderBOD",				"bosls044", PUBLIC_BOD,	   bobod.type.transactional,	"SalesOrderBOD",			YES,
|"SalesOrderInBOD",				"bosls047", PROTECTED_BOD, bobod.type.transactional,	"SalesOrderBOD",			YES,
|"ServiceContractBOD",				"boctm300", PUBLIC_BOD,	   bobod.type.transactional,	"ServiceContractBOD",			YES,
|"ServiceOrderBOD",				"bosoc200", PUBLIC_BOD,	   bobod.type.transactional,	"ServiceOrderBOD",			YES,
|"ServiceOrderWorkOrderBOD",			"bowcs200", PROTECTED_BOD, bobod.type.transactional,	"ServiceOrderBOD",			YES	|#1933053.n
|)
|
||* Maximum number of 255 arguments reached. Continue with next macro.
||* TO IMPROVE MAINTAINABILITY: DONOT ADD NEW BODS IN THIS CACHE_BODS FUNCTION
||* BUT ADD THEM AT THE BOTTOM OF EACH BOD TYPE (MASTERDATA, TRANSACTIONAL,
||* BALANCE OR SYSTEM) SECTION
|		CACHE_BODS(
||* 1.						2.	    3.	      	   4.			   	5					6.
|"ServiceOrderInBOD",				"bosoc201", PROTECTED_BOD, bobod.type.transactional,	"ServiceOrderBOD",			YES,
|"ShipmentBOD",					"boinh803", PUBLIC_BOD,    bobod.type.transactional,	"ShipmentBOD",				YES,
|"LnContractLineBillingDateBOD",			"boctm011", PUBLIC_BOD,    bobod.type.transactional,	"LnContractLineBillingDateBOD",		YES,
|"LnPlanningSignalBOD",				"borao010", PUBLIC_BOD,	   bobod.type.transactional,	"LnPlanningSignalBOD",			YES,
|"LnPlanningSignalInBOD",			"borao013", PROTECTED_BOD, bobod.type.transactional,	"LnPlanningSignalBOD",			YES,
|"PlannedProductionOrderBOD",			"borrp010", PUBLIC_BOD,	   bobod.type.transactional,	"PlannedProductionOrderBOD",		YES,
|"PlannedPurchaseOrderBOD",			"borrp011", PUBLIC_BOD,	   bobod.type.transactional,	"PlannedPurchaseOrderBOD",		YES,
|"PlannedTransferBOD",				"borrp012", PUBLIC_BOD,	   bobod.type.transactional,	"PlannedTransferBOD",			YES,
|"PlannedProductionOrderInBOD",			"borrp013", PROTECTED_BOD, bobod.type.transactional,	"PlannedProductionOrderBOD",		YES,
|"PlannedPurchaseOrderInBOD",			"borrp014", PROTECTED_BOD, bobod.type.transactional,	"PlannedPurchaseOrderBOD",		YES,
|"PlannedTransferInBOD",				"borrp015", PROTECTED_BOD, bobod.type.transactional,	"PlannedTransferBOD",			YES,
|"ShipmentInBOD",				"boinh809", PROTECTED_BOD, bobod.type.transactional,	"ShipmentBOD",				YES,	|#1845916.n
|"ShipmentOutBOD",				"boinh806", PROTECTED_BOD, bobod.type.transactional,	"ShipmentBOD",				YES,
|"ShipmentScheduleBOD",				"bosls050", PUBLIC_BOD,	   bobod.type.transactional,	"ShipmentScheduleBOD",			YES,
|"ShipmentScheduleReleaseBOD",			"bosls051", PROTECTED_BOD, bobod.type.transactional,	"ShipmentScheduleBOD",			YES,
|"ShipmentScheduleReleasePUSBOD",		"bosls052", PROTECTED_BOD, bobod.type.transactional,	"ShipmentScheduleBOD",			YES,
|"SequenceScheduleBOD",				"bosls080", PUBLIC_BOD,	   bobod.type.transactional,	"SequenceScheduleBOD",			YES,
|"InventoryConsumptionSLSBOD",			"bosls070", PROTECTED_BOD, bobod.type.transactional,	"InventoryConsumptionBOD",		YES,
|"OpportunityBOD",				"bosmi010", PUBLIC_BOD,	   bobod.type.transactional,	"OpportunityBOD",			YES,
|"OpportunityFP6BOD",				"bosmi020", PROTECTED_BOD, bobod.type.transactional,	"OpportunityBOD",			YES,
|"SourceSystemJournalEntryBOD",			"bogld106", PUBLIC_BOD,	   bobod.type.transactional,	"SourceSystemJournalEntryBOD",		YES,
|"SourceSystemJournalEntryInBOD",		"bogld102", PROTECTED_BOD, bobod.type.transactional,	"SourceSystemJournalEntryBOD",		YES,
|"SupplierInvoiceBOD",				"boacp701", PUBLIC_BOD,    bobod.type.transactional,	"SupplierInvoiceBOD",			YES,
|"SupplierQuoteBOD",				"bopur013", PUBLIC_BOD,	   bobod.type.transactional,	"SupplierQuoteBOD",			YES,
|"SupplierQuoteInBOD",				"bopur014", PROTECTED_BOD, bobod.type.transactional,	"SupplierQuoteBOD",			YES,
|"SupplierQuoteSubLineBOD",			"bopur015", PROTECTED_BOD, bobod.type.transactional, 	"SupplierQuoteBOD",			YES,	|#1994623.n
|"SupplierQuoteSubLineInBOD",			"bopur016", PROTECTED_BOD, bobod.type.transactional, 	"SupplierQuoteBOD",			YES,	|#1994623.n
|"TransferBOD",					"boinh814", PUBLIC_BOD,	   bobod.type.transactional,	"TransferBOD",				YES
|)
|
||* Maximum number of 255 arguments reached. Continue with next macro.
||* TO IMPROVE MAINTAINABILITY: DONOT ADD NEW BODS IN THIS CACHE_BODS FUNCTION
||* BUT ADD THEM AT THE BOTTOM OF EACH BOD TYPE (MASTERDATA, TRANSACTIONAL,
||* BALANCE OR SYSTEM) SECTION
|		CACHE_BODS(
||* 1.						2.	    3.	      	   4.				5.					6.
|"ProjectBudgetInBOD",				"boptc030", PROTECTED_BOD, bobod.type.transactional,	"ProjectBudgetBOD",			YES,
|"LyDailyStockAccountBOD",			"boinr940", PUBLIC_BOD,    bobod.type.transactional,	"LyDailyStockAccountBOD",		YES,
|"ProjectRevenueAdvancePaymentRequestBOD",	"bopin051", PROTECTED_BOD, bobod.type.transactional,	"ProjectRevenueBOD",			YES,	|#1546145.sn
|"ProjectRevenueDeliveryBasedBOD",		"bopin057", PROTECTED_BOD, bobod.type.transactional,	"ProjectRevenueBOD",			YES,
|"ProjectRevenueFeesBOD",			"bopin055", PROTECTED_BOD, bobod.type.transactional,	"ProjectRevenueBOD",			YES,
|"ProjectRevenueHoldbackBOD",			"bopin054", PROTECTED_BOD, bobod.type.transactional,	"ProjectRevenueBOD",			YES,
|"ProjectRevenueInstallmentBOD",			"bopin052", PROTECTED_BOD, bobod.type.transactional,	"ProjectRevenueBOD",			YES,
|"ProjectRevenueInstallmentExtraWorkBOD",	"bopin053", PROTECTED_BOD, bobod.type.transactional,	"ProjectRevenueBOD",			YES,
|"ProjectRevenueProgressPaymentRequestBOD",	"bopin056", PROTECTED_BOD, bobod.type.transactional,	"ProjectRevenueBOD",			YES,
|"ProjectCostsEACMaterialBOD",			"boppc033", PROTECTED_BOD, bobod.type.transactional,	"ProjectCostsBOD",			YES,
|"ProjectCostsEACLaborBOD",			"boppc034", PROTECTED_BOD, bobod.type.transactional,	"ProjectCostsBOD",			YES,
|"ProjectCostsEACEquipmentBOD",			"boppc035", PROTECTED_BOD, bobod.type.transactional,	"ProjectCostsBOD",			YES,
|"ProjectCostsEACSubcontractingBOD",		"boppc036", PROTECTED_BOD, bobod.type.transactional,	"ProjectCostsBOD",			YES,
|"ProjectCostsEACSundryBOD",			"boppc037", PROTECTED_BOD, bobod.type.transactional,	"ProjectCostsBOD",			YES,
|"ProjectCostsEACOverheadBOD",			"boppc039", PROTECTED_BOD, bobod.type.transactional,	"ProjectCostsBOD",			YES,	|#1665081.n
|"ExpenseReportBOD",				"botmm010", PUBLIC_BOD,    bobod.type.transactional,	"ExpenseReportBOD",			YES,
|"ExpenseReportInBOD",				"botmm011", PROTECTED_BOD, bobod.type.transactional,	"ExpenseReportBOD",			YES,	|#1546145.en
|"CarrierRoutePlannedBOD",			"boinh480", PROTECTED_BOD, bobod.type.transactional,	"CarrierRouteBOD",			YES,	|#1578137.n
|"QualityTestResultBOD",				"boptc115", PUBLIC_BOD,	   bobod.type.transactional,	"QualityTestResultBOD",			YES,	|#1595083.n
|"DebitTransferBOD",				"bocmg409", PUBLIC_BOD,	   bobod.type.transactional,	"DebitTransferBOD",			YES,	|#1626548.n
|"ShipmentScheduleReleaseOutBOD",		"bosls054", PROTECTED_BOD, bobod.type.transactional, 	"ShipmentScheduleBOD",			YES,	|#1649537.sn
|"PlanningScheduleReleaseOutBOD",		"bosls063", PROTECTED_BOD, bobod.type.transactional, 	"PlanningScheduleBOD",			YES,	|#1649537.en
|"SupplierInvoiceInBOD",				"boacp702", PROTECTED_BOD, bobod.type.transactional,	"SupplierInvoiceBOD",			YES,	|#1952025.n
|"BankStatementBOD",				"bocmg510", PUBLIC_BOD,	   bobod.type.transactional,	"BankStatementBOD",			YES,	|#1673320.sn
|"LnVendorRatingBOD",				"bopur081", PUBLIC_BOD,	   bobod.type.transactional,	"LnVendorRatingBOD",			YES,
|"ProjectCostsEquipmentInBOD",			"boppc038", PROTECTED_BOD, bobod.type.transactional,	"ProjectCostsBOD",			YES,
|"ProjectRevenueManualInBOD",			"boppc054", PROTECTED_BOD, bobod.type.transactional,	"ProjectRevenueBOD",			YES,	|#1673320.en
|"ProjectBudgetTimePhasedBOD",			"boptc025", PROTECTED_BOD, bobod.type.transactional,	"ProjectBudgetBOD",			YES,	|#1699084.n
|"AdvanceShipNoticeInBOD",			"boinh807", PROTECTED_BOD, bobod.type.transactional,	"AdvanceShipNoticeBOD",			YES,	|#1848496.n
|"LnProductionResultBOD",			"borpt436", PUBLIC_BOD,	   bobod.type.transactional, 	"LnProductionResultBOD",		YES,	|#1851706.n
|"LnServiceContractBalanceBOD",			"boctm440", PUBLIC_BOD,	   bobod.type.transactional,	"LnServiceContractBalanceBOD",		YES,	|#1874495.sn
|"LnServiceContractBalanceActCostBOD",		"boctm480", PROTECTED_BOD, bobod.type.transactional,	"LnServiceContractBalanceBOD",		YES,
|"LnServiceContractBalanceActRevenueBOD",	"boctm460", PROTECTED_BOD, bobod.type.transactional,	"LnServiceContractBalanceBOD",		YES,
|"LnServiceContractBalanceEstRevenueBOD",	"boctm450", PROTECTED_BOD, bobod.type.transactional,	"LnServiceContractBalanceBOD",		YES,
|"LnClaimBOD",					"bocmm150", PUBLIC_BOD,	   bobod.type.transactional,	"LnClaimBOD",				YES,
|"LnClaimCustomerBOD",				"bocmm100", PROTECTED_BOD, bobod.type.transactional,	"LnClaimBOD",				YES,
|"ProjectProgressElementBOD",			"boppc045", PROTECTED_BOD, bobod.type.transactional,	"ProjectProgressBOD",			YES,	|#1891260.n
|"LnClaimSupplierBOD",				"bocmm200", PROTECTED_BOD, bobod.type.transactional,	"LnClaimBOD",				YES	|#1874495.en
|)
|
|																			|#1952025.sn
||* Maximum number of 255 arguments reached. Continue with next macro.
||* TO IMPROVE MAINTAINABILITY: ADD NEW BODS OF BOD TYPE TRANSACTIONAL IN THIS
||* CACHE_BODS FUNCTION
|		CACHE_BODS(
||* 1.						2.	    3.	      	   4.				5.					6.
|"SalesOrderInLn106BOD",				"bosls048", PROTECTED_BOD, bobod.type.transactional,	"SalesOrderBOD",			YES,
|"PayableTrackerBOD",				"boacp500", PUBLIC_BOD,    bobod.type.transactional,	"PayableTrackerBOD",			YES,
|"PayableTrackerInvoiceBOD",			"boacp510", PROTECTED_BOD, bobod.type.transactional,	"PayableTrackerBOD",			YES,
|"PayableTrackerPaymentBOD",			"boacp520", PROTECTED_BOD, bobod.type.transactional, 	"PayableTrackerBOD",			YES,	|#1944277.n
|"ReceivableTrackerBOD",				"boacr500", PUBLIC_BOD,    bobod.type.transactional,	"ReceivableTrackerBOD",			YES,
|"ReceivableTrackerReceiptBOD",			"boacr520", PROTECTED_BOD, bobod.type.transactional, 	"ReceivableTrackerBOD",			YES,	|#1944277.n
|"ReceivableTrackerInvoiceBOD",			"boacr510", PROTECTED_BOD, bobod.type.transactional,	"ReceivableTrackerBOD",			YES	|#1952025.en
|)
|
||* TO IMPROVE MAINTAINABILITY: ADD NEW BODS OF BOD TYPE BALANCE IN THIS
||* CACHE_BODS FUNCTION
|		CACHE_BODS(
||* 1.						2.	    3.	      	   4.				5.					6.
|"SourceSystemGLMovementBOD",			"bogld302", PUBLIC_BOD,	   bobod.type.balance,		"SourceSystemGLMovementBOD",		YES,
|"ProjectBalanceBOD",				"boppc010", PUBLIC_BOD,    bobod.type.balance,		"ProjectBalanceBOD",			YES,
|"ProjectPeriodBalanceBOD",			"boppc020", PUBLIC_BOD,    bobod.type.balance,		"ProjectPeriodBalanceBOD",		YES
|)
|
||* TO IMPROVE MAINTAINABILITY: ADD NEW BODS OF BOD TYPE SYSTEM IN THIS
||* CACHE_BODS FUNCTION
|		CACHE_BODS(
||* 1.						2.	    3.	      	   4.				5.					6.
|"WorkflowBOD",					"bobod010", PUBLIC_BOD,	   bobod.type.system,		"WorkflowBOD",				NO
|)
									|#2043711.so
									|#2043711.sn
		cache.bods.01(i.name, position, parm.string)
		cache.bods.02(i.name, position, parm.string)
		cache.bods.03(i.name, position, parm.string)
		cache.bods.04(i.name, position, parm.string)
		cache.bods.05(i.name, position, parm.string)
		cache.bods.06(i.name, position, parm.string)
		cache.bods.07(i.name, position, parm.string)
		cache.bods.08(i.name, position, parm.string)
		cache.bods.09(i.name, position, parm.string)
		cache.bods.10(i.name, position, parm.string)
		cache.bods.11(i.name, position, parm.string)
		cache.bods.12(i.name, position, parm.string)
		s.g.position = position
	endif

	if s.g.metadata.cached = true and
	   not isspace(i.name) and position > 0 then
	   						
		return(0)
	endif

	if isspace(i.name) then
		for i = s.g.position + 1 to s.g.cust.position
			s.g.name.stack(1,i) = ""
			s.g.identifier.stack(1,i) = ""
			s.g.visibility.stack(i) = 0
			s.g.type.stack(i) = empty
			s.g.parent.bod.stack(1,i) = ""
			s.g.support.ae.stack(i) = empty
			s.g.parm.stack(1,i) = ""
								
			s.g.receive.verbs.stack(i) = 0
			s.g.send.verbs.stack(i) = 0
			s.g.bod.release.stack(i) = empty
								
		endfor
	endif
								
	if i.kind.of.bods = BODS_ALL	or
	   i.kind.of.bods = BODS_CUSTOM	then
		cust.position = s.g.position

		if get.compnr() <> 0 then			
			select	bobod100.*
			from	bobod100
			where	bobod100.stnd = tcyesno.no
			and	(:i.name = "" or bobod100.name = :i.name)
			selectdo
				cust.position = cust.position + 1

				fill.parameter.string(	bobod100.name,
							true,	|*current
							parm.string)
								
		 		fill.custom.methods(	bobod100.name,
							bobod100.impl,
							bobod100.pblc,
							receive.verbs,	|* ref
							send.verbs)	|* ref
								
				cache.metadata(
					bobod100.name,
					bobod100.impl,
					convert.from.public(
						bobod100.pblc),
					bobod100.type,
					bobod100.pblc = boyesno.yes ?
						bobod100.name :
						bobod100.pbnm,
					boyesno.yes,
								
					receive.verbs,	|* receive.verbs
					send.verbs,	|* send.verbs
					bobod100.pblc,	|* bod.release; only public bods
								
					parm.string,
					cust.position,
					s.g.name.stack,		|* Ref
					s.g.identifier.stack,	|* Ref
					s.g.visibility.stack,	|* Ref
					s.g.type.stack,		|* Ref
					s.g.parent.bod.stack,	|* Ref
					s.g.support.ae.stack,	|* Ref
					s.g.parm.stack,		|* Ref
								
					s.g.receive.verbs.stack,|* ref
					s.g.send.verbs.stack,	|* ref
					s.g.bod.release.stack)	|* ref
								
			endselect

			s.g.cust.position = cust.position
		endif							
	endif

	return( 0 )
}

function string add.label.sequence(
	const	string	i.label,
	const	long	i.sequence.no )
{
	return( i.label & " " & get.converted.to.roman( i.sequence.no ))
}


function fill.custom.methods(	domain	bobod.name	i.name,
				domain	bobod.impl	i.identifier,
				domain	boyesno		i.public,
				ref	long		o.receive.verbs,
				ref	long		o.send.verbs)
{
	boolean		supported

	o.receive.verbs = 0
	o.send.verbs = 0

	if i.public = boyesno.yes then
		supported = TRY_FUNCTION(
			bobod.dll1004.get.custom.bod.verbs(
				i.name,
				i.identifier,
				o.receive.verbs,
				o.send.verbs))
	endif
}

function long get.implemented.methods.outgoing.bods(
	const		string	i.bod,
	const		string	i.identifier,
	const		boolean	i.on.process.implemented,
	ref		boolean	o.publish.sync.implemented,
	ref		boolean	o.publish.load.implemented,
	ref		boolean	o.publish.process.implemented,
	ref		boolean	o.publish.get.implemented,
	ref		boolean	o.publish.show.implemented,
	ref		boolean	o.publish.update.implemented,
	ref		boolean	o.publish.post.implemented,
	ref		boolean	o.publish.acknowledge.implemented )
{
	long	xml.publishable.event.actions
	long	dummy.retval
	string	data(1) based

	o.publish.sync.implemented = false
	o.publish.load.implemented = false
	o.publish.process.implemented = false
	o.publish.get.implemented = false
	o.publish.show.implemented = false
	o.publish.update.implemented = false
	o.publish.post.implemented = false
	o.publish.acknowledge.implemented = false

	|* Event action 'Acknowledge' is an exception. If 'OnProcess' (In) is
	|* implemented the event is mandatory, but will not be found in the
	|* function for publishable event actions in the 'st'-DLL.
	if i.on.process.implemented then
		o.publish.acknowledge.implemented = true
	endif

	|* Get XML with publishable event actions.
	RETIFNOK( get.xml.publishable.event.actions(
			i.bod,
			xml.publishable.event.actions ) )	|* Ref

	if xml.publishable.event.actions > 0 then
		|* XML publishable event actions present.

		if xmlAllocData(
				data,	|* Ref
				xml.publishable.event.actions ) <> 0 then
			dal.set.error.message(
				"No based string used for function " &
				|* No based string  ???
				"'xmlAllocData(...)' " )

			return( DALHOOKERROR )
		endif

		if pos( tolower$( data ), "sync" ) > 0 then
			o.publish.sync.implemented = true
		endif

		if pos( tolower$( data ), "load" ) > 0 then
			o.publish.load.implemented = true
		endif

		if pos( tolower$( data ), "process" ) > 0 then
			o.publish.process.implemented = true
		endif

		if pos( tolower$( data ), "get" ) > 0 then
			o.publish.get.implemented = true
		endif

		if pos( tolower$( data ), "show" ) > 0 then
			o.publish.show.implemented = true
		endif

		if pos( tolower$( data ), "update" ) > 0 then
			o.publish.update.implemented = true
		endif

		if pos( tolower$( data ), "post" ) > 0 then
			o.publish.post.implemented = true
		endif

		|* Delete
		dummy.retval = xmlDelete( xml.publishable.event.actions )
		xml.publishable.event.actions = 0
	endif

	return( 0 )
}

function long determine.implemented.methods.incoming.bods(
	const		string	i.bod,
	const		string	i.identifier,
	const		string	i.function.tree.stack(,),
	const		long	i.pointer.function.tree.stack(),
	const		long	i.used.size.function.tree.stacks,
	ref		boolean	o.on.sync.implemented,
	ref		boolean	o.on.load.implemented,
	ref		boolean	o.on.process.implemented,
	ref		boolean	o.on.get.implemented,
	ref		boolean	o.on.show.implemented,
	ref		boolean	o.on.update.implemented,
	ref		boolean	o.on.post.implemented,
	ref		boolean	o.on.acknowledge.implemented)
{
	long	dll.id
	long	position.pointer
	long	position.function.tree
	string	method(LENGTH_IMPL_METHOD)
	string	bod.dll.code(LENGTH_DLL_CODE)
	boolean	bottom.level.function
	boolean	return.0.implementation

	o.on.sync.implemented = false
	o.on.load.implemented = false
	o.on.process.implemented = false
	o.on.get.implemented = false
	o.on.show.implemented = false
	o.on.update.implemented = false
	o.on.post.implemented = false
	o.on.acknowledge.implemented = false

	|* Get all methods present in the BOD, even if not implemented in the
	|* actual FP.
	RETIFNOK( get.code.bod.dll2( "sb", i.bod, i.identifier, bod.dll.code ))

	dll.id = load_dll( "o" & trim$( bod.dll.code ), DLL_SILENT_ERR )

	if dll.id = 0 then
		|* DLL not found.
		return( 0 )	|* Early return!
	endif


	|* Get all methods implemented in the actual FP only.
	|* A method is implemented if a supporting or routing DLL is present
	|* for the method.
	for position.function.tree = 1 to i.used.size.function.tree.stacks
		bottom.level.function = true

		|* Check if current stack position is present as pointer for
		|* other stack positions at a higher position in the stack.
		|* If so, the current function has one or more childs and is
		|* not a bottom level function. Only bottom level functions
		|* will be checked.
		for position.pointer = position.function.tree to
					i.used.size.function.tree.stacks
			if i.pointer.function.tree.stack(position.pointer) =
					position.function.tree then
				|* Child is found. Skip current stack position
				|* and continue with next stack position.
				bottom.level.function = false

				break
			endif
		endfor

		if not bottom.level.function then
			continue
		endif

		|* Current function is lowest in tree (no childs are present)!
		if method.function.tree.implemented(
				i.bod,
				position.function.tree,
				i.function.tree.stack,
				i.pointer.function.tree.stack,
				method,				|* Ref
				return.0.implementation ) then	|* Ref
			on case trim$( method )
			case ON_SYNC:
				o.on.sync.implemented = true
				break
			case ON_LOAD:
				o.on.load.implemented = true
				break
			case ON_PROCESS:
				o.on.process.implemented = true
				break
			case ON_GET:
				o.on.get.implemented = true
				break
			case ON_SHOW:
				o.on.show.implemented = true
				break
			case ON_UPDATE:
				o.on.update.implemented = true
				break
			case ON_POST:
				o.on.post.implemented = true
				break
			case ON_ACKNOWLEDGE:
				o.on.acknowledge.implemented = true
				break
			default:
				dal.set.error.message(
					"@Method '" & trim$( method ) &
					"' not supported." )

				return( DALHOOKERROR )
			endcase
		else
			if not return.0.implementation then
				if get_function(
						dll.id,
						bod.dll.code(1;5) & "." &
						bod.dll.code(6) & "." &
						method ) <> 0 then
					on case trim$( method )
					case ON_SYNC:
						o.on.sync.implemented = true
						break
					case ON_LOAD:
						o.on.load.implemented = true
						break
					case ON_PROCESS:
						o.on.process.implemented = true
						break
					case ON_GET:
						o.on.get.implemented = true
						break
					case ON_SHOW:
						o.on.show.implemented = true
						break
					case ON_UPDATE:
						o.on.update.implemented = true
						break
					case ON_POST:
						o.on.post.implemented = true
						break
					case ON_ACKNOWLEDGE:
						o.on.acknowledge.implemented =
									true
						break
					default:
						dal.set.error.message(
						"@Method '" & trim$( method ) &
						"' not supported." )

						return( DALHOOKERROR )
					endcase
				endif
			endif
		endif
	endfor

	return( 0 )
}
function boolean method.function.tree.implemented(
	const		string	i.bod,
	const		long	i.position.function.tree,
	const		string	i.function.tree.stack(,),
	const		long	i.pointer.function.tree.stack(),
	ref		string	o.method,
	ref		boolean	o.return.0.implementation)
{
	long	dll.id
	long	function.id
	long	position
	long	pointer
	string	dll.code(LENGTH_DLL_CODE)
	string	function.name(LENGTH_FUNCTION_NAME)
	boolean	implemented

	#define	BOTTOM_LEVEL	position = i.position.function.tree
	#define	TOP_LEVEL	i.pointer.function.tree.stack(position) = 0

	o.method = ""
	o.return.0.implementation = false
	implemented = true
	pointer = i.position.function.tree

	|* Go from current function to initial parent function via the path
	|* using the pointers.
	|* For all functions into the tree, check if the functions are present.

	|* Example:
	|* Hook.OnExecute.ItemMasterBOD.OnSync (boibdbl00st00)	TOP
	|* tcbod.dll2501.Hook.OnExecute.ItemMasterBOD.OnSync
	|* tcbod.dll9501.Hook.OnExecute.ItemMasterBOD.OnSync	BOTTOM

	for position = i.position.function.tree to 1 STEP -1
		if position = pointer then
			|* Function within function tree is reached.

			|* Get pointer
			function.name = i.function.tree.stack(1,pointer)
			pointer = i.pointer.function.tree.stack(position)

			if not implemented then
				|* Method is not implemented. Continuing to
				|* top level is needed to get the method.
				continue
			endif

			if BOTTOM_LEVEL then
				if not bottom.level.function.ok(
						function.name,
						o.return.0.implementation )|*Ref
									then
					implemented = false

					continue
				endif

				if o.return.0.implementation then
					|* For specific 'function':
					|* "Return(0) Implementation" DLL and
					|* function can not be checked.
					|* So continue.
					continue
				endif
			endif

			|* For the top level ('st'-DLL funcion) the DLL code
			|* can not be extracted from the function name, because
			|* an other syntax is used by tools. Furthermore the
			|* function is a local function and can not be checked
			|* by 'get_function'.
			if not TOP_LEVEL then
				|* Check if DLL object is present.
				dll.code = get.dll.code.from.function(
						function.name )

				|* Check if DLL object is present and not
				|* expired.
|				if not borgt.dll1001.dll.exists( dll.code ) then
				if not bod.dll.exists( dll.code ) then
					|* DLL not found or expired.
					implemented = false

					continue
				endif

				|* DLL is present and not expired. Load the DLL.
				dll.id = load_dll(
						"o" & trim$( dll.code ),
						DLL_SILENT_ERR )

				if dll.id = 0 then
					|* DLL not found.
					implemented = false

					continue
				endif

				|* Check if function is present.
				function.id = get_function(
						dll.id,
						trim$( function.name ) )

				if function.id = 0 then
					|* Function not found.
					implemented = false

					continue
				endif
			endif
		endif
	endfor

	|* Get the method out of the function name.
	position = pos( function.name, "BOD.On" )
	o.method = function.name(position + 4)

	return( implemented )
}

function string get.converted.to.roman(
	const	long	i.number )
{
	long	multiplier
	long	number
	long	dummy.value
	string	roman(25)

	roman = ""
	number = i.number

	|* Handle thousands
	multiplier = (number * 1.0) / (1000 * 1.0)

	if multiplier > 0 then
		|* Start with number of 'M' as specified in multiplier.
		dummy.value = set.mem( roman, "M", multiplier )

		number = number - (multiplier * 1000)
	endif

	|* Handle hundreds
	multiplier = (number * 1.0) / (100 * 1.0)

	if multiplier > 0 then
		roman = add.roman( roman, multiplier, "M", "D", "C" )
			|* Ref: roman

		number = number - (multiplier * 100)
	endif

	|* Handle tens
	multiplier = (number * 1.0) / (10 * 1.0)

	if multiplier > 0 then
		roman = add.roman( roman, multiplier, "C", "L", "X" )
			|* Ref: roman

		number = number - (multiplier * 10)
	endif

	|* Handle ones
	roman = add.roman( roman, number, "X", "V", "I" )

	return( roman )
}

function string add.roman(
	const	string	i.roman,
	const	long	i.number,
	const	string	i.roman.unit.1,
	const	string	i.roman.unit.2,
	const	string	i.roman.unit.3 )
{
	|* i.roman.unit.10 = 1000, 100 or 10
	|* i.roman.unit.5 = 500, 50 or 5
	|* i.roman.unit.1 = 100, 10 or 1

	long	dummy.value
	string	roman.to.add(3)

	roman.to.add = ""

	on case i.number
	case 1:
	case 2:
	case 3:
		dummy.value = set.mem( roman.to.add, i.roman.unit.3, i.number )

		return( i.roman & roman.to.add )
	case 4:
		return( i.roman & i.roman.unit.3 & i.roman.unit.2 )
	case 5:
		return( i.roman & i.roman.unit.2 )
	case 6:
	case 7:
	case 8:
		dummy.value = set.mem(
				roman.to.add,
				i.roman.unit.3,
				i.number - 5 )

		return( i.roman & i.roman.unit.2 & roman.to.add )
	case 9:
		return( i.roman & i.roman.unit.3 & i.roman.unit.1 )
	default:
		return( i.roman )
	endcase
}

function string get.dll.code.from.function(
	const	string	i.function.name )
{
	return( trim$( i.function.name(1;5) ) & trim$( i.function.name(7;7) ) )
}
function boolean bottom.level.function.ok(
	const		string	i.function.name,
	ref		boolean	o.return.0.implementation )
{
	FunctionUsage
	Expl:	This function checks
	EndFunctionUsage

	o.return.0.implementation = false

	if trim$( i.function.name ) = RETURN_0_IMPLEMENTATION then
		|* Function contains only 'return(0)'.
		o.return.0.implementation = true
		return( false )
	endif

	if pos( i.function.name, "bod.dll" ) = 0 and
	   pos( i.function.name, "bia.dll" ) = 0 then
		|* Function is not a function of:
		|* - Supporting DLL
		|* - Routing DLL
		|* - tcbod.dll0032
		|* - tfbia.dll....
		|* Thus, function must be a function of the 'st'-DLL.
		|* Is considered as not implemented.
		return( false )
	endif

	return( true )
}

function long custom.bod.dlls.generated.on.backend(
	const	string	i.bod,
	const	string	i.identifier,
	ref	boolean	o.bod.is.generated )
{
	string	bod.dll.code(LENGTH_DLL_CODE)

	o.bod.is.generated = false

	|* Check if 'sb'-DLL is generated.
	RETIFNOK( get.code.bod.dll2( "sb", i.bod, i.identifier, bod.dll.code ) )

	if not bod.dll.exists( bod.dll.code ) then
		|* 'sb'-DLL not found or expired.
		return( 0 )	|* Early return.
	endif

	|* Check 'st'-DLL.
	RETIFNOK( get.code.bod.dll2( "st", i.bod, i.identifier, bod.dll.code ) )

	if not bod.dll.exists( bod.dll.code ) then
		|* BOD 'st'-DLL not found or expired.
		return( 0 )	|* Early return.
	endif

	|* Conditions are met. BOD DLLs (sb + st) are generated and not expired.
	o.bod.is.generated = true

	return( 0 )
}
function long get.implemented.function.tree.on.execute.hooks(
	const	string	i.bod,
	const	string	i.identifier,
	ref	string	o.function.tree.stack(,),
	ref	long	o.pointer.function.tree.stack(),
	ref	long	o.used.size.function.tree.stacks )
{
	long	size.function.tree.stacks
	string	dll.code(LENGTH_DLL_CODE)
	string	file.name(LENGTH_FILE_NAME)

	#define	ON_EXEC_FUNCTION( i_BOD, i_METHOD )
^		"Hook.OnExecute." & trim$( i.bod ) & "." & ##i_METHOD##

	size.function.tree.stacks = 0
	free.mem( o.function.tree.stack )
	free.mem( o.pointer.function.tree.stack )
	o.used.size.function.tree.stacks = 0

	|**********************************************************************
	|* Handle 'st'-DLL
	|**********************************************************************
	RETIFNOK( get.code.bod.dll2( "st", i.bod, i.identifier, dll.code ) )
			|* Ref: dll.code

	RETIFNOK( get.file.name.including.path(
			dll.code,
			file.name ) )	|* Ref

	size.function.tree.stacks = INCREASE_SIZE_STACK	|* Multiples of 10 only!

	allocate.memory.function.tree.stacks(
		o.function.tree.stack,		|* Ref
		o.pointer.function.tree.stack,	|* Ref
		size.function.tree.stacks )	|* Ref

	|* Add 'OnExecute' functions of all methods to 'function.tree.stack'.
	|* During analysing of the 'st'-DLL the program will check of the
	|* declared function exists.
	o.function.tree.stack(1,1) = ON_EXEC_FUNCTION( i.bod, ON_SYNC )
	o.function.tree.stack(1,2) = ON_EXEC_FUNCTION( i.bod, ON_LOAD )
	o.function.tree.stack(1,3) = ON_EXEC_FUNCTION( i.bod, ON_PROCESS )
	o.function.tree.stack(1,4) = ON_EXEC_FUNCTION( i.bod, ON_GET )
	o.function.tree.stack(1,5) = ON_EXEC_FUNCTION( i.bod, ON_SHOW )
	o.function.tree.stack(1,6) = ON_EXEC_FUNCTION( i.bod, ON_UPDATE )
	o.function.tree.stack(1,7) = ON_EXEC_FUNCTION( i.bod, ON_POST )
	o.function.tree.stack(1,8) = ON_EXEC_FUNCTION( i.bod, ON_ACKNOWLEDGE )
	o.used.size.function.tree.stacks = 8

	|* Get implemented functions of the earlier declared functions.
	RETIFNOK( get.implemented.functions(
			file.name,
			o.function.tree.stack,			|* Ref
			o.pointer.function.tree.stack,		|* Ref
			o.used.size.function.tree.stacks,	|* Ref
			size.function.tree.stacks ) )		|* Ref

	|**********************************************************************
	|* Handle supporting DLL.
	|**********************************************************************
	if dll.type.in.function.tree(
			SUPPORTING_DLL,
			o.function.tree.stack,
			o.used.size.function.tree.stacks,
			dll.code ) and	|* Ref
	   bod.dll.exists( dll.code ) then
		|* Functions of supporting DLL are present in
		|* 'function.tree.stack'. Check supporting DLL.
		RETIFNOK( get.file.name.including.path(
				dll.code,
				file.name ) )	|* Ref

		RETIFNOK( get.implemented.functions(
				file.name,
				o.function.tree.stack,			|* Ref
				o.pointer.function.tree.stack,		|* Ref
				o.used.size.function.tree.stacks,	|* Ref
				size.function.tree.stacks ) )		|* Ref
	endif

	|**********************************************************************
	|* Handle routing DLL.
	|**********************************************************************
	if dll.type.in.function.tree(
			ROUTING_DLL,
			o.function.tree.stack,
			o.used.size.function.tree.stacks,
			dll.code ) and	|* Ref
	   bod.dll.exists( dll.code ) then
		|* Functions of routing DLL are present in
		|* 'function.tree.stack'. Check routing DLL.
		RETIFNOK( get.file.name.including.path(
				dll.code,
				file.name ) )	|* Ref

		RETIFNOK( get.implemented.functions(
				file.name,
				o.function.tree.stack,			|* Ref
				o.pointer.function.tree.stack,		|* Ref
				o.used.size.function.tree.stacks,	|* Ref
				size.function.tree.stacks ) )		|* Ref
	endif

	return( 0 )
}
function long get.implemented.functions(
	const	string	i.file.name,
	ref	string	io.function.tree.stack(,),
	ref	long	io.pointer.function.tree.stack(),
	ref	long	io.used.size.function.tree.stacks,
	ref	long	io.size.function.tree.stacks )
{
	long	line.number
	long	fp.file
	long	used.size.function.tree.stack
	long	position
	long	pointer
	long	return.value
	string	function.name(LENGTH_FUNCTION_NAME)
	boolean	in.function.body
	boolean	in.dll.usage
	boolean	in.function.usage
	boolean	analyse.function
	boolean return.0.implementation
	string	e.line

	used.size.function.tree.stack = io.used.size.function.tree.stacks

	RETIFNOK( open.file( i.file.name, "r", fp.file ))

	|* Get the first line of the st-DLL file.
	return.value = seq.gets( e.line, LENGTH_LINE, fp.file )

	analyse.function = false
	return.0.implementation = false
	line.number = 0

	while return.value = 0
		line.number = line.number + 1	|* Just for debugging

		|* Determine start of function.
		if e.line(1;8) = "function" and
		   not analyse.function then
			for pointer = 1 to used.size.function.tree.stack
				function.name = io.function.tree.stack(
							1,pointer)

				if pos(	    e.line,
					    "long " &
					    trim$( function.name ) ) > 0 then
					|* Function to be analyse (start of
					|* functin) is reached.
					analyse.function = true
					in.function.body = false
					in.dll.usage = false
					in.function.usage = false
					return.0.implementation = true

					break
				endif
			endfor
		endif

		if analyse.function then
			if analyse.line( e.line,
					 in.function.body,	  |* Ref (io)
					 in.dll.usage,		  |* Ref (io)
					 in.function.usage ) then |* Ref (io)
				|* Line is filled.
				|* Check if a 'bod.dll' function is called.
				position = pos( e.line, "bod.dll" )

				if position = 0 then
					|* Check if a 'bia.dll' function is
					|* called.
					position = pos( e.line, "bia.dll" )
				endif

				if position > 0 then
					|* String 'bod.dll' or 'bia.dll' is
					|* found. Will be assumed as a function
					|* call to a BOD DLL.
					function.name =
					get.function.name.from.line(
						e.line,
						position )

					add.function.to.function.tree.stack(
					    pointer,
					    function.name,
					    io.function.tree.stack,
					    io.pointer.function.tree.stack,
					    io.used.size.function.tree.stacks,
					    io.size.function.tree.stacks )

					|* Because a call to a BOD DLL function
					|* is present, the function can not be
					|* a 'return(0)' implementation.
					return.0.implementation = false
				else
					if not line.is.return.zero.line(
							e.line ) then
						|* Line is filled and not with
						|* 'return(0)'. Function can
						|* not be a 'return(0)'
						|* implementation.
						return.0.implementation = false
					endif
				endif
			endif

			|* Determine end of function.
			if pos( e.line, "}" ) = 1 then
				|* End of function is reached.
				analyse.function = false

				if return.0.implementation then
					|* End of function is reached.
					add.function.to.function.tree.stack(
					    pointer,
					    RETURN_0_IMPLEMENTATION,
					    io.function.tree.stack,
					    io.pointer.function.tree.stack,
					    io.used.size.function.tree.stacks,
					    io.size.function.tree.stacks )
				endif
			endif
		endif

		|* Get next line of file.
		return.value = seq.gets( e.line, LENGTH_LINE, fp.file )
	endwhile

	RETIFNOK( close.file( i.file.name, fp.file ))

	return( 0 )
}
function add.function.to.function.tree.stack(
	const	long	i.pointer,
	const	string	i.function,
	ref	string	io.function.tree.stack(,),
	ref	long	io.pointer.function.tree.stack(),
	ref	long	io.used.size.function.tree.stacks,
	ref	long	io.size.function.tree.stacks )
{
	if io.size.function.tree.stacks \ INCREASE_SIZE_STACK = 0 then
		|* Increase size of function stack.
		io.size.function.tree.stacks =
			io.size.function.tree.stacks + INCREASE_SIZE_STACK

		allocate.memory.function.tree.stacks(
			io.function.tree.stack,
			io.pointer.function.tree.stack,
			io.size.function.tree.stacks )
	endif

	|* Add function to 'io.function.tree.stack'.
	io.used.size.function.tree.stacks =
					io.used.size.function.tree.stacks + 1

	io.function.tree.stack(1,io.used.size.function.tree.stacks) =
					trim$( i.function )

	|* Add pointer to 'io.pointer.function.tree.stack'.
	|* The pointer can be used to determine the position of the parent
	|* function in the 'fucntion.tree.stack'.
	io.pointer.function.tree.stack(io.used.size.function.tree.stacks) =
					i.pointer
}

function boolean line.is.return.zero.line(
	const	string	i.line )
{
	long	position
	string	character
	string	dummy.character
	string	line(LENGTH_LINE)

	line = ""

	dummy.character = get.first.character( i.line, position )
		|* Ref: Position

	if position > 0 then
		for position = position to len( i.line )
			character = i.line(position;1)

			if not isspace( character ) then
				line = line & character
			endif
		endfor

		line = tolower$( line )

		if trim$( line ) = "return(0)" then
			return( true )
		endif
	endif

	return( false )
}

function boolean analyse.line(
	const	string	i.line,
	ref	boolean	io.in.function.body,
	ref	boolean	io.in.dll.usage,
	ref	boolean	io.in.function.usage )
{
	long	dummy.position
	string	line.to.lower(LENGTH_LINE)

	|* Check for empty line/comment line.
	if isspace( i.line ) or
	   get.first.character( i.line, dummy.position ) = "|" then
		|* Empty or comment line. Do not analyse line.
		return( false )
	endif

	|* Check for start function body.
	if not io.in.function.body and
	   i.line(1;1) = "{" then
		|* Start of function body is reached.
		io.in.function.body = true

		return( false )
	endif

	|* Check for end function body.
	if io.in.function.body and
	   i.line(1;1) = "}" then
		|* End of function body is reached.
		io.in.function.body = false

		return( false )
	endif

	|* For checks on 'DLLUsage' and 'FunctionUsage' use line
	|* converted to lower characters.
	|* First check on 'EndDLLUsage' and 'EndFunctionUsage' before
	|* 'DLLUsage' and 'FunctionUsage', because 'DLLUsage' and
	|* 'FunctionUsage' are part of 'EndDLLUsage' and 'EndFunctionUsage'.
	line.to.lower = trim$( tolower$( i.line ) )

	|* Check for start DLL usage.
	if not io.in.dll.usage and
	   pos( line.to.lower, "dllusage" )  > 0 then
		|* Start of DLL usage.
		io.in.dll.usage = true

		return( false )
	endif

	|* Check for end DLL usage.
	if io.in.dll.usage and
	   pos( line.to.lower, "enddllusage" ) > 0 then
		|* End of DLL usage.
		io.in.dll.usage = false

		return( false )
	endif

	|* Check for start function usage.
	if not io.in.function.usage and
	   pos( line.to.lower, "functionusage" ) > 0 then
		|* Start of function usage.
		io.in.function.usage = true

		return( false )
	endif

	|* Check for end function usage.
	if io.in.function.usage and
	   pos( line.to.lower, "endfunctionusage" ) > 0 then
		|* End of function usage.
		io.in.function.usage = false

		return( false )
	endif

	if io.in.function.body and
	   not io.in.dll.usage and
	   not io.in.function.usage then
		|* Line is a 'normal' line in the function body.
		|* Line must be checked.
		return( true )
	endif

	|* Line is not a 'normal' line. Do not check the line.
	return( false )
}
function string get.first.character(
	const	string	i.line,
	ref	long	o.position )
{
	long	length
	string	character

	length = len( i.line )

	for o.position = 1 to length
		character = i.line(o.position;1)

		if not isspace( character ) and
		   not asc( character ) = 9 then	|* Horizontal tab
			return( character )
		endif
	endfor

	o.position = 0

	return( "" )
}
function string get.function.name.from.line(
	const	string	i.line,
	const	long	i.start.position.bod.dll )
{
	long	position
	string	character
	string	function.name(LENGTH_FUNCTION_NAME)

	function.name = ""

	|* - 2 is needed for package code.
	|*
	|* Example: tdbod.dll1205....
	|* - i.start.position.bod.dll = 3
	|* - Start position function name = 1 (3-2)
	|*
	for position = i.start.position.bod.dll - 2 to len( i.line )
		character = i.line(position)

		if character = chr$(040) or	|* chr$(040) = (
		   character = chr$(044) then	|* chr$(044) = ,
			|* End of function name is reached.
			break
		else
			function.name = function.name & character
		endif
	endfor

	return( function.name )
}

function long open.file(
	const	string	i.file,
		string	i.open.mode(2),
	ref	long	o.file.pointer )
{
	o.file.pointer = seq.open( i.file, i.open.mode )

	if o.file.pointer < 1 then
		dal.set.error.message(
			"@File '" & strip$( i.file ) &
			"' can not be opened (error: " &
			str$( o.file.pointer ) & ")." )

		return( DALHOOKERROR )
	endif

	return( 0 )
}
function long close.file(
	const	string	i.file,
	const	long	i.file.pointer )
{
	if seq.close( i.file.pointer ) <> 0 then
		dal.set.error.message(
			"@File '" & strip$( i.file ) &
			"' can not be closed (error: " &
			str$( e ) & ")." )

		return( DALHOOKERROR )
	endif

	return( 0 )
}

function long get.file.name.including.path(
	const	string	i.script.code,
	ref	string	o.file.name )
{
		long		no.vrcs.in.stack
	domain	ttadv.cpac	package
	domain	ttadv.cmod	module
	domain	ttadv.cprs	script
	domain	ttadv.vers	script.version fixed
	domain	ttadv.rele	script.release fixed
	domain	ttadv.cust	script.customer fixed
	domain	ttadv.vers	vrc.version.stack(MAX_LEVELS)
	domain	ttadv.rele	vrc.release.stack(MAX_LEVELS)
	domain	ttadv.cust	vrc.customer.stack(MAX_LEVELS)

	o.file.name = ""

	package = i.script.code(1;2)
	module = i.script.code(3;3)
	script = i.script.code(6)

	RETIFNOK( get.derivation.structure(
			curr.pacc$,
			package,
			vrc.version.stack,	|* Ref
			vrc.release.stack,	|* Ref
			vrc.customer.stack,	|* Ref
			no.vrcs.in.stack ) )	|* Ref

	RETIFNOK( get.vrc.of.apps.script(
			package,
			module,
			script,
			vrc.version.stack,
			vrc.release.stack,
			vrc.customer.stack,
			no.vrcs.in.stack,
			script.version,		|* Ref
			script.release,		|* Ref
			script.customer ) )	|* Ref

	RETIFNOK( get.script.file.name.including.path(
			package,
			module,
			script,
			script.version,
			script.release,
			script.customer,
			o.file.name ) )		|* Ref

	return( 0 )
}

function long get.vrc.of.apps.script(
	const	string	i.package,
	const	string	i.module,
	const	string	i.script,
	const	string	i.vrc.version.stack(,),
	const	string	i.vrc.release.stack(,),
	const	string	i.vrc.customer.stack(,),
	const	long	i.nr.vrcs.in.stack,
	ref	string	o.version fixed,
	ref	string	o.release fixed,
	ref	string	o.customer fixed )
{
		long		vrc.number
		boolean		vrc.found
	domain	ttadv.vers	version
	domain	ttadv.rele	release
	domain	ttadv.cust	customer
	domain	ttyeno		expired

	vrc.found = false
	o.version = ""
	o.release = ""
	o.customer = ""

	for vrc.number = 1 to i.nr.vrcs.in.stack
		version = i.vrc.version.stack(1,vrc.number)
		release = i.vrc.release.stack(1,vrc.number)
		customer = i.vrc.customer.stack(1,vrc.number)

		select	ttadv230.expi:expired
		from	ttadv230
		where	ttadv230._index1 = {	:i.package,
						:i.module,
						:i.script,
						:version,
						:release,
						:customer }
		and	ttadv230._compnr = 0
		as set with 1 rows
		selectdo
			if expired = ttyeno.yes then
				dal.set.error.message(
					"@Script '" & trim$( i.package ) &
						      trim$( i.module ) &
						      trim$( i.script ) &
					"' is expired." )

				return( DALHOOKERROR )
			endif

			o.version = version
			o.release = release
			o.customer = customer

			vrc.found = true
		endselect

		if vrc.found then
			break
		endif
	endfor

	if not vrc.found then
		dal.set.error.message(
			"@VRC of script '" & trim$( i.package ) &
					      trim$( i.module ) &
					      trim$( i.script ) &
			"' not found." )

		return( DALHOOKERROR )
	endif

	return( 0 )
}

function long get.script.file.name.including.path(
	const	string	i.package,
	const	string	i.module,
	const	string	i.script,
	const	string	i.script.version fixed,
	const	string	i.script.release fixed,
	const	string	i.script.customer fixed,
	ref	string	o.file.name )
{
		string		package.vrc(14)
	domain	ttadv.path	path

	o.file.name = ""

	select	ttadv115.prdd:path
	from	ttadv115
	where	ttadv115._index1 = {	:i.package,
					:i.script.version,
					:i.script.release,
					:i.script.customer,
					ttadv.kord.program.script }
	and	ttadv115._compnr = 0
	as set with 1 rows
	selectdo
		package.vrc =
			strip$( i.package ) &
			strip$( i.script.version ) & "_" &
			strip$( i.script.release )

		if not isspace( i.script.customer ) then
			package.vrc =
				package.vrc & "_" & strip$( i.script.customer )
		endif

		o.file.name =
			trim$( path ) & "/" &
			package.vrc &
			"/p" & i.package & i.module &
			"/p" & i.module & trim$( i.script ) & "0"
	selectempty
		dal.set.error.message(
			"@Path of script '" & trim$( i.package ) &
			trim$( i.script.version ) & trim$( i.script.release ) &
			trim$( i.script.customer ) & "' not found'." )

		return( DALHOOKERROR )
	endselect

	return( 0 )
}
function long get.derivation.structure(
	const	string	i.package.combination,
	const	string	i.package,
	ref	string	o.vrc.version.stack(,),
	ref	string	o.vrc.release.stack(,),
	ref	string	o.vrc.customer.stack(,),
	ref	long	o.no.vrcs )
{
			boolean		end.of.structure
		domain	ttadv.vers	version
		domain	ttadv.rele	release
		domain	ttadv.cust	customer
	static		long		s.no.vrcs
	static		string		s.package.combination(8)
	static		boolean		s.package.vrc.found
	static	domain	ttadv.cpac	s.package
	static	domain	ttadv.vers	s.package.version
	static	domain	ttadv.rele	s.package.release
	static	domain	ttadv.cust	s.package.customer
	static	domain	ttadv.vers	s.vrc.version
	static	domain	ttadv.rele	s.vrc.release
	static	domain	ttadv.cust	s.vrc.customer
	static	domain	ttadv.vers	s.vrc.version.stack(MAX_LEVELS)
	static	domain	ttadv.rele	s.vrc.release.stack(MAX_LEVELS)
	static	domain	ttadv.cust	s.vrc.customer.stack(MAX_LEVELS)

	if set.mem( o.vrc.version.stack, "" ) = -1 or
	   set.mem( o.vrc.release.stack, "" ) = -1 or
	   set.mem( o.vrc.customer.stack, "" ) = -1 then
		dal.set.error.message(
			"@Stack variables vor VRC tree can not be resetted." )

		return( DALHOOKERROR )
	endif

	o.no.vrcs = 0

	|* Get the actual VRC by package combination/package.
	if trim$( i.package.combination ) <> trim$( s.package.combination ) or
	   trim$( i.package ) <> trim$( s.package ) then
		s.package.combination = i.package.combination
		s.package = i.package
		s.package.vrc.found = false

		select	ttaad121.vers:s.package.version,
			ttaad121.rele:s.package.release,
			ttaad121.cust:s.package.customer
		from	ttaad121
		where	ttaad121._index1 = {	:s.package.combination,
						:s.package }
		and	ttaad121._compnr = 0
		selectdo
			s.package.vrc.found = true
		endselect
	endif

	if not s.package.vrc.found then
		dal.set.error.message(
			"@VRC of package combination '" &
			trim$( i.package.combination ) & "' and package '" &
			trim$( i.package ) & "' not found." )

		return( DALHOOKERROR )
	endif

	|* Get the derivation structure of the VRC.
	if i.package <> s.package or
	   s.package.version <> s.vrc.version or
	   s.package.release <> s.vrc.release or
	   s.package.customer <> s.vrc.customer then
		|* (Re)fill the stacks.
		if set.mem( s.vrc.version.stack, "" ) = -1 or
		   set.mem( s.vrc.release.stack, "" ) = -1 or
		   set.mem( s.vrc.customer.stack, "" ) = -1 then
			dal.set.error.message(
				"@Static stack variables for VRC tree can " &
				"not be resetted." )

			return( DALHOOKERROR )
		endif

		s.package = i.package
		s.vrc.version = s.package.version
		s.vrc.release = s.package.release
		s.vrc.customer = s.package.customer

		s.no.vrcs = 1

		version = s.package.version
		release = s.package.release
		customer = s.package.customer

		|* Fill the stack with the first level.
		s.vrc.version.stack(1,s.no.vrcs) = version
		s.vrc.release.stack(1,s.no.vrcs) = release
		s.vrc.customer.stack(1,s.no.vrcs) = customer

		|**************************************************************
		|* Not all VRC's contain all components of a version. The first
		|* character of the customer is used to get a complete version.
		|* Example:
		|* The VRC that is filled in on the form is B40Cc4m512.
		|* e.vers.arr(1) = B40C e.rele.arr(1) = c4 e.cust.arr(1) = m512
		|* e.vers.arr(2) = B40P e.rele.arr(2) = c4 e.cust.arr(2) = m512
		|* e.vers.arr(3) = B40C e.rele.arr(3) = c4 e.cust.arr(3) = m511
		|* e.vers.arr(4) = B40P e.rele.arr(4) = c4 e.cust.arr(4) = m511
		|* e.vers.arr(5) = B40C e.rele.arr(5) = c4 e.cust.arr(5) = m510
		|* e.vers.arr(6) = B40P e.rele.arr(6) = c4 e.cust.arr(6) = m510
		|* The VRC B40Pc4m510 is derived from B40Uc4sp3.
		|**************************************************************

		end.of.structure = false

		while s.no.vrcs < MAX_LEVELS
			select	ttadv111.*
			from	ttadv111
			where	ttadv111._index1 = {	:i.package,
							:version,
							:release,
							:customer }
			and	( ttadv111.vedf <> "" or
				  ttadv111.redf <> "" or
				  ttadv111.cudf <> "" )
			and	ttadv111._compnr = 0
			as set with 1 rows
			selectdo
				s.no.vrcs = s.no.vrcs + 1

				s.vrc.version.stack(1,s.no.vrcs) = ttadv111.vedf
				s.vrc.release.stack(1,s.no.vrcs) = ttadv111.redf
				s.vrc.customer.stack(1,s.no.vrcs) =
								ttadv111.cudf

				version  = ttadv111.vedf
				release = ttadv111.redf
				customer = ttadv111.cudf
			selectempty
				|* End of derivation structure.
				end.of.structure = true

				break
			endselect

			if end.of.structure then
				GOTO END_OF_FUNCTION_ROUTINE
			endif
		endwhile

		mess(	"@More than " & str$(MAX_LEVELS) & " levels found " &
			"for VRC '" & trim$( s.package.version ) &
				      trim$( s.package.release ) &
				      trim$( s.package.customer ) &
			"'. Next levels are ignored!",
			1 )
	endif

	END_OF_FUNCTION_ROUTINE:
	copy.mem( o.vrc.version.stack, s.vrc.version.stack )
	copy.mem( o.vrc.release.stack, s.vrc.release.stack )
	copy.mem( o.vrc.customer.stack, s.vrc.customer.stack )
	o.no.vrcs = s.no.vrcs

	return( 0 )
}
function boolean bod.dll.exists(
	string	i.dll.code(LENGTH_DLL_CODE) )
{
	string	dummy.description

	|* Function 'tt.library' is used instead of 'load_dll', because in
	|* ERP LN an object can exists even if the DLL is set to expired.
	return( tt.library( trim$( i.dll.code ), dummy.description ))
}
function boolean dll.type.in.function.tree(
		long	i.dll.type,
	const	string	i.function.tree.stack(,),
	const	long	i.used.size.function.tree.stack,
	ref	string	o.dll.code )
{
	long	position
	string	function.name(LENGTH_FUNCTION_NAME)

	o.dll.code = ""

	for position = 1 to i.used.size.function.tree.stack
		function.name = trim$( i.function.tree.stack(1,position) )

		if function.name(1;13) = "tcbod.dll0032" then
			continue
		endif

		o.dll.code = function.name(1;5) & function.name(7;7)

		if ( function.name(3;8) = "bod.dll9" or
		     function.name(3;8) = "bia.dll9" ) and
		   i.dll.type = ROUTING_DLL then
			return( true )
		endif

		if ( function.name(3;7) = "bod.dll" or
		     function.name(3;7) = "bia.dll" ) and
		   i.dll.type = SUPPORTING_DLL then
			return( true )
		endif
	endfor

	o.dll.code = ""

	return( false )
}



function allocate.memory.function.tree.stacks(
	ref	string	io.function.tree.stack(,),
	ref	long	io.pointer.function.tree.stack(),
	ref	long	io.size.function.tree.stacks )
{
	allocate.memory.string.stack(
		LENGTH_FUNCTION_NAME,
		io.size.function.tree.stacks,
		io.function.tree.stack )

	allocate.memory.long.stack(
		io.size.function.tree.stacks,
		io.pointer.function.tree.stack )
}
function long get.code.bod.dll2(
		string	i.visibility(2),
	const	string	i.bod,
	const	string	i.identifier,
	ref	string	o.code )
{
	o.code = i.identifier(1;5) & "bl" & i.identifier(6;3) &
		 trim$( i.visibility ) & "00"

	return( 0 )
}
								
function cache.metadata(					
		domain	bobod.name	i.name,
		domain	bobod.impl	i.identifier,
			long		i.visibility,
		domain	bobod.type	i.type,
		domain	bobod.name	i.parent.bod,
		domain	boyesno		i.support.accounting.entity,
								
			long		i.receive.verbs,
			long		i.send.verbs,
		domain	boyesno		i.bod.release,		|public
								
		const	string		i.parm.string,
			long		i.position,
	ref	domain	bobod.name	io.name.stack(),
	ref	domain	bobod.impl	io.identifier.stack(),
	ref		long		io.visibility.stack(),
	ref	domain	bobod.type	io.type.stack(),
	ref	domain	bobod.name	io.parent.bod.stack(),
	ref	domain	boyesno		io.support.accounting.entity(),
	ref	string			io.parm.stack(,) ,
								
	ref		long		io.receive.verbs.stack(),
	ref		long		io.send.verbs.stack(),
	ref	domain	boyesno		io.bod.release.stack())
								
								
{
	long	nr.bods

								
	s.g.metadata.cached = true
	s.g.bods.in.stack = i.position

	if g.reshuffle.cache = false then
								
		nr.bods = get.number.of.positions.stack( s.g.name.stack )

		if i.position > nr.bods then
			allocate.memory.stack(
				nr.bods + INCREASE_SIZE_STACK,
				io.name.stack,			|* Ref
				io.identifier.stack,		|* Ref
				io.visibility.stack,		|* Ref
				io.type.stack,			|* Ref
				io.parent.bod.stack,		|* Ref	
								
				io.support.accounting.entity,
				io.parm.stack,
								
				io.receive.verbs.stack,		|* ref
				io.send.verbs.stack,		|* ref
				io.bod.release.stack)		|* ref
								
		endif
								
	else
		if i.position > FIXED_STACK_SIZE then
			s.g.bods.in.stack = FIXED_STACK_SIZE
			reshuffle.stack()
		else
			if s.g.bods.in.stack = 1 then
				allocate.memory.stack(
				FIXED_STACK_SIZE,
				io.name.stack,			|* Ref
				io.identifier.stack,		|* Ref
				io.visibility.stack,		|* Ref
				io.type.stack,			|* Ref
				io.parent.bod.stack,		|* Ref
				io.support.accounting.entity,	|* Ref
				io.parm.stack,			|* Ref
								
				io.receive.verbs.stack,		|* ref
				io.send.verbs.stack,		|* ref
				io.bod.release.stack)		|* ref
								
			endif
		endif
	endif

	io.name.stack(1,s.g.bods.in.stack) = i.name
	io.identifier.stack(1,s.g.bods.in.stack) = i.identifier
	io.visibility.stack(s.g.bods.in.stack) = i.visibility
	io.type.stack(s.g.bods.in.stack) = i.type
	io.parent.bod.stack(1,s.g.bods.in.stack) = i.parent.bod
								
	io.receive.verbs.stack(s.g.bods.in.stack) = i.receive.verbs
	io.send.verbs.stack(s.g.bods.in.stack) = i.send.verbs
	io.bod.release.stack(s.g.bods.in.stack) = i.bod.release
								
	io.support.accounting.entity(s.g.bods.in.stack) = i.support.accounting.entity
	io.parm.stack(1,s.g.bods.in.stack) = i.parm.string
								
}

function reshuffle.stack()
{
	long	i

	for i = 1 to FIXED_STACK_SIZE - 1
		s.g.name.stack(1,i)		= s.g.name.stack(1,i+1)
		s.g.identifier.stack(1,i)	= s.g.identifier.stack(1,i+1)
		s.g.visibility.stack(i)		= s.g.visibility.stack(i+1)
		s.g.type.stack(i)		= s.g.type.stack(i+1)
		s.g.parent.bod.stack(1,i)	= s.g.parent.bod.stack(1,i+1)
		s.g.support.ae.stack(i)		= s.g.support.ae.stack(i+1)
		s.g.parm.stack(1,i)		= s.g.parm.stack(1,i+1)
		s.g.receive.verbs.stack(i)	= s.g.receive.verbs.stack(i+1)
		s.g.send.verbs.stack(i)		= s.g.send.verbs.stack(i+1)
		s.g.bod.release.stack(i)	= s.g.bod.release.stack(i+1)
	endfor
}
		
function allocate.memory.stack(				
			long		i.nr.positions,
	ref	domain	bobod.name	o.name.stack(),
	ref	domain	bobod.impl	o.identifier.stack(),
	ref		long		o.visibility.stack(),
	ref	domain	bobod.type	o.type.stack(),
	ref	domain	bobod.name	o.parent.bod.stack(),
	ref	domain	boyesno		o.support.accounting.entity.stack(),
	ref		string		o.parm.stack(,) ,	
	ref		long		o.receive.verbs.stack(),
	ref		long		o.send.verbs.stack(),
	ref	domain	boyesno		o.bod.release.stack() )
{
	long	dummy.retval
	long	length.position
	long	dummy.convert

	dummy.retval = rdi.domain.string(			
			"bobod.name",				
			length.position,	|* Ref
			dummy.convert )		|* Ref

	allocate.memory.string.stack(
		length.position,
		i.nr.positions,
		o.name.stack )

	allocate.memory.string.stack(				
		length.position,
		i.nr.positions,
		o.parent.bod.stack )				

	dummy.retval = rdi.domain.string(			
			"bobod.impl",				
			length.position,	|* Ref
			dummy.convert )		|* Ref

	allocate.memory.string.stack(
		length.position,
		i.nr.positions,
		o.identifier.stack )

	allocate.memory.long.stack(
		i.nr.positions,
		o.visibility.stack )

	allocate.memory.type.stack(				
		i.nr.positions,
		o.type.stack )
			
	allocate.memory.boyesno.stack(				
		i.nr.positions,
		o.support.accounting.entity.stack )
								
	length.position = PARM_STRING
	allocate.memory.string.stack(
		length.position,
		i.nr.positions,
		o.parm.stack )
								
								
	allocate.memory.long.stack(
		i.nr.positions,
		o.receive.verbs.stack )

	allocate.memory.long.stack(
		i.nr.positions,
		o.send.verbs.stack )

	allocate.memory.boyesno.stack(
		i.nr.positions,
		o.bod.release.stack )
								
}

function allocate.memory.string.stack(
	const	long	i.length.position,
	const	long	i.nr.positions,
	ref	string	o.stack(,) )
{
	long	dummy.retval

	dummy.retval = alloc.mem(
			o.stack,
			i.length.position,
			i.nr.positions )
}

function allocate.memory.long.stack(
	const	long	i.nr.positions,
	ref	long	o.stack() )
{
	long	dummy.retval

	dummy.retval = alloc.mem(
			o.stack,
			i.nr.positions )
}

								
function allocate.memory.type.stack(
	const		long		i.nr.positions,
	ref	domain	bobod.type	o.stack() )		
|	ref	domain	tcbod.type	o.stack() )		
{
	long	dummy.retval

	dummy.retval = alloc.mem(
			o.stack,
			i.nr.positions )
}
								

|function allocate.memory.tcyesno.stack(			
function allocate.memory.boyesno.stack(				
	const		long	i.nr.positions,
	ref	domain	boyesno	o.stack() )			
|	ref	domain	tcyesno	o.stack() )			
{
	long	dummy.retval

	dummy.retval = alloc.mem(
			o.stack,
			i.nr.positions )
}


function cache.bods.01(domain	bobod.name i.name, ref long position, ref string parm.string)
{
		CACHE_BODS(
|* 1.				   		2.	    	3.	      	4.			  	5.				6.	7.		8.			9.
"AccountingBookDefinitionBOD",			"bogld001",	PUBLIC_BOD,	bobod.type.masterdata,		"AccountingBookDefinitionBOD",	boyesno.yes,	0,		B_SYNC,			boyesno.yes,
"AccountingBookDefinitionActualBOD",		"bogld003",	PROTECTED_BOD,	bobod.type.masterdata,		"AccountingBookDefinitionBOD",	boyesno.yes,	0,		0,			boyesno.no,
"AccountingBookDefinitionBudgetBOD",		"bofbs003",	PROTECTED_BOD,	bobod.type.masterdata,		"AccountingBookDefinitionBOD",	boyesno.yes,	0,		0,			boyesno.no,
"AccountingChartBOD",				"bogld002",	PUBLIC_BOD,	bobod.type.masterdata,		"AccountingChartBOD",		boyesno.yes,	0,		B_SYNC,			boyesno.yes,
"AccountingEntityBOD",				"boemm170",	PUBLIC_BOD,	bobod.type.masterdata,		"AccountingEntityBOD",		boyesno.yes,	0,		B_SYNC,			boyesno.yes,
"AccountingJournalBOD",				"bobia030",	PUBLIC_BOD,	bobod.type.masterdata,		"AccountingJournalBOD",		boyesno.yes,	0,		B_SYNC,			boyesno.yes,
"AssetMasterBOD",				"bomcs295",	PUBLIC_BOD,	bobod.type.masterdata,		"AssetMasterBOD",		boyesno.yes,	0,		B_SYNC,			boyesno.yes,
"AssetMasterServiceCarBOD",			"bomdm145",	PROTECTED_BOD,	bobod.type.masterdata,		"AssetMasterBOD",		boyesno.yes,	0,		0,			boyesno.no,
"BillFromPartyMasterBOD",			"bocom127",	PUBLIC_BOD,	bobod.type.masterdata,		"BillFromPartyMasterBOD",	boyesno.yes,	B_PROCESS,	B_SYNC,			boyesno.yes,
"BillFromPartyMasterInBOD",			"bocom172",	PROTECTED_BOD,	bobod.type.masterdata,		"BillFromPartyMasterBOD",	boyesno.yes,	0,		0,			boyesno.no,
"BillOfMaterialsBOD",				"boedm110",	PUBLIC_BOD,	bobod.type.masterdata,		"BillOfMaterialsBOD",		boyesno.yes,	B_PROCESS,	0,			boyesno.yes,
"BillOfMaterialsInBOD",				"boedm111",	PROTECTED_BOD,	bobod.type.masterdata,		"BillOfMaterialsBOD",		boyesno.yes,	0,		0,			boyesno.no,
"BillOfResourcesBOD",				"bobom001",	PUBLIC_BOD,	bobod.type.masterdata,		"BillOfResourcesBOD",		boyesno.yes,	B_PROCESS,	B_SYNC,			boyesno.yes,
"BillOfResourcesBOMBOD",			"bobom010",	PROTECTED_BOD,	bobod.type.masterdata,		"BillOfResourcesBOD",		boyesno.yes,	0,		0,			boyesno.no,
"BillOfResourcesBOMInBOD",			"bobom011",	PROTECTED_BOD,	bobod.type.masterdata,		"BillOfResourcesBOD",		boyesno.yes,	0,		0,			boyesno.no,
"BillOfResourcesROUBOD",			"borou101",	PROTECTED_BOD,	bobod.type.masterdata,		"BillOfResourcesBOD",		boyesno.yes,	0,		0,			boyesno.no,
"BillOfResourcesROUInBOD",			"borou102",	PROTECTED_BOD,	bobod.type.masterdata,		"BillOfResourcesBOD",		boyesno.yes,	0,		0,			boyesno.no,
"BillOfResourcesAssemblyBOD",			"boapl220",	PROTECTED_BOD,	bobod.type.masterdata,		"BillOfResourcesBOD",		boyesno.yes,	0,		0,			boyesno.no,
"BillToPartyMasterBOD",				"bocom117",	PUBLIC_BOD,	bobod.type.masterdata,		"BillToPartyMasterBOD",		boyesno.yes,	B_PROCESS,	B_SYNC,			boyesno.yes,
"BillToPartyMasterInBOD",			"bocom162",	PROTECTED_BOD,	bobod.type.masterdata,		"BillToPartyMasterBOD",		boyesno.yes,	0,		0,			boyesno.no,
"BusinessPlanBOD",				"bormp300",	PUBLIC_BOD,	bobod.type.masterdata,		"BusinessPlanBOD",		boyesno.yes,	B_PROCESS,	0,			boyesno.yes,
"BusinessPlanInBOD",				"bormp301",	PROTECTED_BOD,	bobod.type.masterdata,		"BusinessPlanBOD",		boyesno.yes,	0,		0,			boyesno.no,
"CarrierPartyBOD",				"bomcs083",	PUBLIC_BOD,	bobod.type.masterdata,		"CarrierPartyBOD",		boyesno.yes,	0,		B_SYNC,			boyesno.yes,
"ChartOfAccountsBOD",				"bogld008",	PUBLIC_BOD,	bobod.type.masterdata,		"ChartOfAccountsBOD",		boyesno.yes,	B_PROCESS,	B_SYNC,			boyesno.yes,
"ChartOfAccountsInBOD",				"bogld009",	PROTECTED_BOD,	bobod.type.masterdata,		"ChartOfAccountsBOD",		boyesno.yes,	0,		0,			boyesno.no
		)
}

|* Maximum number of 255 arguments reached. Continue with next macro.
function cache.bods.02(domain	bobod.name i.name, ref long position, ref string parm.string)
{
		CACHE_BODS(
|* The publication level of the CodeDefinitionBOD depends on the setting of the BOD parameter tcbod000... and not on the
|* "Support accounting entity" flag in boboddll1000.
|* 1.				   		2.	    	3.	      	4.			  	5.				6.	7.		8.			9.
"CodeDefinitionBOD",				"bomcs300",	PUBLIC_BOD,	bobod.type.masterdata,		"CodeDefinitionBOD",		YES,	B_SYNC+B_PROCESS, B_SYNC+B_PROCESS,	YES,
"CodeDefinitionCashFlowReasonDimensionBOD",	"bomcs313",	PROTECTED_BOD,	bobod.type.masterdata,		"CodeDefinitionBOD",		YES,	0,		0,			NO,
"CodeDefinitionDepartmentBOD",			"bomcs314",	PROTECTED_BOD,	bobod.type.masterdata,		"CodeDefinitionBOD",		YES,	0,		0,			NO,
"CodeDefinitionGeneralBOD",			"bomcs320",	PROTECTED_BOD,	bobod.type.masterdata,		"CodeDefinitionBOD",		YES,	0,		0,			NO,
"CodeDefinitionGeneralInBOD",			"bomcs321",	PROTECTED_BOD,	bobod.type.masterdata,		"CodeDefinitionBOD",		YES,	0,		0,			NO,
"CodeDefinitionFlexDimensionBOD",		"bogld010",	PROTECTED_BOD,	bobod.type.masterdata,		"CodeDefinitionBOD",		YES,	0,		0,			NO,
"CodeDefinitionJournalBookDimensionBOD",	"bogld050",	PROTECTED_BOD,	bobod.type.masterdata,		"CodeDefinitionBOD",		YES,	0,		0,			NO,
"CodeDefinitionMetaFixedDimensionBOD",		"bobia020",	PROTECTED_BOD,	bobod.type.masterdata,		"CodeDefinitionBOD",		YES,	0,		0,			NO,
"CodeDefinitionMetaFlexDimensionBOD",		"bobia010",	PROTECTED_BOD,	bobod.type.masterdata,		"CodeDefinitionBOD",		YES,	0,		0,			NO,
"CodeDefinitionPartyDimensionBOD",		"bocom105",	PROTECTED_BOD,	bobod.type.masterdata,		"CodeDefinitionBOD",		YES,	0,		0,			NO,
"CodeDefinitionProductionReasonBOD",		"bomcs315",	PROTECTED_BOD,	bobod.type.masterdata,		"CodeDefinitionBOD",		YES,	0,		0,			NO,
"CodeDefinitionRebateGroupBOD",			"bocms301",	PROTECTED_BOD,	bobod.type.masterdata,		"CodeDefinitionBOD",		YES,	0,		0,			NO,
"CodeDefinitionReconGroupDimensionBOD",		"bofin020",	PROTECTED_BOD,	bobod.type.masterdata,		"CodeDefinitionBOD",		YES,	0,		0,			NO,
"CodeDefinitionTaxAccountDimensionBOD",		"bogld070",	PROTECTED_BOD,	bobod.type.masterdata,		"CodeDefinitionBOD",		YES,	0,		0,			NO,
"CodeDefinitionTaxCodeDimensionBOD",		"bomcs311",	PROTECTED_BOD,	bobod.type.masterdata,		"CodeDefinitionBOD",		YES,	0,		0,			NO,
"CodeDefinitionTaxCountryDimensionBOD",		"bomcs312",	PROTECTED_BOD,	bobod.type.masterdata,		"CodeDefinitionBOD",		YES,	0,		0,			NO,
"CodeDefinitionUnitBOD",			"bomcs310",	PROTECTED_BOD,	bobod.type.masterdata,		"CodeDefinitionBOD",		YES,	0,		0,			NO,
"ConfiguredAssetMasterBOD",			"bobsc101",	PUBLIC_BOD,	bobod.type.masterdata,		"ConfiguredAssetMasterBOD",	YES,	0,		B_SYNC,			YES,
"ConfiguredAssetMasterGroupBOD",		"bobsc100",	PROTECTED_BOD,	bobod.type.masterdata,		"ConfiguredAssetMasterBOD",	YES,	0,		0,			NO,
"ConfiguredAssetMasterNonSerialBOD",		"bobsc103",	PROTECTED_BOD,	bobod.type.masterdata,		"ConfiguredAssetMasterBOD",	YES,	0,		0,			NO,
"ConfiguredAssetMasterSerialBOD",		"bobsc102",	PROTECTED_BOD,	bobod.type.masterdata,		"ConfiguredAssetMasterBOD",	YES,	0,		0,			NO,
"ConstrainedResourceBOD",			"borou010",	PUBLIC_BOD,	bobod.type.masterdata,		"ConstrainedResourceBOD",	YES,	0,		B_SYNC,			YES,
"ConstrainedResourceMachineTypeBOD",		"borou011",	PROTECTED_BOD,	bobod.type.masterdata,		"ConstrainedResourceBOD",	YES,	0,		0,			NO,
"ContactMasterBOD",				"bocom140",	PUBLIC_BOD,	bobod.type.masterdata,		"ContactMasterBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"ContactMasterInBOD",				"bocom141",	PROTECTED_BOD,	bobod.type.masterdata,		"ContactMasterBOD",		YES,	0,		0,			NO
|"CurrencyBOD",					"bomcs031",	PUBLIC_BOD,	bobod.type.masterdata,		"CurrencyBOD",			YES,	B_PROCESS,	B_SYNC,			NO
		)
}
|* Maximum number of 255 arguments reached. Continue with next macro.
function cache.bods.03(domain	bobod.name i.name, ref long position, ref string parm.string)
{
		CACHE_BODS(
|* 1.				   		2.	    	3.	      	4.			  	5.				6.	7.		8.			9.
"CurrencyExchangeRateMasterBOD",		"bomcs214",	PUBLIC_BOD,	bobod.type.masterdata,		"CurrencyExchangeRateMasterBOD",YES,	B_SYNC+B_LOAD,	B_SYNC,			YES,
"CurrencyExchangeRateMasterInBOD",		"bomcs216",	PROTECTED_BOD,	bobod.type.masterdata,		"CurrencyExchangeRateMasterBOD",YES,	0,		0,			NO,
"CurrencyExchangeRateMasterOutBOD",		"bomcs215",	PROTECTED_BOD,	bobod.type.masterdata,		"CurrencyExchangeRateMasterBOD",YES,	0,		0,			NO,
"CurrencyRateTypeBOD",				"bomcs213",	PUBLIC_BOD,	bobod.type.masterdata,		"CurrencyRateTypeBOD",		YES,	0,		B_SYNC,			YES,
"CustomerPartyMasterBOD",			"bocom115",	PUBLIC_BOD,	bobod.type.masterdata,		"CustomerPartyMasterBOD",	YES,	B_PROCESS,	B_SYNC,			YES,
"CustomerPartyMasterSoldToBOD",			"bocom110",	PROTECTED_BOD,	bobod.type.masterdata,		"CustomerPartyMasterBOD",	YES,	0,		0,			NO,
"CustomerPartyMasterSoldToInBOD",		"bocom160",	PROTECTED_BOD,	bobod.type.masterdata,		"CustomerPartyMasterBOD",	YES,	0,		0,			NO,
"FinancialCalendarBOD",				"bogld005",	PUBLIC_BOD,	bobod.type.masterdata,		"FinancialCalendarBOD",		YES,	0,		B_SYNC,			YES,
"FinancialCalendarCommonBOD",			"boccp070",	PROTECTED_BOD,	bobod.type.masterdata,		"FinancialCalendarBOD",		YES,	0,		0,			NO,
"FinancialCalendarPlanningBOD",			"bormp420",	PROTECTED_BOD,	bobod.type.masterdata,		"FinancialCalendarBOD",		YES,	0,		0,			NO,
"ItemMasterBOD",				"boibd501",	PUBLIC_BOD,	bobod.type.masterdata,		"ItemMasterBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"ItemMasterCommonBOD",				"boibd505",	PROTECTED_BOD,	bobod.type.masterdata,		"ItemMasterBOD",		YES,	0,		0,			NO,
"ItemMasterCommonInBOD",			"boibd506",	PROTECTED_BOD,	bobod.type.masterdata,		"ItemMasterBOD",		YES,	0,		0,			NO,
"ItemMasterRevisionBOD",			"boedm100",	PROTECTED_BOD,	bobod.type.masterdata,		"ItemMasterBOD",		YES,	0,		0,			NO,
"LaborCostMasterBOD",				"bopdm020",	PUBLIC_BOD,	bobod.type.masterdata,		"LaborCostMasterBOD",		YES,	0,		B_SYNC,			YES,
"LaborCostMasterProjectBOD",			"bopdm021",	PROTECTED_BOD,	bobod.type.masterdata,		"LaborCostMasterBOD",		YES,	0,		0,			NO,
"LnItemMasterDefaultsBOD",			"boibd502",	PUBLIC_BOD,	bobod.type.masterdata,		"LnItemMasterDefaultsBOD",	YES,	0,		B_SYNC,			YES,
"LnResourceCalendarBOD",			"boccp020",	PUBLIC_BOD,	bobod.type.masterdata,		"LnResourceCalendarBOD",	YES,	0,		B_SYNC,			YES,
"LnUserDefinedStructureBOD",			"bopdm095",	PUBLIC_BOD,	bobod.type.masterdata,		"LnUserDefinedStructureBOD",	YES,	0,		B_SYNC,			YES,
"LocationBOD",					"bomcs290",	PUBLIC_BOD,	bobod.type.masterdata,		"LocationBOD",			YES,	0,		B_SYNC,			YES,
"LocationDepartmentBOD",			"bomcs292",	PROTECTED_BOD,	bobod.type.masterdata,		"LocationBOD",			YES,	0,		0,			NO,
"LocationProjectBOD",				"bopdm600",	PROTECTED_BOD,	bobod.type.masterdata,		"LocationBOD",			YES,	0,		0,			NO,
"LocationSiteBOD",				"boemm010",	PROTECTED_BOD,	bobod.type.masterdata,		"LocationBOD",			YES,	0,		0,			NO,
"LocationWarehouseBOD",				"bomcs291",	PROTECTED_BOD,	bobod.type.masterdata,		"LocationBOD",			YES,	0,		0,			NO
		)
}
|* Maximum number of 255 arguments reached. Continue with next macro.
function cache.bods.04(domain	bobod.name i.name, ref long position, ref string parm.string)
{
		CACHE_BODS(
|* 1.				   		2.	    	3.	      	4.			  	5.				6.	7.		8.			9.
"ManufacturingPartBOD",				"boipu045",	PUBLIC_BOD,	bobod.type.masterdata,		"ManufacturingPartBOD",		YES,	B_PROCESS,	0,			YES,
"ManufacturingPartInBOD",			"boipu046",	PROTECTED_BOD,	bobod.type.masterdata,		"ManufacturingPartBOD",		YES,	0,		0,			NO,
"ManufacturerPartyMasterBOD",			"bomcs060",	PUBLIC_BOD,	bobod.type.masterdata,		"ManufacturerPartyMasterBOD",	YES,	B_PROCESS,	B_SYNC,			YES,
"ManufacturerPartyMasterInBOD",			"bomcs063",	PROTECTED_BOD,	bobod.type.masterdata,		"ManufacturerPartyMasterBOD",	YES,	0,		0,			NO,
"PayFromPartyMasterBOD",			"bocom118",	PUBLIC_BOD,	bobod.type.masterdata,		"PayFromPartyMasterBOD",	YES,	B_PROCESS,	B_SYNC,			YES,
"PayFromPartyMasterInBOD",			"bocom163",	PROTECTED_BOD,	bobod.type.masterdata,		"PayFromPartyMasterBOD",	YES,	0,		0,			NO,
"PersonBOD",					"bocom002",	PUBLIC_BOD,	bobod.type.masterdata,		"PersonBOD",			YES,	B_PROCESS,	B_SYNC,			YES,
"PersonEmployeeBOD",				"bocom003",	PROTECTED_BOD,	bobod.type.masterdata,		"PersonBOD",			YES,	0,		0,			NO,
"PersonInBOD",					"bocom004",	PROTECTED_BOD,	bobod.type.masterdata,		"PersonBOD",			YES,	0,		0,			NO,
"PersonnelBOD",					"bocom006",	PUBLIC_BOD,	bobod.type.masterdata,		"PersonnelBOD",			YES,	B_SYNC,		B_SYNC+B_PROCESS,	YES,
"PersonnelInBOD",				"bocom007",	PROTECTED_BOD,	bobod.type.masterdata,		"PersonnelBOD",			YES,	0,		0,			NO,
"PriceListBOD",					"bopcg010",	PUBLIC_BOD,	bobod.type.masterdata,		"PriceListBOD",			YES,	0,		B_SYNC,			YES,
"ProjectMasterBOD",				"bomcs360",	PUBLIC_BOD,	bobod.type.masterdata,		"ProjectMasterBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"ProjectMasterInBOD",				"bopdm040",	PROTECTED_BOD,	bobod.type.masterdata,		"ProjectMasterBOD",		YES,	0,		0,			NO,
"ProjectMasterPCSBOD",				"bopcs010",	PROTECTED_BOD,	bobod.type.masterdata,		"ProjectMasterBOD",		YES,	0,		0,			NO,
"ProjectMasterTPBOD",				"bopdm010",	PROTECTED_BOD,	bobod.type.masterdata,		"ProjectMasterBOD",		YES,	0,		0,			NO,
"RemitToPartyMasterBOD",			"bocom128",	PUBLIC_BOD,	bobod.type.masterdata,		"RemitToPartyMasterBOD",	YES,	B_PROCESS,	B_SYNC,			YES,
"RemitToPartyMasterInBOD",			"bocom173",	PROTECTED_BOD,	bobod.type.masterdata,		"RemitToPartyMasterBOD",	YES,	0,		0,			NO,
"SerialStructureBOD",				"bocfg210",	PUBLIC_BOD,	bobod.type.masterdata,		"SerialStructureBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"SerialStructureAsBuiltBOD",			"bomfc010",	PROTECTED_BOD,	bobod.type.masterdata,		"SerialStructureBOD",		YES,	0,		0,			NO,
"SerialStructureAsBuilt2BOD",			"bomfc011",	PROTECTED_BOD,	bobod.type.masterdata,		"SerialStructureBOD",		YES,	0,		0,			NO,
"SerialStructureInBOD",				"bocfg211",	PROTECTED_BOD,	bobod.type.masterdata,		"SerialStructureBOD",		YES,	0,		0,			NO,
"ShipFromPartyMasterBOD",			"bocom126",	PUBLIC_BOD,	bobod.type.masterdata,		"ShipFromPartyMasterBOD",	YES,	B_PROCESS,	B_SYNC,			YES,
"ShipFromPartyMasterInBOD",			"bocom171",	PROTECTED_BOD,	bobod.type.masterdata,		"ShipFromPartyMasterBOD",	YES,	0,		0,			NO,
"ShipToPartyMasterBOD",				"bocom116",	PUBLIC_BOD,	bobod.type.masterdata,		"ShipToPartyMasterBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"ShipToPartyMasterInBOD",			"bocom161",	PROTECTED_BOD,	bobod.type.masterdata,		"ShipToPartyMasterBOD",		YES,	0,		0,			NO
		)
}
|* Maximum number of 255 arguments reached. Continue with next macro.
function cache.bods.05(domain	bobod.name i.name, ref long position, ref string parm.string)
{
		CACHE_BODS(
|* 1.				   		2.	    	3.	      	4.			  	5.				6.	7.		8.			9.
"StationBOD",					"boasl145",	PROTECTED_BOD,	bobod.type.masterdata,		"WorkCenterBOD",		YES,	0,		0,			NO,
"SupplierPartyMasterBOD",			"bocom125",	PUBLIC_BOD,	bobod.type.masterdata,		"SupplierPartyMasterBOD",	YES,	B_PROCESS,	B_SYNC,			YES,
"SupplierPartyMasterInBOD",			"bocom170",	PROTECTED_BOD,	bobod.type.masterdata,		"SupplierPartyMasterBOD",	YES,	0,		0,			NO,
"SupplierPartyMasterBuyFromBOD",		"bocom119",	PROTECTED_BOD,	bobod.type.masterdata,		"SupplierPartyMasterBOD",	YES,	0,		0,			NO,
"SecurityPermissionMasterBOD",			"bobod101",	PUBLIC_BOD,	bobod.type.masterdata,		"SecurityPermissionMasterBOD",	NO,	0,		B_SYNC,			YES,
"SecurityRoleMasterBOD",			"bobod102",	PUBLIC_BOD,	bobod.type.masterdata,		"SecurityRoleMasterBOD",	NO,	0,		B_SYNC,			YES,
"SecurityUserMasterBOD",			"bobod103",	PUBLIC_BOD,	bobod.type.masterdata,		"SecurityUserMasterBOD",	NO,	B_SYNC,		B_SYNC+B_PROCESS,	YES,
"SecurityUserMasterInBOD",			"bobod104",	PROTECTED_BOD,	bobod.type.masterdata,		"SecurityUserMasterBOD",	NO,	0,		0,			NO,
"SundryCostMasterBOD",				"bopdm030",	PUBLIC_BOD,	bobod.type.masterdata,		"SundryCostMasterBOD",		YES,	0,		B_SYNC,			YES,
"SundryCostMasterProjectBOD",			"bopdm031",	PROTECTED_BOD,	bobod.type.masterdata,		"SundryCostMasterBOD",		YES,	0,		0,			NO,
"UOMGroupBOD",					"bomcs350",	PUBLIC_BOD,	bobod.type.masterdata,		"UOMGroupBOD",			YES,	0,		B_SYNC,			YES,
"WorkCellBOD",					"borpt045",	PROTECTED_BOD,	bobod.type.masterdata,		"WorkCenterBOD",		YES,	0,		0,			NO,
"WorkCenterBOD",				"borou001",	PUBLIC_BOD,	bobod.type.masterdata,		"WorkCenterBOD",		YES,	0,		B_SYNC,			YES,
"WorkShiftMasterBOD",				"boppl101",	PUBLIC_BOD,	bobod.type.masterdata,		"WorkShiftMasterBOD",		YES,	0,		B_SYNC,			YES,
"WorkShiftMasterWTSBOD",			"boppl100",	PROTECTED_BOD,	bobod.type.masterdata,		"WorkShiftMasterBOD",		YES,	0,		0,			NO,
"LnProductVariantBOD",				"bopcf100",	PUBLIC_BOD,	bobod.type.masterdata,		"LnProductVariantBOD",		YES,	0,		B_SYNC,			YES,
"LnProductVariantAssemblyBOD",			"boapl300",	PROTECTED_BOD,	bobod.type.masterdata,		"LnProductVariantBOD",		YES,	0,		0,			NO,
"LnProductVariantPCFBOD",			"bopcf500",	PROTECTED_BOD,	bobod.type.masterdata,		"LnProductVariantBOD",		YES,	0,		0,			NO,
"EmployeeWorkScheduleBOD",			"bomdm030",	PUBLIC_BOD,	bobod.type.masterdata,		"EmployeeWorkScheduleBOD",	YES,	B_SYNC,		0,			YES,
"AdvanceShipNoticeBOD",				"boinh804",	PUBLIC_BOD,	bobod.type.transactional,	"AdvanceShipNoticeBOD",		YES,	B_SYNC+B_LOAD+B_PROCESS, B_SYNC+B_PROCESS, YES,
"AdvanceShipNoticeInBOD",			"boinh807",	PROTECTED_BOD,	bobod.type.transactional,	"AdvanceShipNoticeBOD",		YES,	0,		0,			NO,
"AdvanceShipNoticeOrderBOD",			"boinh805",	PROTECTED_BOD,	bobod.type.transactional,	"AdvanceShipNoticeBOD",		YES,	0,		0,			NO,
"BankStatementBOD",				"bocmg510",	PUBLIC_BOD,	bobod.type.transactional,	"BankStatementBOD",		YES,	B_LOAD+B_PROCESS, 0,			YES,
"CarrierRouteBOD",				"boinh818",	PUBLIC_BOD,	bobod.type.transactional,	"CarrierRouteBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"CarrierRoutePlannedBOD",			"boinh480",	PROTECTED_BOD,	bobod.type.transactional,	"CarrierRouteBOD",		YES,	0,		0,			NO,
"ContractBOD",					"bopur032",	PUBLIC_BOD,	bobod.type.transactional,	"ContractBOD",			YES,	0,		B_SYNC,			YES,
"ContractPurchaseBOD",				"bopur033",	PROTECTED_BOD,	bobod.type.transactional,	"ContractBOD",			YES,	0,		0,			NO,
"ContractSalesBOD",				"bosls032",	PROTECTED_BOD,	bobod.type.transactional,	"ContractBOD",			YES,	0,		0,			NO
		)
}
|* Maximum number of 255 arguments reached. Continue with next macro.
function cache.bods.06(domain	bobod.name i.name, ref long position, ref string parm.string)
{
		CACHE_BODS(
|* 1.				   		2.	    	3.	      	4.			  	5.				6.	7.		8.			9.
"CorrectiveActionPlanBOD",			"bocpl100",	PUBLIC_BOD,	bobod.type.transactional,	"CorrectiveActionPlanBOD",	YES,	0,		B_SYNC,			YES,
"CreditTransferBOD",				"bocmg109",	PUBLIC_BOD,	bobod.type.transactional,	"CreditTransferBOD",		YES,	0,		B_SYNC,			YES,
"CustomerCallBOD",				"boclm100",	PUBLIC_BOD,	bobod.type.transactional,	"CustomerCallBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"CustomerCallInBOD",				"boclm101",	PROTECTED_BOD,	bobod.type.transactional,	"CustomerCallBOD",		YES,	0,		0,			NO,
"CustomerForecastBOD",				"bovmi006",	PROTECTED_BOD,	bobod.type.transactional,	"PlanningScheduleBOD",		YES,	0,		0,			NO,
"CustomerRemittanceAdviceBOD",			"bocmg250",	PUBLIC_BOD,	bobod.type.transactional,	"CustomerRemittanceAdviceBOD",	YES,	B_LOAD+B_PROCESS, 0,			YES,
"CustomerRemittanceAdviceInBOD",		"bocmg251",	PROTECTED_BOD,	bobod.type.transactional,	"CustomerRemittanceAdviceBOD",	YES,	0,		0,			NO,
"CustomerReturnBOD",				"bosls046",	PUBLIC_BOD,	bobod.type.transactional,	"CustomerReturnBOD",		YES,	0,		B_SYNC,			YES,
"DebitTransferBOD",				"bocmg409",	PUBLIC_BOD,	bobod.type.transactional,	"DebitTransferBOD",		YES,	0,		B_SYNC,			YES,
"DefectiveMaterialNoticeBOD",			"boncm100",	PUBLIC_BOD,	bobod.type.transactional,	"DefectiveMaterialNoticeBOD",	YES,	0,		B_SYNC,			YES,
"EmployeeWorkTimeBOD",				"botmm100",	PUBLIC_BOD,	bobod.type.transactional,	"EmployeeWorkTimeBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"EmployeeWorkTimeAssemblyBOD",			"botmm160",	PROTECTED_BOD,	bobod.type.transactional,	"EmployeeWorkTimeBOD",		YES,	0,		0,			NO,
"EmployeeWorkTimeGeneralBOD",			"botmm150",	PROTECTED_BOD,	bobod.type.transactional,	"EmployeeWorkTimeBOD",		YES,	0,		0,			NO,
"EmployeeWorkTimeInBOD",			"botmm101",	PROTECTED_BOD,	bobod.type.transactional,	"EmployeeWorkTimeBOD",		YES,	0,		0,			NO,
"EmployeeWorkTimePCSProjectBOD",		"botmm170",	PROTECTED_BOD,	bobod.type.transactional,	"EmployeeWorkTimeBOD",		YES,	0,		0,			NO,
"EmployeeWorkTimeProductionBOD",		"botmm120",	PROTECTED_BOD,	bobod.type.transactional,	"EmployeeWorkTimeBOD",		YES,	0,		0,			NO,
"EmployeeWorkTimeProjectBOD",			"botmm110",	PROTECTED_BOD,	bobod.type.transactional,	"EmployeeWorkTimeBOD",		YES,	0,		0,			NO,
"EmployeeWorkTimeServiceOrderBOD",		"botmm130",	PROTECTED_BOD,	bobod.type.transactional,	"EmployeeWorkTimeBOD",		YES,	0,		0,			NO,
"EmployeeWorkTimeWorkOrderBOD",			"botmm140",	PROTECTED_BOD,	bobod.type.transactional,	"EmployeeWorkTimeBOD",		YES,	0,		0,			NO,
"ExpenseReportBOD",				"botmm010",	PUBLIC_BOD,	bobod.type.transactional,	"ExpenseReportBOD",		YES,	B_SYNC,		0,			YES,
"ExpenseReportInBOD",				"botmm011",	PROTECTED_BOD,	bobod.type.transactional,	"ExpenseReportBOD",		YES,	0,		0,			NO
		)
}

function cache.bods.07(domain	bobod.name i.name, ref long position, ref string parm.string)
{
		CACHE_BODS(
|* 1.				   		2.	    	3.	      	4.			  	5.				6.	7.		8.			9.
"InspectDeliveryBOD",				"boinh808",	PUBLIC_BOD,	bobod.type.transactional,	"InspectDeliveryBOD",		YES,	B_SYNC,		0,			YES,
"InspectionOrderBOD",				"boptc100",	PUBLIC_BOD,	bobod.type.transactional,	"InspectionOrderBOD",		YES,	0,		B_SYNC,			YES,
"InspectionOrderOrderBOD",			"boptc120",	PROTECTED_BOD,	bobod.type.transactional,	"InspectionOrderBOD",		YES,	0,		0,			NO,
"InspectionOrderStorageBOD",			"boptc220",	PROTECTED_BOD,	bobod.type.transactional,	"InspectionOrderBOD",		YES,	0,		0,			NO,
"InventoryAdjustmentBOD",			"boinh810",	PUBLIC_BOD,	bobod.type.transactional,	"InventoryAdjustmentBOD",	YES,	B_SYNC+B_PROCESS, B_SYNC,		YES,
"InventoryAdjustmentAdjustmentBOD",		"boinh811",	PROTECTED_BOD,	bobod.type.transactional,	"InventoryAdjustmentBOD",	YES,	0,		0,			NO,
"InventoryAdjustmentCycleCountBOD",		"boinh812",	PROTECTED_BOD,	bobod.type.transactional,	"InventoryAdjustmentBOD",	YES,	0,		0,			NO,
"InventoryConsumptionBOD",			"bowmd801",	PUBLIC_BOD,	bobod.type.transactional,	"InventoryConsumptionBOD",	YES,	B_LOAD,		B_SYNC,			YES,
"InventoryConsumptionSLSBOD",			"bosls070",	PROTECTED_BOD,	bobod.type.transactional,	"InventoryConsumptionBOD",	YES,	0,		0,			NO,
"InventoryCountBOD",				"bowmd803",	PUBLIC_BOD,	bobod.type.transactional,	"InventoryCountBOD",		YES,	B_LOAD,		B_SYNC+B_GET,		YES,
"InventoryHoldBOD",				"bowmd802",	PUBLIC_BOD,	bobod.type.transactional,	"InventoryHoldBOD",		YES,	B_SYNC,		B_SYNC+B_PROCESS,	YES,
"InvoiceBOD",					"boacr701",	PUBLIC_BOD,	bobod.type.transactional,	"InvoiceBOD",			YES,	B_LOAD+B_PROCESS, B_SYNC,		YES,
"InvoiceSalesBOD",				"bosli705", 	PROTECTED_BOD, 	bobod.type.transactional,	"InvoiceBOD",			YES,	0,		0,			NO,	|#2044613.n
"InvoiceSalesFP8BOD",				"bosli701",	PROTECTED_BOD,	bobod.type.transactional,	"InvoiceBOD",			YES,	0,		0,			NO,
"InvoiceSalesACRBOD",				"boacr705",	PROTECTED_BOD,	bobod.type.transactional,	"InvoiceBOD",			YES,	0,		0,			NO,
"InvoiceSalesInBOD",				"bosli710",	PROTECTED_BOD,	bobod.type.transactional,	"InvoiceBOD",			YES,	0,		0,			NO,
"InvoiceWarehousingBOD",			"boinh819",	PROTECTED_BOD,	bobod.type.transactional,	"InvoiceBOD",			YES,	0,		0,			NO,
"LnClaimBOD",					"bocmm150",	PUBLIC_BOD,	bobod.type.transactional,	"LnClaimBOD",			YES,	0,		B_SYNC,			YES,
"LnClaimCustomerBOD",				"bocmm100",	PROTECTED_BOD,	bobod.type.transactional,	"LnClaimBOD",			YES,	0,		0,			NO,
"LnClaimSupplierBOD",				"bocmm200",	PROTECTED_BOD,	bobod.type.transactional,	"LnClaimBOD",			YES,	0,		0,			NO,
"LnContractLineBillingDateBOD",			"boctm011",	PUBLIC_BOD,	bobod.type.transactional,	"LnContractLineBillingDateBOD",	YES,	0,		B_SYNC,			YES,
"LnCostPegTransferBOD",				"boinh140",	PUBLIC_BOD,	bobod.type.transactional,	"LnCostPegTransferBOD",		YES,	0,		B_SYNC,			YES,
"LnMaintenanceSalesOrderBOD",			"bomsc100",	PUBLIC_BOD,	bobod.type.transactional,	"LnMaintenanceSalesOrderBOD",	YES,	B_PROCESS,	B_SYNC,			YES,
"LnMaintenanceSalesOrderInBOD",			"bomsc101",	PROTECTED_BOD,	bobod.type.transactional,	"LnMaintenanceSalesOrderBOD",	YES,	0,		0,			NO,
"LnMessageBOD",					"bobod020",	PUBLIC_BOD,	bobod.type.transactional,	"LnMessageBOD",			YES,	0,		B_SYNC,			YES,
"LnPlanningSignalBOD",				"borao010",	PUBLIC_BOD,	bobod.type.transactional,	"LnPlanningSignalBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"LnPlanningSignalInBOD",			"borao013",	PROTECTED_BOD,	bobod.type.transactional,	"LnPlanningSignalBOD",		YES,	0,		0,			NO,
"LnProductionResultBOD",			"borpt436",	PUBLIC_BOD,	bobod.type.transactional,	"LnProductionResultBOD",	YES,	0,		B_SYNC,			YES
		)
}
|* Maximum number of 255 arguments reached. Continue with next macro.
function cache.bods.08(domain	bobod.name i.name, ref long position, ref string parm.string)
{
		CACHE_BODS(
|* 1.				   		2.	    	3.	      	4.			  	5.				6.	7.		8.			9.
"LnServiceContractBalanceBOD",			"boctm440",	PUBLIC_BOD,	bobod.type.transactional,	"LnServiceContractBalanceBOD",	YES,	0,		B_SYNC,			YES,
"LnServiceContractBalanceActCostBOD",		"boctm480",	PROTECTED_BOD,	bobod.type.transactional,	"LnServiceContractBalanceBOD",	YES,	0,		0,			NO,
"LnServiceContractBalanceActRevenueBOD",	"boctm460",	PROTECTED_BOD,	bobod.type.transactional,	"LnServiceContractBalanceBOD",	YES,	0,		0,			NO,
"LnServiceContractBalanceEstRevenueBOD",	"boctm450",	PROTECTED_BOD,	bobod.type.transactional,	"LnServiceContractBalanceBOD",	YES,	0,		0,			NO,
"LnVendorRatingBOD",				"bopur081",	PUBLIC_BOD,	bobod.type.transactional,	"LnVendorRatingBOD",		YES,	0,		B_SYNC,			YES,
"OpportunityBOD",				"bosmi010",	PUBLIC_BOD,	bobod.type.transactional,	"OpportunityBOD",		YES,	0,		B_SYNC,			YES,
"OpportunityFP6BOD",				"bosmi020",	PROTECTED_BOD,	bobod.type.transactional,	"OpportunityBOD",		YES,	0,		0,			NO,
"PackageLabelBOD",				"bowmd530",	PUBLIC_BOD,	bobod.type.transactional,	"PackageLabelBOD",		YES,	0,		B_SYNC+B_PROCESS,	YES,
"PayableTrackerBOD",				"boacp500",	PUBLIC_BOD,	bobod.type.transactional,	"PayableTrackerBOD",		YES,	0,		B_SYNC,			YES,
"PayableTrackerInvoiceBOD",			"boacp510",	PROTECTED_BOD,	bobod.type.transactional,	"PayableTrackerBOD",		YES,	0,		0,			NO,
"PayableTrackerPaymentBOD",			"boacp520",	PROTECTED_BOD,	bobod.type.transactional,	"PayableTrackerBOD",		YES,	0,		0,			NO,
"PayableTransactionBOD",			"boacp700",	PUBLIC_BOD,	bobod.type.transactional,	"PayableTransactionBOD",	YES,	0,		B_SYNC,			YES,
"PayrollAdviceBOD",				"bobod110",	PUBLIC_BOD,	bobod.type.transactional,	"PayrollAdviceBOD",		YES,	B_SYNC,		0,			YES,
"PayrollAdviceInBOD",				"bobod111",	PROTECTED_BOD,	bobod.type.transactional,	"PayrollAdviceBOD",		YES,	0,		0,			NO,
"PlannedProductionOrderBOD",			"borrp010",	PUBLIC_BOD,	bobod.type.transactional,	"PlannedProductionOrderBOD",	YES,	B_PROCESS,	B_SYNC,			YES,
"PlannedProductionOrderInBOD",			"borrp013",	PROTECTED_BOD,	bobod.type.transactional,	"PlannedProductionOrderBOD",	YES,	0,		0,			NO,
"PlannedPurchaseOrderBOD",			"borrp011",	PUBLIC_BOD,	bobod.type.transactional,	"PlannedPurchaseOrderBOD",	YES,	B_PROCESS,	B_SYNC,			YES,
"PlannedPurchaseOrderInBOD",			"borrp014",	PROTECTED_BOD,	bobod.type.transactional,	"PlannedPurchaseOrderBOD",	YES,	0,		0,			NO,
"PlannedTransferBOD",				"borrp012",	PUBLIC_BOD,	bobod.type.transactional,	"PlannedTransferBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"PlannedTransferInBOD",				"borrp015",	PROTECTED_BOD,	bobod.type.transactional,	"PlannedTransferBOD",		YES,	0,		0,			NO,
"PlanningScheduleReleaseOutBOD",		"bosls063",	PROTECTED_BOD,	bobod.type.transactional,	"PlanningScheduleBOD",		YES,	0,		0,			NO,
"PlanningScheduleBOD",				"bovmi001",	PUBLIC_BOD,	bobod.type.transactional,	"PlanningScheduleBOD",		YES,	B_SYNC,		B_SYNC,			YES,
"PlanningSchedulePartsForecastBOD",		"bovmi003",	PROTECTED_BOD,	bobod.type.transactional,	"PlanningScheduleBOD",		YES,	0,		0,			NO,
"PlanningScheduleReleaseBOD",			"bosls060",	PROTECTED_BOD,	bobod.type.transactional,	"PlanningScheduleBOD",		YES,	0,		0,			NO
		)
}
|* Maximum number of 255 arguments reached. Continue with next macro.
function cache.bods.09(domain	bobod.name i.name, ref long position, ref string parm.string)
{
		CACHE_BODS(
|* 1.				   		2.	    	3.	      	4.			  	5.				6.	7.		8.			9.
"ProductionOrderBOD",				"bosfc100",	PUBLIC_BOD,	bobod.type.transactional,	"ProductionOrderBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"ProductionOrderASCBOD",			"boasc010",	PROTECTED_BOD,	bobod.type.transactional,	"ProductionOrderBOD",		YES,	0,		0,			NO,
"ProductionOrderSFCBOD",			"bosfc110",	PROTECTED_BOD,	bobod.type.transactional,	"ProductionOrderBOD",		YES,	0,		0,			NO,
"ProductionOrderSFCInBOD",			"bosfc111",	PROTECTED_BOD,	bobod.type.transactional,	"ProductionOrderBOD",		YES,	0,		0,			NO,
"ProductionOrderSOCBOD",			"bosoc205",	PROTECTED_BOD,	bobod.type.transactional,	"ProductionOrderBOD",		YES,	0,		0,			NO,
"ProjectBidBOD",				"boest020",	PUBLIC_BOD,	bobod.type.transactional,	"ProjectBidBOD",		YES,	0,		B_SYNC,			YES,
"ProjectBudgetBOD",				"boptc020",	PUBLIC_BOD,	bobod.type.transactional,	"ProjectBudgetBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"ProjectBudgetInBOD",				"boptc030",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectBudgetBOD",		YES,	0,		0,			NO,
"ProjectBudgetTimePhasedBOD",			"boptc025",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectBudgetBOD",		YES,	0,		0,			NO,
"ProjectContractBOD",				"boctm010",	PUBLIC_BOD,	bobod.type.transactional,	"ProjectContractBOD",		YES,	0,		B_SYNC,			YES,
"ProjectContractDeliverableBOD",		"bopdm050",	PUBLIC_BOD,	bobod.type.transactional,	"ProjectContractDeliverableBOD",YES,	0,		B_SYNC,			YES,
"ProjectContractInstallmentBOD",		"bopin020",	PUBLIC_BOD,	bobod.type.transactional,	"ProjectContractInstallmentBOD",YES,	0,		B_SYNC,			YES,
"ProjectCostsBOD",				"boppc030",	PUBLIC_BOD,	bobod.type.transactional,	"ProjectCostsBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"ProjectCostsEACEquipmentBOD",			"boppc035",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectCostsBOD",		YES,	0,		0,			NO,
"ProjectCostsEACLaborBOD",			"boppc034",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectCostsBOD",		YES,	0,		0,			NO,
"ProjectCostsEACMaterialBOD",			"boppc033",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectCostsBOD",		YES,	0,		0,			NO,
"ProjectCostsEACOverheadBOD",			"boppc039",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectCostsBOD",		YES,	0,		0,			NO,
"ProjectCostsEACSubcontractingBOD",		"boppc036",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectCostsBOD",		YES,	0,		0,			NO,
"ProjectCostsEACSundryBOD",			"boppc037",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectCostsBOD",		YES,	0,		0,			NO,
"ProjectCostsEquipmentInBOD",			"boppc038",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectCostsBOD",		YES,	0,		0,			NO,
"ProjectCostsHistoryBOD",			"boppc031",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectCostsBOD",		YES,	0,		0,			NO,
"ProjectCostsInterimResultsBOD",		"boppc032",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectCostsBOD",		YES,	0,		0,			NO,
"ProjectEstimateBOD",				"boest010",	PUBLIC_BOD,	bobod.type.transactional,	"ProjectEstimateBOD",		YES,	0,		B_SYNC,			YES,
"ProjectExtensionBOD",				"boptc010",	PUBLIC_BOD,	bobod.type.transactional,	"ProjectExtensionBOD",		YES,	0,		B_SYNC,			YES,
"ProjectProgressBOD",				"boppc040",	PUBLIC_BOD,	bobod.type.transactional,	"ProjectProgressBOD",		YES,	0,		B_SYNC,			YES
		)
}
|* Maximum number of 255 arguments reached. Continue with next macro.
function cache.bods.10(domain	bobod.name i.name, ref long position, ref string parm.string)
{
		CACHE_BODS(
|* 1.				   		2.	    	3.	      	4.			  	5.				6.	7.		8.			9.
"ProjectRevenueBOD",				"boppc050",	PUBLIC_BOD,	bobod.type.transactional,	"ProjectRevenueBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"ProjectRevenueAdvancePaymentRequestBOD",	"bopin051",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectRevenueBOD",		YES,	0,		0,			NO,
"ProjectRevenueDeliveryBasedBOD",		"bopin057",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectRevenueBOD",		YES,	0,		0,			NO,
"ProjectRevenueFeesBOD",			"bopin055",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectRevenueBOD",		YES,	0,		0,			NO,
"ProjectRevenueHistoryBOD",			"boppc051",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectRevenueBOD",		YES,	0,		0,			NO,
"ProjectRevenueHoldbackBOD",			"bopin054",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectRevenueBOD",		YES,	0,		0,			NO,
"ProjectRevenueInstallmentBOD",			"bopin052",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectRevenueBOD",		YES,	0,		0,			NO,
"ProjectRevenueInstallmentExtraWorkBOD",	"bopin053",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectRevenueBOD",		YES,	0,		0,			NO,
"ProjectRevenueInterimResultsBOD",		"boppc052",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectRevenueBOD",		YES,	0,		0,			NO,
"ProjectRevenueManualBOD",			"boppc053",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectRevenueBOD",		YES,	0,		0,			NO,
"ProjectRevenueManualInBOD",			"boppc054",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectRevenueBOD",		YES,	0,		0,			NO,
"ProjectRevenueProgressPaymentRequestBOD",	"bopin056",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectRevenueBOD",		YES,	0,		0,			NO,
"PurchaseOrderBOD",				"bopur047",	PUBLIC_BOD,	bobod.type.transactional,	"PurchaseOrderBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"PurchaseOrderInBOD",				"bopur049",	PROTECTED_BOD,	bobod.type.transactional,	"PurchaseOrderBOD",		YES,	0,		0,			NO,
"QualityTestResultBOD",				"boptc115",	PUBLIC_BOD,	bobod.type.transactional,	"QualityTestResultBOD",		YES,	0,		B_SYNC,			YES,
"QuoteBOD",					"bosls012",	PUBLIC_BOD,	bobod.type.transactional,	"QuoteBOD",			YES,	B_PROCESS,	B_SYNC,			YES,
"QuoteSalesBOD",				"bosls011",	PROTECTED_BOD,	bobod.type.transactional,	"QuoteBOD",			YES,	0,		0,			NO,
"QuoteSalesInBOD",				"bosls013",	PROTECTED_BOD,	bobod.type.transactional,	"QuoteBOD",			YES,	0,		0,			NO,
"ReceivableTrackerBOD",				"boacr500",	PUBLIC_BOD,	bobod.type.transactional,	"ReceivableTrackerBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"ReceivableTrackerInvoiceBOD",			"boacr510",	PROTECTED_BOD,	bobod.type.transactional,	"ReceivableTrackerBOD",		YES,	0,		0,			NO,
"ReceivableTrackerReceiptBOD",			"boacr520",	PROTECTED_BOD,	bobod.type.transactional,	"ReceivableTrackerBOD",		YES,	0,		0,			NO,
"ReceivableTransactionBOD",			"boacr700",	PUBLIC_BOD,	bobod.type.transactional,	"ReceivableTransactionBOD",	YES,	0,		B_SYNC,			YES,
"ReceiveDeliveryBOD",				"boinh801",	PUBLIC_BOD,	bobod.type.transactional,	"ReceiveDeliveryBOD",		YES,	B_SYNC+B_LOAD+B_PROCESS, B_SYNC,	YES,
"ReceiveDeliveryPurchaseBOD",			"bopur046",	PROTECTED_BOD,	bobod.type.transactional,	"ReceiveDeliveryBOD",		YES,	0,		0,			NO,
"ReceiveDeliverySalesBOD",			"bosls045",	PROTECTED_BOD,	bobod.type.transactional,	"ReceiveDeliveryBOD",		YES,	0,		0,			NO,
"ReceiveDeliveryWarehousingBOD",		"boinh802",	PROTECTED_BOD,	bobod.type.transactional,	"ReceiveDeliveryBOD",		YES,	0,		0,			NO,
"ReceiveDeliveryWarehousingInBOD",		"boinh820",	PROTECTED_BOD,	bobod.type.transactional,	"ReceiveDeliveryBOD",		YES,	0,		0,			NO
		)
}
|* Maximum number of 255 arguments reached. Continue with next macro.
function cache.bods.11(domain	bobod.name i.name, ref long position, ref string parm.string)
{
		CACHE_BODS(
|* 1.				   		2.	    	3.	      	4.			  	5.				6.	7.		8.			9.
"RemittanceAdviceBOD",				"bocmg103",	PUBLIC_BOD,	bobod.type.transactional,	"RemittanceAdviceBOD",		YES,	0,		B_SYNC,			YES,
"RequisitionBOD",				"bopur022",	PUBLIC_BOD,	bobod.type.transactional,	"RequisitionBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"RequisitionInBOD",				"bopur023",	PROTECTED_BOD,	bobod.type.transactional,	"RequisitionBOD",		YES,	0,		0,			NO,
"RFQBOD",					"bopur011",	PUBLIC_BOD,	bobod.type.transactional,	"RFQBOD",			YES,	0,		B_SYNC,			YES,
"RFQSubLineBOD",				"bopur121",	PROTECTED_BOD,	bobod.type.transactional,	"RFQBOD",			YES,	0,		0,			NO,
"SalesOrderBOD",				"bosls044",	PUBLIC_BOD,	bobod.type.transactional,	"SalesOrderBOD",		YES,	B_PROCESS+B_LOAD+B_UPDATE, B_SYNC,	YES,
"SalesOrderInBOD",				"bosls047",	PROTECTED_BOD,	bobod.type.transactional,	"SalesOrderBOD",		YES,	0,		0,			NO,
"SalesOrderInLn106BOD",				"bosls048",	PROTECTED_BOD,	bobod.type.transactional,	"SalesOrderBOD",		YES,	0,		0,			NO,
"SequenceScheduleBOD",				"bosls080",	PUBLIC_BOD,	bobod.type.transactional,	"SequenceScheduleBOD",		YES,	B_SYNC,		0,			YES,
"ServiceContractBOD",				"boctm300",	PUBLIC_BOD,	bobod.type.transactional,	"ServiceContractBOD",		YES,	0,		B_SYNC,			YES,
"ServiceOrderBOD",				"bosoc200",	PUBLIC_BOD,	bobod.type.transactional,	"ServiceOrderBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"ServiceOrderInBOD",				"bosoc201",	PROTECTED_BOD,	bobod.type.transactional,	"ServiceOrderBOD",		YES,	0,		0,			NO,
"ServiceOrderWorkOrderBOD",			"bowcs200",	PROTECTED_BOD,	bobod.type.transactional,	"ServiceOrderBOD",		YES,	0,		0,			NO,
"ShipmentBOD",					"boinh803",	PUBLIC_BOD,	bobod.type.transactional,	"ShipmentBOD",			YES,	B_SYNC+B_PROCESS, B_SYNC+B_PROCESS,	YES,
"ShipmentInBOD",				"boinh809",	PROTECTED_BOD,	bobod.type.transactional,	"ShipmentBOD",			YES,	0,		0,			NO,
"ShipmentOutBOD",				"boinh806",	PROTECTED_BOD,	bobod.type.transactional,	"ShipmentBOD",			YES,	0,		0,			NO,
"ShipmentScheduleBOD",				"bosls050",	PUBLIC_BOD,	bobod.type.transactional,	"ShipmentScheduleBOD",		YES,	B_SYNC,		B_SYNC,			YES,
"ShipmentScheduleReleaseBOD",			"bosls051",	PROTECTED_BOD,	bobod.type.transactional,	"ShipmentScheduleBOD",		YES,	0,		0,			NO,
"ShipmentScheduleReleasePUSBOD",		"bosls052",	PROTECTED_BOD,	bobod.type.transactional,	"ShipmentScheduleBOD",		YES,	0,		0,			NO,
"ShipmentScheduleReleaseOutBOD",		"bosls054",	PROTECTED_BOD,	bobod.type.transactional,	"ShipmentScheduleBOD",		YES,	0,		0,			NO,
"SourceSystemJournalEntryBOD",			"bogld106",	PUBLIC_BOD,	bobod.type.transactional,	"SourceSystemJournalEntryBOD",	YES,	B_PROCESS,	B_SYNC,			YES,
"SourceSystemJournalEntryInBOD",		"bogld102",	PROTECTED_BOD,	bobod.type.transactional,	"SourceSystemJournalEntryBOD",	YES,	0,		0,			NO,
"SupplierInvoiceBOD",				"boacp701",	PUBLIC_BOD,	bobod.type.transactional,	"SupplierInvoiceBOD",		YES,	B_LOAD+B_PROCESS, B_SYNC,		YES,
"SupplierInvoiceInBOD",				"boacp702",	PROTECTED_BOD,	bobod.type.transactional,	"SupplierInvoiceBOD",		YES,	0,		0,			NO,
"SupplierQuoteBOD",				"bopur013",	PUBLIC_BOD,	bobod.type.transactional,	"SupplierQuoteBOD",		YES,	B_PROCESS,	B_SYNC,			YES,
"SupplierQuoteInBOD",				"bopur014",	PROTECTED_BOD,	bobod.type.transactional,	"SupplierQuoteBOD",		YES,	0,		0,			NO,
"SupplierQuoteSubLineBOD",			"bopur015",	PROTECTED_BOD,	bobod.type.transactional,	"SupplierQuoteBOD",		YES,	0,		0,			NO,
"SupplierQuoteSubLineInBOD",			"bopur016",	PROTECTED_BOD,	bobod.type.transactional,	"SupplierQuoteBOD",		YES,	0,		0,			NO
		)
}
|* Maximum number of 255 arguments reached. Continue with next macro.
function cache.bods.12(domain	bobod.name i.name, ref long position, ref string parm.string)
{
		CACHE_BODS(
|* 1.				   		2.	    	3.	      	4.			  	5.				6.	7.		8.			9.
"BillOfResourcesPBOMBOD",			"bomfc300",	PROTECTED_BOD,	bobod.type.masterdata,		"BillOfResourcesBOD",		YES,	0,		0,			NO,	|#2076013.n
"BillOfResourcesPBOMInBOD",			"bomfc301",	PROTECTED_BOD,	bobod.type.masterdata,		"BillOfResourcesBOD",		YES,	0,		0,			NO,	|#2090666.n
"BillOfResourcesJSROUBOD",			"borou400",	PROTECTED_BOD,	bobod.type.masterdata,		"BillOfResourcesBOD",		YES,	0,		0,			NO,	|#2076013.n
"BillOfResourcesJSROUInBOD",			"borou401",	PROTECTED_BOD,	bobod.type.masterdata,		"BillOfResourcesBOD",		YES,	0,		0,			NO,	|#2090666.n
"ShipmentOutSalesScheduleBOD",			"bosls057",	PROTECTED_BOD,	bobod.type.transactional,	"ShipmentBOD",			YES,	0,		0,			NO,	|#2076013.n
"ReceiveDeliveryPurchaseScheduleBOD",		"bopur018",	PROTECTED_BOD,	bobod.type.transactional,	"ReceiveDeliveryBOD",		YES,	0,		0,			NO,	|#2076013.n
"SupplierRMABOD",				"bopur050",	PUBLIC_BOD,	bobod.type.transactional,	"SupplierRMABOD",		YES,	0,		B_SYNC,			YES,
"SupplierPlanningScheduleBOD",			"bopur060",	PUBLIC_BOD,	bobod.type.transactional,	"SupplierPlanningScheduleBOD",	YES,	0,		B_SYNC,			YES,
"SupplierShipmentScheduleBOD",			"bopur051",	PUBLIC_BOD,	bobod.type.transactional,	"SupplierShipmentScheduleBOD",	YES,	0,		B_SYNC,			YES,
"ProjectProgressElementBOD",			"boppc045",	PROTECTED_BOD,	bobod.type.transactional,	"ProjectProgressBOD",		YES,	0,		0,			NO,
"TransferBOD",					"boinh814",	PUBLIC_BOD,	bobod.type.transactional,	"TransferBOD",			YES,	0,		B_SYNC,			YES,
"LnAssemblyLineBOD",				"boasl130",	PUBLIC_BOD,	bobod.type.masterdata,		"LnAssemblyLineBOD",		YES,	0,		B_SYNC,			YES,
"LyDailyStockAccountBOD",			"boinr940", 	PUBLIC_BOD,    	bobod.type.transactional,	"LyDailyStockAccountBOD",	YES,	0,		0,			NO,	|#2044613.n
"ProjectBalanceBOD",				"boppc010",	PUBLIC_BOD,	bobod.type.balance,		"ProjectBalanceBOD",		YES,	0,		B_SYNC,			YES,
"ProjectPeriodBalanceBOD",			"boppc020",	PUBLIC_BOD,	bobod.type.balance,		"ProjectPeriodBalanceBOD",	YES,	0,		B_SYNC,			YES,
"SourceSystemGLMovementBOD",			"bogld302",	PUBLIC_BOD,	bobod.type.balance,		"SourceSystemGLMovementBOD",	YES,	0,		B_SYNC,			YES,
"SourceSystemGLMovementInBOD",			"bofbs101",	PROTECTED_BOD,	bobod.type.balance,		"SourceSystemGLMovementBOD",	NO,	B_SYNC,		B_SYNC,			NO,	|#2142618.n
"CalendarBOD",					"boccp019",	PUBLIC_BOD,	bobod.type.transactional,	"CalendarBOD",			YES,	0,		B_SYNC,			NO,
"WorkflowBOD",					"bobod010",	PUBLIC_BOD,	bobod.type.system,		"WorkflowBOD",			NO,	0,		B_PROCESS,		YES,
"SalesOrderReceivedCustomerOrderInBOD",		"bosls049",	PROTECTED_BOD,	bobod.type.transactional,	"SalesOrderBOD",		YES, 	0,		0,			YES	|#2143175.n
		)
}

function boolean bod.supported(					
			domain	bobod.name	i.table.name,
				boolean		i.set.error.message)
{
	boolean	supported
	
	|* ASSUMPTION : It is being updated to cloud. Hence it is expected to support
	
	return(true)						|* ValOP2CE_01.n

|	|* Check if BOD is supported in this FP.		|* ValOP2CE_01.so
|	supported = TRY_FUNCTION(
|			txbod.dll9002.bod.implementation.supported.in.this.fp,
|			i.table.name)
|	|* Check if BOD is supported in this ES version.
|	if not supported then					|#2046296.o
|	if not supported and 					|#2046296.sn
|	   get.compnr() = 0 then				|#2046296.en
|		supported =
|		TRY_TOOLS_FUNCTION(
|		   ttintbor,
|		   ttint.bor.bod.implementation.supported.in.this.es.version,
|		   i.table.name )
|	endif
|
|
|	if not supported then
|		if i.set.error.message then
|			dal.set.error.message("txbods0019", trim$(i.table.name))
|			|* BOD Name %1$s not supported in this FP and ES
|			|* version.
|		endif
|
|		return(false)
|	endif
|
|	return(true)					|* ValOP2CE_01.eo
}

function fill.parameter.string(	domain	bobod.name	i.name,
				boolean			i.record.current,
				ref	string		o.parm.string)
{
	long	ret
	
	domain	boyesno		staging				
	domain	boyesno		sync.processing			
	domain	bobod.type	bod.type
	domain	bobod.spls	split.size			
	domain	bobod.stco	staging.condition		

	o.parm.string = ""

								
	if get.compnr() = 0 then
		return
	endif
								

	if i.record.current then
		o.parm.string = str$(bobod100.ostg) &
|				str$(bobod100.sypr)		
								
				str$(bobod100.sypr) &
				edit$(bobod100.spls, "99VD99") &
				str$(bobod100.stco)		
	else
		select	bobod100.ostg:staging,
			bobod100.sypr:sync.processing,
			bobod100.spls:split.size,		
			bobod100.stco:staging.condition,	
			bobod100.type:bod.type
		from	bobod100
		where	bobod100._index2 = {:i.name}
		as set with 1 rows
		selectdo
		selectempty
			if txbod.dll9002.staging.is.never.applicable() then
				staging = boyesno.no			
|				staging = tcyesno.no		
			else
				ret =  txbod.dll9002.staging.is.derived(
						i.name,
						bod.type,
						staging)
			endif

			if txbod.dll9002.sync.processing.is.never.applicable() then
				sync.processing = boyesno.no		
|				sync.processing = tcyesno.no	
			else
				ret =  txbod.dll9002.sync.processing.is.derived(
						i.name,
						sync.processing)
			endif
			staging.condition = bobod.stco.modified	
		endselect

		o.parm.string = str$(staging) &
|				str$(sync.processing)		
								
				str$(sync.processing) &
				edit$(split.size, "99VD99") &	
				str$(staging.condition)		
	endif
}


function long convert.from.public(				
				domain	boyesno	i.public)
{
	on case i.public
	case boyesno.yes:
		return(PUBLIC_BOD)
	case boyesno.no:
		return(PROTECTED_BOD)
	endcase

	return(0)
}

function boolean service.implemented()
{
	FunctionUsage
	Expl:	This function checks if the package service is implemented.
	Pre:	N.a.
	Post:	N.a.
	Input:	N.a.
	Output:	N.a.
	Return:	true, package ts is implemented
		false, package ts is not implemented
	EndFunctionUsage

	long	ret

|t	STOP.MESSAGES

	ret = txmcs.dll9001.read.company.data1()	|* NEW

|t	START.MESSAGES

	if ret = 0 and
	   tccom000.srvi = tcyesno.yes then
		return(true)
	endif

	return(false)
}

function boolean freight.management.implemented()
{
	FunctionUsage
	Expl:	This function checks if freight management functionality
		is implemented.
	Pre:	N.a.
	Post:	N.a.
	Input:	N.a.
	Output:	N.a.
	Return:	True/False
	EndFunctionUsage

			long		ret

|t	STOP.MESSAGES

	ret = txmcs.dll9001.read.company.data1()

|t	START.MESSAGES

	if ret = 0 and
	   tccom000.frmi = tcyesno.yes then
		return(true)
	endif

	return(false)
}								


function boolean subcontracting.with.wip.manufacturer.implemented()
{
	FunctionUsage
	Expl:	This function checks if the package subcontracting with wip manufacturer (smfm)
		is implemented.
	Pre:	N.a.
	Post:	N.a.
	Input:	N.a.
	Output:	N.a.
	Return:	true, package ts is implemented
		false, package ts is not implemented
	EndFunctionUsage

			long		ret

|t	STOP.MESSAGES

	ret = txmcs.dll9001.read.company.data1()

|t	START.MESSAGES

	if ret = 0 and
	   tccom000.smfm = tcyesno.yes then
		return(true)
	endif

	return(false)
}
 

function boolean order.management.implemented()
{
	FunctionUsage
	Expl:	This function checks if order management functionality is
		implemented.
	Pre:	-
	Post:	-
	Input:	-
	Output:	-
	Return:	True/False
	EndFunctionUsage
	
	domain	tcncmp		l.curr.company
	
	l.curr.company = get.compnr()
	select	tccom000.*
	from	tccom000
	where	tccom000._index1={0,:l.curr.company}
	as set with 1 rows
	selectdo
	if tccom000.dsri = tcyesno.yes then
		return(true)
	endif
	endselect

	return(false)
}

function long execute.db.action(
			long		i.db.action,
	const		string		i.table,
			long		i.error.flag)
{
			long		error.flag
			long		table.id
			long		ret.val

	error.flag = i.error.flag
	if active.in.workflow(i.table) then
		error.flag = error.flag + db.return.dbcm.action.not.allowed
	endif

	table.id = db.bind("t"&i.table)
	if table.id = 0 then
		db.unbind(table.id)				
		return(DALHOOKERROR)
	endif

	ret.val = 0

	on case i.db.action
	case DB.MODE.INSERT:
		ret.val = db.insert(table.id, db.retry, error.flag)
		break
	case DB.MODE.UPDATE:
		ret.val = db.update(table.id, db.retry, error.flag)
		break
	case DB.MODE.DELETE:
		ret.val = db.delete(table.id, db.retry, error.flag)
		break
	endcase

	on case ret.val
	case edbcmactionnotallowed:
		handle.workflow.error.message(
					table.id)
		break
	endcase

	db.unbind(table.id)					
	return(ret.val)
}

function boolean active.in.workflow(
	const		string		i.table)
{
	FunctionUsage
	Expl.:	Function can be used to check if a given table is active
		in Workflow.
	Pre:	NA
	Post:	NA
	Input:	i.table (e.g. "tdpur400")
	Output:	NA
	Return:	true / false
	EndFunctionUsage

|t	return(OCM_ACTIVE(		i.table))

	return(true)	|* Remove after reolving the error
}

function void handle.workflow.error.message(
			long		i.table.id)
{
	FunctionUsage
	Expl.:	Function can be used to set an error message.
	Pre:	NA
	Post:	Error message is added to stack.
	Input:	i.table.id (e.g. ttdpur400)
	Output:	NA
	Return:	NA
	EndFunctionUsage

			string		workflow.typed.object.id(34)
			string		object.type.desc(280)

|t	object.type.desc = dbcm.get.object.type.desc$(i.table.id)
	workflow.typed.object.id = dbcm.get.rcd.toid$(i.table.id)

	dal.set.error.message("tcgens0100",
	|* tcgens0100  ???
		trim$(object.type.desc),
		trim$(dbcm.get.functional.id$(workflow.typed.object.id)))
}


function boolean commissions.margin.control.allowed()		
{
	if tdcms000.cmim = tcyesno.no then
	   	|* Commissions not implemented
	   	return(false)
	endif

	if tdcms000.lnrp = tdcms.lnrp.order then
		return(false)
	endif

	if tdcms000.mlrp = tdcms.mlrp.manually then
		return(false)
	endif

	if tdcms000.calc = tdcms.mlrp.manually or
	   tdcms000.cucl = tdcms.mlrp.manually then
	   	return(false)
	endif

	return(true)
}

function boolean rebates.margin.control.allowed()
{
	if tdcms000.rbim = tcyesno.no then
	   	|* Commissions not implemented
	   	return(false)
	endif

	if tdcms000.lnrp.r = tdcms.lnrp.order then
		return(false)
	endif

	if tdcms000.mlrp.r = tdcms.mlrp.manually then
		return(false)
	endif

	if tdcms000.calc.r = tdcms.mlrp.manually or
	   tdcms000.cucl.r = tdcms.mlrp.manually then
	   	return(false)
	endif

	return(true)
}

function long xml.get.value(
	const	string	i.method,
	const	long	i.node,
	const	string	i.element,
	const	string	i.attribute,
	const	string	i.attribute.value,
	const	string	i.domain,
	const	boolean	i.is.mandatory,
	ref	string	o.value,
	ref	boolean	o.value.is.set )
{
	FunctionUsage
	Expl:	The purpose of this function is to return the value of the
		first find specified element and attribute.
		If the domain is specified, the value is checked against the
		domain.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.method
		i.node
		i.element	- <element> or ?<element>
				  Example:
				   <Shipment><ShipmentHeader><DocumentID>
				   ?<Shipment><ShipmentHeader><DocumentID>
		i.attribute	- Example: agencyRole
		i.domain
		i.is.mandatory
	Output:	o.value
		o.value.is.set
	Return:	0/DALHOOKERROR
	EndFunctionUsage

	long	node
	long	length
	long	return.value
	string	b.pattern(1) based
	string	b.element(1) based
	string	l.value(1024) mb				

	#define	INIT_XML_GET_VALUE
^		free.mem( b.pattern )
^		free.mem( b.element )

	#define	ERROR_XML_GET_VALUE( i_RETURN_VALUE )
^		if i_RETURN_VALUE <> 0 then
^			END_XML_GET_VALUE( i_RETURN_VALUE )
^		endif

	#define	END_XML_GET_VALUE( i_RETURN_VALUE )
^		INIT_XML_GET_VALUE
^		return( i_RETURN_VALUE )

	INIT_XML_GET_VALUE
	return.value = 0
	o.value = ""
	o.value.is.set = false

	|* Check if the specified method is supported.
	on case i.method
	case GET_ELEMENT:
	case GET_ATTRIBUTE:
		|* Supported
		break
	default:
		|* Programming error. Hardcoded error message.
		dal.set.error.message(
			"@Method '" & i.method & "' is not supported." )

		return( DALHOOKERROR )
	endcase

	|* Set the element.
	SET_BASED_VARIABLE( trim$( i.element ), b.element )	|* Ref

	if b.element(1;1) <> "?" then
		SET_BASED_VARIABLE( "?" & b.element, b.element )|* Ref
	endif

	|* Set the search pattern.
	length = len( b.element )

	SET_BASED_VARIABLE(
		isspace( i.attribute ) ?
			b.element :
			b.element(1;length-1) & " " & trim$( i.attribute ) &
		       (isspace( i.attribute.value ) ?
				"" :
				"=" & quoted.string( trim$( i.attribute.value)))
		       & ">",
		b.pattern )	|* Ref

	|* Find first node for pattern.
	node = xmlFindFirstMatch( b.pattern, i.node )

	if node = 0 then
		if i.is.mandatory then
			on case i.method
			case GET_ELEMENT:
				dal.set.error.message( "txbods0058", b.pattern )
				|* txbods0058  ???
				ERROR_XML_GET_VALUE( DALHOOKERROR )
			case GET_ATTRIBUTE:
				dal.set.error.message( "txbods0059", b.pattern )
				|* txbods0059  ???
				ERROR_XML_GET_VALUE( DALHOOKERROR )
			endcase
		endif
	else
		on case i.method
		case GET_ELEMENT: |* Get the element value.
			node = xmlGetData( node, l.value )	
			if not isspace( i.domain ) then
				check.and.convert.to.single.byte(
						i.domain,
						l.value)
			endif

			o.value = l.value
								

			if i.is.mandatory and
			   isspace( o.value ) then
				dal.set.error.message( "txbods0060", b.pattern )
				|* txbods0060  ???

				ERROR_XML_GET_VALUE( DALHOOKERROR )					endif

			break
		case GET_ATTRIBUTE: |* Get the attribute value.
			node = xmlGetAttribute(
					node,
					i.attribute,
					o.value )

			if i.is.mandatory and
			   isspace( o.value ) then
				dal.set.error.message( "txbods0061", b.pattern )
				|* txbods0061  ???

				ERROR_XML_GET_VALUE( DALHOOKERROR )					endif

			break
		endcase

		o.value.is.set = true

		if not isspace( i.domain ) then
			|* Error is resolved by linking tlbctdll1000.
			|* Below function is trusted function.
			return.value = tlbct.dll1000.domain.check.value(
					o.value,
					i.domain,
					"",		|* Alternative domain
					i.element )
 
			ERROR_XML_GET_VALUE( return.value )
		endif
		
	endif

	END_XML_GET_VALUE( 0 )
}


function handle.settings.logging(
			long		i.method,
	ref	domain	tcbod.mode	io.mode,
	ref	domain	tcyesno		io.logging,
	ref	domain	tcbod.slog	io.subject,
	ref	domain	tcyesno		io.single.xml,
	ref	domain	tcclsv		io.location,
	ref	domain	tcmcs.s512	io.directory )
{
	|* This function stores or returns all variables related to logging,
	|* based on the specified method.

	static	domain	tcbod.mode	s.mode
	static	domain	tcyesno		s.logging
	static	domain	tcbod.slog	s.subject
	static	domain	tcyesno		s.single.xml
	static	domain	tcclsv		s.location
	static	domain	tcmcs.s512	s.directory

	on case i.method
	case SET_VALUE:
		s.mode = io.mode
		s.logging = io.logging
		s.subject = io.subject
		s.single.xml = io.single.xml
		s.location = io.location
		s.directory = io.directory

		break
	case GET_VALUE:
		io.mode = s.mode
		io.logging = s.logging
		io.subject = s.subject
		io.single.xml = s.single.xml
		io.location = s.location
		io.directory = s.directory

		break
	default:
		ASSERT(	false,
		"Method '" & str$( i.method ) & "' not supported." )

		break
	endcase
}
function initialize.report.control.variables()
{
	|* Sort fields.
	pd.sequence.no = 0	|* Sort field 1.
	pd.company = 0		|* Sort field 2.

	|* Variable for message in box.
	pd.box.msg.flag = tcyesno.no
	pd.box.msg.hd = tcyesno.no
	pd.box.msg.ft = tcyesno.no

	|* Variables for error message.
	pd.error.flag = tcyesno.no
	pd.error.header = tcyesno.no
	pd.error.field = tcyesno.no
	pd.error.more.fld = tcyesno.no
	pd.error.id = tcyesno.no
	pd.error.more.id = tcyesno.no
	pd.error.text.hd = tcyesno.no
	pd.error.text = tcyesno.no
	pd.error.empty.ln = tcyesno.no
}

function long get.company.list(
	const	domain	tcncmp	i.company.stack(),
	const		long	i.nr.positions.company.stack,
	ref		string	o.company.list() )
{
		long	nr.digits.domain
		long	stack.position
		long	dummy.return.value
	domain	tcncmp	company

	#define	COMPANY_DOMAIN	"tcncmp"

	free.mem( o.company.list )

	|* Allocate memory for variable 'o.company.list'.
	if rdi.domain.integer( COMPANY_DOMAIN, nr.digits.domain) = -1 then
		dal.set.error.message(
			"txemms0098",
			|* txemms0098  ???
			COMPANY_DOMAIN )
		|* Error during reading information of domain '%1$s'.

		return( DALHOOKERROR )
	endif

	dummy.return.value = alloc.mem(
				o.company.list,
				( nr.digits.domain + 2 ) *
				i.nr.positions.company.stack )
				|* The extra position is needed for the comma
				|* and space.

	|* Process the companies. Build the list to confirm.
	for stack.position = 1 to i.nr.positions.company.stack
		company = i.company.stack(stack.position)

		if company <> 0 then
			if not isspace( o.company.list ) then
				o.company.list = trim$( o.company.list ) & ","
			endif

			o.company.list =
				trim$( o.company.list ) & " " &
				edit$( company, "C" )
		endif
	endfor

	return( 0 )
}


function boolean processing.confirmed(
	const	domain	tcbod.mode	i.mode,
	const	domain	tcbod.uvrb	i.use.verb,
	const		string		i.company.list,
	const		long		i.nr.companies,
	const		string		i.logical.id.list )
{
		long	nr.logical.ids
		long	dummy.value
		string	b.question.text(1) based
	domain	tcyesno	confirmed

	free.mem( b.question.text )

	on case i.mode
	case PD_MODE_COUNT:
		|* Only listed companies are relevant.

		dummy.value = alloc.mem(
				b.question.text,
				132 +	|* Length message
				len( i.company.list ) +
					len( str$( i.nr.companies )))

		if i.nr.companies = 1 then
			|* Number of companies = 1
			b.question.text = sprintf$(
						form.text$( "tcbods0096" ),
						|* tcbods0096  ???
						trim$( i.company.list ))
			|* BODs of company %1$s will be counted.
		else
			|* Number of companies = n
			b.question.text = sprintf$(
						form.text$( "tcbods0097" ),
						|* tcbods0097  ???
						i.nr.companies,
						trim$( i.company.list ))
			|* BODs of companies (%1$d) %2$s will be counted.
		endif

		break
	default:	|* Publish/Simulate
		on case i.use.verb
		case PD_USE_VERB_SHOW:
			|* Listed companies and logical ids are relevant.
			nr.logical.ids = get.number.of.logical.ids(
						i.logical.id.list )

			dummy.value = alloc.mem(
					b.question.text,
					132 +	|* Length message
					len( i.company.list ) +
						len( str$( i.nr.companies )) +
					len( i.logical.id.list ) +
						len( str$( nr.logical.ids )))

			if i.nr.companies = 1 then
				if nr.logical.ids = 1 then
					|* Number of companies = 1
					|* Number of logical ids = 1
					b.question.text =
					sprintf$(
						form.text$( "tcbods0092" ),
						|* tcbods0092  ???
						trim$( i.company.list ),
						trim$( i.logical.id.list ))
					|* BODs of company %1$d will be
					|* published to Logical ID %2$s.
				else
					|* Number of companies = 1
					|* Number of logical ids = n
					b.question.text =
					sprintf$(
						form.text$( "tcbods0093" ),
						|* tcbods0093  ???
						trim$( i.company.list ),
						nr.logical.ids,
						trim$( i.logical.id.list ))
					|* BODs of company %1$d will be
					|* published to Logical IDs (%2$d) %3$s.
				endif
			else
				if nr.logical.ids = 1 then
					|* Number of companies = n
					|* Number of logical ids = 1
					b.question.text =
					sprintf$(
						form.text$( "tcbods0094" ),
						|* tcbods0094  ???
						i.nr.companies,
						trim$( i.company.list ),
						trim$( i.logical.id.list ))
					|* BODs of companies (%1$d) %2$s will
					|* be published to Logical ID %3$s.
				else
					|* Number of companies = n
					|* Number of logical ids = n
					b.question.text =
					sprintf$(
						form.text$( "tcbods0095" ),
						|* tcbods0095  ???
						i.nr.companies,
						trim$( i.company.list ),
						nr.logical.ids,
						trim$( i.logical.id.list ))
					|* BODs of companies (%1$d) %2$s will
					|* be published to Logical IDs (%3$d)
					|* %4$s.
				endif
			endif

			break
		default:	|* Process/Sync
			|* Only listed companies are relevant.
			dummy.value = alloc.mem(
					b.question.text,
					132 +	|* Length message
					len( i.company.list ) +
						len( str$(i.nr.companies )))

			if i.nr.companies = 1 then
				|* Number of companies = 1
				b.question.text =
					sprintf$(
						form.text$( "tcbods0090" ),
						|* tcbods0090  ???
						trim$( i.company.list ))
				|* BODs of company %1$s will be published.
			else
				|* Number of companies = n
				b.question.text =
					sprintf$(
						form.text$( "tcbods0091" ),
						|* tcbods0091  ???
						i.nr.companies,
						trim$( i.company.list ))
				|* BODs of companies (%1$d) %2$s will be
				|* published.
			endif

			break
		endcase
	endcase

	confirmed = ask.enum( "tcbod00003", YES, trim$( b.question.text ))
	|* tcbod00003  ???

	free.mem( b.question.text )

	if confirmed = tcyesno.yes then
		return( true )
	endif

	|* Not confirmed (= cancelled) by user.
	return( false )
}

|# As Progress Indicator part is no more used
|function long initialize.progress.indicator(
|	const	domain	tcbod.mode	i.mode,
|	const	domain	tcmcs.str70m	i.report.description )
|{
|	long	mode
|
|	if txmcs.dll9001.show.progress.indicator() then
|		on case i.mode
|		case PD_MODE_COUNT:
|			mode = PROGRESS.STOP + PROGRESS.NOAUTODESTROY
|
|			break
|		default: |* Simulate/Publish
|			mode =	PROGRESS.BAR +
|				PROGRESS.STOP +
|				PROGRESS.NOAUTODESTROY
|
|			break
|		endcase
|
|		if create.progress.indicator(
|				i.report.description,
|				mode ) = 0 then
|			set.show.progress.indicator( true )
|			change.progress.delay( 0 )
|		endif
|	endif
|
|	return( 0 )
|}

function set.show.progress.indicator(
	boolean	i.show.progress.indicator )
{
	handle.show.progress.indicator(
		SET_VALUE,
		i.show.progress.indicator )	|* Ref i/o
}
function handle.show.progress.indicator(
		long	i.method,
	ref	long	io.show.progress.indicator )
{
	static boolean	s.show.progress.indicator

	on case i.method
	case SET_VALUE:
		s.show.progress.indicator = io.show.progress.indicator

		break
	case GET_VALUE:
		io.show.progress.indicator = s.show.progress.indicator

		break
	endcase
}

function handle.settings(
			long		i.method,
	ref	domain	tcbod.uvrb	io.use.verb,
	ref	domain	tcmcs.str215	io.logical.ids )
{
	static	domain	tcbod.uvrb	s.use.verb
	static	domain	tcmcs.str215	s.logical.ids

	on case i.method
	case SET_VALUE:
		s.use.verb = io.use.verb
		s.logical.ids = io.logical.ids

		break
	case GET_VALUE:
		io.use.verb = s.use.verb
		io.logical.ids = s.logical.ids

		break
	endcase
}

function string convert.directory(
	const	domain	tcclsv	i.location,
	const		string	i.directory )
{
	|* On UNIX OS systems, make path absolute if needed.
	if i.location = PD_SERVER and
|t	   ostype() = OS_UNIX and
	   not path.is.absolute( i.directory ) then
		return( path.dir.separator( OS_UNIX ) & i.directory )
	endif

	return( i.directory )
}

function handle.variable.staging.is.disabled(
		long	i.method,
	ref	boolean	io.staging.is.disabled )
{
	static	boolean	s.staging.is.disabled

	on case i.method
	case SET_VALUE:
		s.staging.is.disabled = io.staging.is.disabled

		break
	case GET_VALUE:
		io.staging.is.disabled = s.staging.is.disabled

		break
	endcase
}


function long open.publishing.report(
	const	domain	tcbod.mode	i.mode,
	const	domain	tcmcs.str70m	i.report.description,
	ref		long		o.report.id )
{
	long	return.value

	o.report.id = 0

	pd.report.desc = trim$( i.report.description )
	pd.mode = i.mode
	pd.bod.pack.vers = "2.1"
	pd.schema.version = txbod.dll9002.get.bod.schema.version()

	return.value = txbod.dll9002.open.publishing.report(
			"rtcbod020011100",	|* Report code
			"",			|* Print device
			"",			|* Report path
			"",			|* Report name
			false )			|* Chained startup

	if return.value > 0 then
		|* Report is activated.
		o.report.id = return.value
	else
		if return.value = -1 then
			dal.set.error.message( "txcoms0019" )
			|* Printing canceled.

			return( DALHOOKERROR )
		else
			dal.set.error.message( "txcoms0018" )
			|* Report not found.

			return( DALHOOKERROR )
		endif
	endif

	return( 0 )
}


function long get.confirmed.companies(
	const	domain	tcbod.mode	i.mode,
	const	domain	tcncmp		i.company.f,
	const	domain	tcncmp		i.company.t,
	const	domain	tcbod.uvrb	i.use.verb,
	const		string		i.logical.ids,
	ref	domain	tcncmp		o.company.stack(),
	ref		long		o.nr.positions.company.stack )
{
	FunctionUsage
	Expl:	The purpose of this function is to return the companies within
		the specified range and confirmed by the user.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.company.f
		i.company.t
		i.logical.ids
	Output: o.company.stack
		o.nr.positions.company.stack
	Return:	0/DALHOOKERROR
	EndFunctionUsage

	string	company.list(1) based

	free.mem( o.company.stack )
	o.nr.positions.company.stack = 0

	RETIFNOK( txbod.dll9002.get.companies(			
			i.company.f,
			i.company.t,
			o.company.stack,		|* Ref
			o.nr.positions.company.stack ))|* Ref

	|* Ask for confirmation of listed companies and logical ids (optional).
	if not job.process then
		RETIFNOK( get.company.list(
				o.company.stack,
				o.nr.positions.company.stack,
				company.list ))	|* Ref

		if not processing.confirmed(
				i.mode,
				i.use.verb,
				company.list,
				o.nr.positions.company.stack,
				i.logical.ids ) then
			|* Companies are not confirmed. Clear company stack.
			free.mem( o.company.stack )
			o.nr.positions.company.stack = 0
		endif
	endif

	return( 0 )
}


function long get.horizon.duration(
		domain	tcitem		i.ERPPlanningDataItem,
		domain	tcmcs.str25	i.ERPOrderHorizon,
		domain	tcmcs.str25	i.ERPPlanningHorizon,
	ref	domain	tcmcs.long	o.HorizonDuration(),
	ref		boolean		io.HorizonDuration.isSet() )
{
	long	sequence.stack

	|* <Horizons>
	|*	<HorizonDuration durationType="Ordering/Planning">Days</HorizonDuration>
	|* </Horizons>

	set.mem( o.HorizonDuration, 0 )
	set.mem( io.HorizonDuration.isSet, false )
	sequence.stack = 0

	if not isspace( i.ERPPlanningDataItem ) then
		if not isspace( i.ERPOrderHorizon ) then
			inc( sequence.stack )

			RETIFNOK( txbod.dll9002.get.horizon.duration.node(
					DURATION_TYPE_ORDERING,
					i.ERPOrderHorizon,
					o.HorizonDuration(sequence.stack ),		|* Ref
					io.HorizonDuration.isSet(sequence.stack) ))	|* Ref
		endif

		if not isspace( i.ERPPlanningHorizon ) then
			inc( sequence.stack )

			RETIFNOK( txbod.dll9002.get.horizon.duration.node(
					DURATION_TYPE_PLANNING,
					i.ERPPlanningHorizon,
					o.HorizonDuration(sequence.stack),		|* Ref
					io.HorizonDuration.isSet(sequence.stack) ))	|* Ref
		endif
	endif

	return( 0 )
}

function long get.work.center.description(
		domain	tccwoc		i.work.center,
	ref	domain	tcdsca		o.work.center.descr)
{
	FunctionUsage
	Expl:	Returns the description of the work center
		  (tirou001.dsca) by argument.

		  Initialization of o.work.center.descr will be done within
		  this function.

		  If the work center does not exist an error message will be
		  set and DALHOOKERROR will be returned.

		  If the calling function is not interested in the error
		  message then in case of DALHOOKERROR one should add the
		  following statement, dal.reset.error.message(-1), to remove
		  the error message from the stack.
		  Example:
		  	ret.val = tirou.dll0002.get.work.center.description(
			   		ppmmmxxx.cwoc, work.center.descr)
			if ret.val <> 0 then
		  		dal.reset.error.messages(-1)
			endif

		  This function uses static variables to keep the last
		  requested work center description in cache.
	Pre:	-
	Post:	Remove error message from the error stack if the calling
		function is not interested in the error message. See also
		the Expl. section in this DllUsage.
	Input:	i.work.center -- Work Center.
	Output:	o.work.center.descr -- Work Center Description.
	Return:	0/DALHOOKERROR.
	EndFunctionUsage


	get.work.center.data(		get.compnr(),		
					i.work.center,
					true)
	o.work.center.descr = g.dsca
	if not g.work.center.is.valid then
		dal.set.error.message("txroud001007.1",
		|* txroud001007.1  ???
				trim$(i.work.center))
		return(DALHOOKERROR)
	endif
	return(0)						
}

function void get.work.center.data(				
		domain	tcncmp		i.company,
		domain	tccwoc		i.work.center,
			boolean		i.force.read)
{
	if g.comp <> i.company or g.cwoc <> i.work.center or i.force.read then
		select	tirou001.cwoc:g.cwoc,
			tirou001.dsca:g.dsca
		from	tirou001
		where	tirou001._index1 = {:i.work.center}
		and	tirou001._compnr = :i.company
		as set with 1 rows
		selectdo
			g.comp = i.company
			g.work.center.is.valid = true
		selectempty
			init.work.center.data()
		endselect
	endif
}								

function void init.work.center.data()				
{
	g.comp = 0
	g.cwoc = ""
	g.dsca = ""

	g.work.center.is.valid = false
}			

function long get.item.value.amount.currency(
		domain	tcccur		i.ERPCurrency,
	ref	domain	tcccur		o.ItemValue_UnitValue_Amount_currencyID,
	ref		boolean		io.ItemValue_UnitValue_Amount_currencyID.isSet )
{
	domain	tcemm.depe	dummy.currency.system
	domain	tcmcs.long	dummy.nr.home.currencies
	domain	tcccur		local.currency
	domain	tcccur		dummy.currency.2
	domain	tcccur		dummy.currency.3
	domain	tcemm.expu	dummy.exchange.rate.purchase
	domain	tcemm.expu	dummy.exchange.rate.sales
	domain	tcemm.expu	dummy.exchange.rate.internal

	o.ItemValue_UnitValue_Amount_currencyID = ""
	io.ItemValue_UnitValue_Amount_currencyID.isSet = false

	if not isspace( i.ERPCurrency ) then
		|* Variable 'i.ERPCurrency' is filled. Use 'i.ERPCurrency'.
		o.ItemValue_UnitValue_Amount_currencyID = i.ERPCurrency
	else
		|* Variable 'i.ERPCurrency' is filled. Read 'Local Currency' of company.
		if read.company.data(
				get.compnr(),
				dummy.currency.system,			|* Ref
				dummy.nr.home.currencies,		|* Ref
				local.currency,				|* Ref
				dummy.currency.2,			|* Ref
				dummy.currency.3,			|* Ref
				dummy.exchange.rate.purchase,		|* Ref
				dummy.exchange.rate.sales,		|* Ref
				dummy.exchange.rate.internal ) then	|* Ref
			|* 'Local Currency' of company is filled. Use 'Local Currency'.
			o.ItemValue_UnitValue_Amount_currencyID = local.currency
		endif
	endif

	if not isspace( o.ItemValue_UnitValue_Amount_currencyID ) then
		io.ItemValue_UnitValue_Amount_currencyID.isSet = true
	endif

	return( 0 )
}

function boolean read.company.data(
		domain	tcncmp		i.company,
	ref	domain	tcemm.depe	o.currency.system,
	ref	domain	tcmcs.long	o.no.hcur,
	ref	domain	tcccur		o.local.currency,
	ref	domain	tcccur		o.currency2,
	ref	domain	tcccur		o.currency3,
	ref	domain	tcemm.expu	o.exchange.rate.pur,
	ref	domain	tcemm.expu	o.exchange.rate.sls,
	ref	domain	tcemm.expu	o.exchange.rate.eu,
					...)
{
	FunctionUSAGE
	EXPL:	This function calls "data.financial.company" function to read
		related data about the given financial company.
	PRE:	-
	POST:	-
	INPUT:	company.no -> company number
	OUTPUT: o.currency.system -> currency system
		o.no.hcur -> num. of home curency
		o.local.currency -> local currency
		o.currency2 -> reporting currency1
		o.currency3	-> reporting currency2
		o.exchange.rate.pur -> Purchase exchange rate
		o.exchange.rate.sls -> sales exchange rate
		o.exchange.rate.eu -> internal exchange rate
		time.zone, timezone (optional argument)
	RETURN:	true, financial company data is found; otherwise false.
	ENDFunctionUSAGE

		domain	tctimz		time.zone
			boolean		ret.value

	ret.value = txemm.dll9001.data.financial.company(
					i.company,
					o.currency.system,
					o.no.hcur,
					o.local.currency,
					o.currency2,
					o.currency3,
					o.exchange.rate.pur,
					o.exchange.rate.sls,
					o.exchange.rate.eu,
					time.zone)

	if get.argc() > 9 then
		put.string.arg(10, time.zone)
	endif

	return(ret.value)
}

function boolean get.item.ordering.data(
				domain	tcncmp		i.site,
				domain	tcitem		i.item )
{
								
	static	domain	tcitem	prev.item
	static	domain	tcncmp	prev.site

	boolean	record.found

	record.found = false
							
	if g.clear.cache.all.item.ordering.data then
		prev.item = ""
		g.clear.cache.all.item.ordering.data = false
	endif
								
	if prev.site <> i.site or prev.item <> i.item then
		select	tcibd200.osys:g.ibd200.osys,
			tcibd200.cwar:g.ibd200.cwar	
		from	tcibd200
		where	tcibd200._index1 = { :i.item }
		and	tcibd200._compnr = :i.site
		as set with 1 rows
		selectdo
			prev.site = i.site
			prev.item = i.item
			g.ibd200.item = i.item
			record.found = true
		endselect
	else
		|* Record is not changed, but still found.
		record.found = true
	endif

	return( record.found )
}
function long add.multi.languages.to.stack(
	const	string	i.description,
	ref	long	io.last.used.position,
	ref	long	io.language.node.stack(),
	ref	boolean	io.language.is.set.stack() )
{
	long	sizes.stack(4)
	long	nr.positions.stack
	long	node.data.language
	long	node.data.languages
	long	dummy.nr.dimensions

	|* Initialize local XML data languages.
	if node.data.languages <> 0 then
		free.mem( node.data.languages )
		node.data.languages = 0
	endif
	
	|* BELOW FUNCTION IS AN "UNTRUSTED" FUNCTION.
|t	if rdi.data.languages( node.data.languages ) = 0 then	|* Ref
|		|* Data languages (not hidden) are defined.
|
|		|* Get the size of the description stack.
|		array.info(
|			io.language.node.stack,
|			dummy.nr.dimensions,	|* Ref
|			sizes.stack)		|* Ref
|
|		nr.positions.stack = sizes.stack(1)
|
|		|* Add data languages to stack.
|		node.data.language = xmlGetFirstChild( node.data.languages )
|
|		while node.data.language <> 0
|			RETIFNOK( add.language.to.stack(
|					i.description,
|					nr.positions.stack,
|					node.data.language,	    |* Ref (io)
|					io.last.used.position,
|					io.language.node.stack,	    |* Ref
|					io.language.is.set.stack )) |* Ref
|
|			if node.data.language <> 0 then
|				node.data.language =
|					xmlGetRightSibling( node.data.language )
|			endif
|		endwhile
|t	endif

	return( 0 )
}

function long add.language.to.stack(
	const	string	i.description,
	const	long	i.nr.positions.stack,
	ref	long	io.node.data.language,
	ref	long	io.last.used.position,
	ref	long	io.language.node.stack(),
	ref	boolean	io.language.is.set.stack() )
{
	long	position
	string	b.description(1) based
	string	b.data.language(1) based
	string	b.data.language.status(1) based

	RETIFNOK( get.data.node(
			io.node.data.language,
			TAG_DATALANG,
			b.data.language ))	|* Ref

	RETIFNOK( get.attribute.node(
			io.node.data.language,
			ATTR_STATUS,
			b.data.language.status ))	|* Ref

	SET_BASED_VARIABLE(
		ml_one_lang( i.description, b.data.language),
		b.description )	|* Ref

	|* Explanation data language statuses:
	|*   b: base language
	|*   a: fully available non-base language
	|*   +: a language that is being added.
	|*   -: a language that is being deleted.

	on case b.data.language.status
	case "b": |* Base language
		|* Add base language to last stack position.
		position = i.nr.positions.stack

		break
	default: |* All other statuses
		|* Add to next stack position
		INC( io.last.used.position )

		if io.last.used.position < i.nr.positions.stack then
			position = io.last.used.position

			break
		endif

		|* Last available stack position for not based language is
		|* exceeded. Last position of stack is reserved for base
		|* language.
		|* Language cannot be added to stack.
		position = 0

		if io.last.used.position = i.nr.positions.stack then
			dal.set.info.message(
				"tcbods0197",
				|* tcbods0197  ???
				i.nr.positions.stack )
			|* End of stack (%1$d) reached. Not all languages are
			|* published.
		endif
								
		if io.language.node.stack(i.nr.positions.stack) = 0 then
								
			|* Base language is not filled yet.
			|* Continue with next child XML.
			break
		else
			|* Stack is filled completely (incl. base language).
			|* Further processing of XML can be stopped.
			io.node.data.language = 0

			break
		endif
	endcase

	if position > 0 then
		RETIFNOK( txbod.dll9002.get.description.node(
				b.description,
				"",					|* Type
				b.data.language,			|* Language
				io.language.node.stack(position),	|* Ref
				io.language.is.set.stack(position) ))	|* Ref
	endif

	return( 0 )
}


function  long get.data.node(
		long	i.node,
	const	string	i.tag.name,
	ref	string	o.data() )
{
	FunctionUsage
	Expl:	This function gets the data of a specified node.
	Pre:	Variable 'o.data' is declared as a based string.
	Post:	N.a.
	Input:	i.node
		i.tag.name
	Output:	o.data
	Return:	0/DALHOOKERROR
	EndFunctionUsage

	free.mem( o.data )

	if xmlAllocData( o.data, i.node, i.tag.name ) = -1 then
		ASSERT( false, "No based string used." )

		return( DALHOOKERROR )
	endif

	return( 0 )
}


function long get.attribute.node(
		long	i.node,
	const	string	i.attribute.name,
	ref	string	o.data() )
{
	FunctionUsage
	Expl:	This function gets the data (value) of a specified attribute.
	Pre:	Variable 'o.data' is declared as a based string.
	Post:	N.a.
	Input:	i.node
	Output:	o.data
	Return:	0/DALHOOKERROR
	EndFunctionUsage

	free.mem( o.data )

	if xmlAllocAttribute( o.data, i.node, i.attribute.name ) = -1 then
		ASSERT( false, "No based string used." )

		return( DALHOOKERROR )
	endif

	return( 0 )
}

function init.asserts()
{
	boolean parent.job.process

	if txstl.dll9001.asserts.active() then
		asserts.active = true

		import("job.process", parent.job.process)

		if 	job.process
		  or	parent.job.process
		then
			asserts.display = false
		else
			asserts.display = true
		endif
	else
		asserts.active  = false
		asserts.display = false
	endif

	asserts.initialized = true
}

function assert.failed(	string	i.message(256),
		        string	i.file(32),
		        long	i.line)
{

	assert.error.file = i.file
	assert.error.line = i.line

	|* allways log failure message in logfile
	txstl.dll9001.log.assert.failure(
			i.message,
			i.file,
			i.line)

	|* display assert message
	if asserts.display then

		txstl.dll9001.display.assert.failure(
			i.message,
			i.file,
			i.line,
			asserts.display)

	endif
}

function boolean field.service.implemented()
{
	FunctionUsage
	Expl:	Function checks whether field Field Service
		(tsmdm000.flds) is Yes.
	Pre:	-
	Post:	-
	Input:	-
	Output: -
	Return:	true/false
	EndFunctionUsage
	
	if txmcs.dll9001.read.parm("tsmdm000") = 0 and
	  tsmdm000.flds = tcyesno.yes then
		return(true)
	endif

	return(false)
}

function domain tcdate add.date.to.utc.date(
		domain	tcdate		i.utc.date,
			long		i.nyears,
			long		i.nmonths,
			long		i.ndays,
			long		i.nhours,
			long		i.nminutes,
			long		i.nseconds)
{
	FunctionUsage
	Expl:	Returns an utc date that is later (or earlier) than the given
		i.utc.date.
		The i.nyears, i.nmontsh, i.ndays, i.nhours, i.nminutes or
		i.nseconds are added to (or subtracted from if the values are
		negative) the i.utc.date.
	Pre:	-
	Post:	-
	Input:	i.date	   - date
		i.nyears   - number of years that must be added to the date
		i.nmonths  - number of months
		i.ndays    - number of days
		i.nhours   - number of hours
		i.nminutes - number of minutes
		i.nseconds - number of seconds
	Output:	-
	Return:	utc date
	EndFunctionUsage

	#define	SEC.IN.MINUTE	60
	#define	SEC.IN.HOUR	60 * SEC.IN.MINUTE	|* 60 * 60
	#define	SEC.IN.DAY	24 * SEC.IN.HOUR	|* 24 * 60 * 60
	#define SEC.IN.MONTH	30 * SEC.IN.DAY		|* 30 * 24 * 60 * 60
	#define SEC.IN.YEAR	365 * SEC.IN.DAY	|* 365 * 24 * 60 * 60

		domain	tcdate		calculated.date
			long		ret
			long		total.time

	|* Starting point, the result date is at least equal to the input date.
	calculated.date = i.utc.date

	|* Add or subtract the date parts.
	ret = utc.add(			i.utc.date,
					i.nyears,	|* years
					i.nmonths,	|* months
					i.ndays,	|* days
					i.nhours,	|* hours
					i.nminutes,	|* minutes
					i.nseconds,	|* seconds
					calculated.date)|* ref

	|* Error 2, probably means that the request date is before
	|* 01/01/197 00:00:00 or afer 19/01/2038 03:14:07.
	if ret = 2 then
		|* Determine of the requested date was later or earlier than
		|* the input date.
		calculated.date = -1

		|* The following cases are handled.

		if calculated.date = -1 and
		   i.nseconds = 0 and
		   i.nminutes = 0 and
		   i.nhours = 0 and
		   i.ndays = 0 and
		   i.nmonths = 0 and
		   i.nyears = 0 then
			|* All date parts are zero.
			calculated.date = i.utc.date
		endif

		if calculated.date = -1 and
		   i.nseconds >= 0 and
		   i.nminutes >= 0 and
		   i.nhours >= 0 and
		   i.ndays >= 0 and
		   i.nmonths >= 0 and
		   i.nyears >= 0 then
			|* All date parts are greater (or equal) than zero.
			|* Set date to maximum value
|			set.max(calculated.date)
			set.max(	calculated.date,
					domainof(calculated.date))
		endif

		if calculated.date = -1 and
		   i.nseconds <= 0 and
		   i.nminutes <= 0 and
		   i.nhours <= 0 and
		   i.ndays <= 0 and
		   i.nmonths <= 0 and
		   i.nyears <= 0 then
			|* All date parts are smaller (or equal) than zero.
			calculated.date = 0
		endif

		|* The total time expressed in seconds is greater than 0
		total.time = i.nseconds +
			     i.nminutes * SEC.IN.MINUTE +
			     i.nhours * SEC.IN.HOUR +
			     i.ndays * SEC.IN.DAY +
			     i.nmonths * SEC.IN.MONTH +
			     i.nyears * SEC.IN.YEAR

		if calculated.date = -1 and
		   total.time > 0 then
|			set.max( calculated.date )
			set.max(	calculated.date,
					domainof(calculated.date))
		endif

		if calculated.date = -1 and
		   total.time < 0 then
			calculated.date = 0
		endif

		|* This should be the last case!
		if calculated.date = -1 then
			calculated.date = i.utc.date
		endif
	endif

	return(calculated.date)
}


function boolean get.project.description(
		domain	tccprj		i.project,
	ref	domain	tcdsca		o.description)
{
	FunctionUsage
	Expl.	: This function retrieves the description of a project from the
		  General Projects table (tcmcs052).
	Pre	:
	Post	:
	Input	: i.project		- Project.
	Output	: o.description		- Project Description.
	Return	: True	- Project found.
		  False	- Project not found.
	EndFunctionUsage

	|* Declaration of local variables.

		domain	tcncmp		current.company
	static		boolean		s.ret.val
	static	domain	tcdsca		s.project.dsca
	static	domain	tcncmp		s.company
	static	domain	tccprj		s.project

	current.company = get.compnr()
	if i.project <> s.project or
	   force.description.read = true or			
	   current.company <> s.company then

		s.project.dsca = ""
		s.ret.val = false

		if not isspace(i.project) then
			select	tcmcs052.dsca :s.project.dsca
			from	tcmcs052
			where	tcmcs052._index1 = {:i.project}
			as set with 1 rows
			selectdo
				s.ret.val = true
			endselect
		endif

		s.project = i.project
		s.company = current.company
	endif

	o.description = s.project.dsca

	return(s.ret.val)
}

function  boolean get.company.description(
		domain	tcncmp		i.company,
	ref	domain	tcdesc		o.description)
{
	FunctionUSAGE
	EXPL:	Read the company description
	PRE:	-
	POST:	If the company is not found then the function fails.
	INPUT:	i.company, company number.
	OUTPUT:	o.description, description of the company
	RETURN:	true, description is found; false otherwise.
	ENDFunctionUSAGE

			boolean		ret

	ret = get.company.data(	i.company)
	o.description = g.description

	return(ret)
}

function boolean get.company.data(
		domain	tcncmp		i.company)
{
			long		i

	if i.company = 0 then
		i.company = get.compnr()
	endif

	i = is.company.in.cache(i.company)
	if i > 0 then
		get.company.from.cache(i)
	else
		|* The company is not found in the cache. Read it from
		|* the table.
		init.company.fields()

		if not txmcs.dll9001.company.exists(
					i.company) then
			return(false)
		endif

		if not add.company.to.cache(
					i.company) then
			return(false)
		endif
	endif

	return(true)
}

function boolean add.company.to.cache(
		domain	tcncmp		i.company)
{
	select	tcemm170.comp :g.company
	from	tcemm170
	where	tcemm170._index1 = {	:i.company}
	and	tcemm170._compnr = :i.company
	as set with 1 rows
	selectdo
		last.index = last.index + 1
		if last.index > MAX_CACHE then
			last.index = 1
		endif

		|* Add the company data to the cache
		set.company.in.cache(last.index)
		return(true)
	endselect

	return(false)
}

function void init.company.fields()
{
	|* Initialize the globals
	g.company = 0

}

function long is.company.in.cache(
		domain	tcncmp		i.company)
{
			long		i
			long		found.index

	found.index = 0

	for i = 1 to MAX_CACHE
		if cache.comp(i) = 0 then
			break
		endif

		if cache.comp(i) = i.company then
			found.index = i

		endif
	endfor

	return(found.index)
}

function void get.company.from.cache(
			long		i.index)
{
	g.company = cache.comp(i.index)
}

function void set.company.in.cache(
			long		i.index)
{
	cache.comp(i.index) = g.company
	cache.desc(1, i.index) = g.description
}

function check.and.convert.to.single.byte(
	const	string	i.domain,
	ref	string	io.value)
{
	static	string	s.domain(18)
	static	long	s.domain.type
	static	long	dll.id
	static	long	func.id

		long	ret
		boolean	retval
		string	converted.value(1024)
		string	dummy.string(1)
		long	dummy.long

	if trim$(i.domain) <> trim$(s.domain) then
		s.domain = i.domain

		s.domain.type = rdi.domain(	i.domain,
						dummy.string,
						dummy.string,
						dummy.string,
						dummy.long,
						dummy.string,
						dummy.long,
						dummy.long)
	endif

	if s.domain.type <> db.string then
		return
	endif

	if dll.id = 0 then
		dll.id = load_dll("otlbctdll1000")
		func.id = get_function(dll.id,
				"tlbct.dll1000.convert.to.single.byte")
	endif
	if func.id > 0 then
		ret = exec_function(dll.id, func.id, retval, io.value, converted.value)
		if ret = 0 and retval = true then
			io.value = converted.value
		endif
	endif
}

function long get.language.by.iso.code(
		domain	tcilng	i.iso.code,
	ref	domain	tcclan	o.language)
{
	FunctionUsage
	Expl:	This function locates the ERPLN language corresponding a given
		ISO language code. Caching is used to improve performance.
	Input:	i.iso.code: The ISO code.
	Output: o.language: The ERPLN language matching the ISO code, or empty
			    when there is not equivalent language defined.
	Return:	0 on success, or DALHOOKERROR when the function fails.
	EndFunctionUsage

	static	domain	tcilng	s.iso.code
	static	domain	tcclan	s.language

	if i.iso.code = s.iso.code then
		o.language = s.language
		return(0)
	endif

	o.language = ""

	select 	tcmcs046.clan:o.language
	from	tcmcs046
	where	tcmcs046.ilng = :i.iso.code
	as set with 1 rows
	selectdo
	selecterror
		return(DALHOOKERROR)
	endselect

	s.language = o.language
	s.iso.code = i.iso.code
	return(0)
}

function boolean get.country.by.iso.alpha2.code(
		domain	tcict2		i.iso.code,
	ref	domain	tcccty		o.country)
{
	FunctionUsage
	Expl:	This function locates the ERPLN country corresponding a given
		ISO 2 Alpha country code.
		Caching is used to improve performance.
	Input:	i.iso.code: The ISO Alpha 2 code.
	Output: o.country: The ERPLN country matching the ISO code, or empty
			    when there is not equivalent country defined.
	Return: true	country code can be found
		false	country code cannot be found
	EndFunctionUsage

	static	domain	tcncmp		s.company
	static	domain	tcict2		s.iso.code
	static	domain	tcccty		s.country
		domain	tcncmp		current.company

	current.company = get.compnr()

	if (current.company = s.company and
	    i.iso.code = s.iso.code) then
		o.country = s.country
		return(true)
	endif

	o.country = ""

	select 	tcmcs010.ccty :o.country
	from	tcmcs010
	where	tcmcs010.ict2 = :i.iso.code
	as set with 1 rows
	selectdo
	selectempty
		o.country = ""
		return(false)
	endselect

	s.company = current.company
	s.iso.code = i.iso.code
	s.country  = o.country

	return(true)
}


function long get.iso.code.by.language(
		domain	tcclan	i.language,
	ref	domain	tcilng	o.iso.code)
{
	FunctionUsage
	Expl:	This function reads the ISO code corresponding a given ERPLN
		language. Caching is used to improve performance.
	Input:	i.language: The ERPLN language.
	Output: o.language: The ISO code matching the ERPLN language, or empty
			    when there is no ISO code defined for the language.
	Return:	0 on success, or DALHOOKERROR when the function fails.
	EndFunctionUsage

	static	domain	tcclan	s.language
	static	domain	tcilng	s.iso.code

	if i.language = s.language then
		o.iso.code = s.iso.code
		return(0)
	endif

	o.iso.code = ""

	select 	tcmcs046.ilng:o.iso.code
	from	tcmcs046
	where	tcmcs046.clan = :i.language
	as set with 1 rows
	selectdo
	selecterror
		return(DALHOOKERROR)
	endselect

	s.iso.code = o.iso.code
	s.language = i.language
	return(0)
}


function long get.iso.code.by.currency(
		domain	tcccur		i.currency,
			boolean		i.force.reading,
	ref	domain	tciccc		o.iso.code)
{
	FunctionUsage
	Expl:	This function locates the ERPLN currency corresponding a given
		ISO currency code. Caching is used to improve performance.
	Input:	i.iso.code: The ISO code.
		i.force.reading: force to read the currency record
	Output: o.language: The ERPLN currency matching the ISO code, or empty
			    when there is not equivalent currency defined.
	Return:	0 on success, or DALHOOKERROR when the function fails.
	EndFunctionUsage

	static	domain	tciccc		s.iso.code
	static	domain	tcccur		s.currency

	if i.force.reading = false then
		if i.currency = s.currency then
			o.iso.code = s.iso.code
			return(0)
		endif
	endif

	o.iso.code = ""

	select 	tcmcs002.iccc :o.iso.code
	from	tcmcs002
	where	tcmcs002.ccur = :i.currency
	as set with 1 rows
	selectdo
	selecterror
		return(DALHOOKERROR)
	endselect

	s.currency  = i.currency
	s.iso.code = o.iso.code
	return(0)
}

function boolean is.valid.iso.currency.code(
		domain	tciccc		i.iso.code)
{
	FunctionUsage
	Expl:	This function checks the format of an ISO currency code as
		used in tcmcs002. A currency code consists of a three characters
		(defined in ISO4217). All characters should be uppercase.
		This function only checks the format of the currency code, no
		validation of the currency is done.
	Input:	i.iso.code: The language which needs to be validated.
	Return:	true when de code is valid or false when it is not.
	EndFunctionUsage
	
	domain	tcmcs.byte	temp.first
	domain	tcmcs.byte	temp.second
	domain	tcmcs.byte	temp.third

		temp.first 	= asc(i.iso.code(1;1))
		temp.second 	= asc(i.iso.code(2;1))
		temp.third 	= asc(i.iso.code(3;1))

	if temp.first >= 65 and
	   temp.first <= 90 then
		if temp.second 	< 65 or
		   temp.second 	> 90 or
		   temp.third 	< 65 or
		   temp.third 	> 90 then
			return(false)
		endif
	else
		if  temp.first >= 48 and
		    temp.first <= 57 then
			if temp.second 	< 48 or
			   temp.second 	> 57 or
			   temp.third 	< 48 or
			   temp.third 	> 57 then
				return(false)
			endif
		else
			return(false)
		endif
	endif
	return(true)
}

function long get.iso.alpha2.code.by.country(
		domain	tcccty		i.country,
	ref	domain	tcict2		o.iso.code)
{
	FunctionUsage
	Expl:	This function locates the ERPLN country corresponding a given
		ISO country code. Caching is used to improve performance.
	Input:	i.iso.code: The ISO code.
	Output: o.language: The ERPLN country matching the ISO code, or empty
			    when there is not equivalent country defined.
	Return:	0 on success, or DALHOOKERROR when the function fails.
	EndFunctionUsage

	RETIFNOK(country.make.fields.global(			|#2065498.sn
					get.compnr(),
					i.country))		|#2065498.en
	o.iso.code = g.iso.code.alpha2

	return(0)
}

function long country.make.fields.global(			|#2065498.sn
		domain	tcncmp		i.company,
		domain	tcccty		i.country)
{

	if (i.company = g.company and
	    i.country = g.country) then
		return(0)
	endif

	g.company = i.company
	g.country = i.country

	initialize.variables(g.iso.code.alpha2)

	if isspace(i.country) then
		return(0)
	endif

	select	tcmcs010.ict2 :g.iso.code.alpha2	
	from	tcmcs010
	where	tcmcs010._index1 = {:i.country}
	as set with 1 rows
	selectdo
	selectempty
		dal.set.error.message("txcom1306",
		|* Country '%1$s' not found in Countries.
					trim$(i.country))
		|* Country '%1$s' not found in Countries.
		return(DALHOOKERROR)
	endselect

	return(0)
}

function void initialize.variables(...)
{
	FunctionUsage
	Expl:	Initializes the passed variables:
		_______________________________________
		|Data Type		|Initial Value
		|-----------------------+---------------
		|Long			|0
		|Integer(same as Long)	|0
		|Boolean(same as Long)	|0
		|Enumerate(same as Long)|0
		|Double			|0.0
		|String			|""
		|MB String		|""
		------------------------+---------------
	Input/:	single variable, or list of variable of data type from above.
	output
	EndFunctionUsage

			long		arg.count

	for arg.count = 1 to get.argc()
		on case get.arg.type(	arg.count)
		case DB.LONG:
			put.long.arg(	arg.count, 0)
			break
		case DB.DOUBLE:
			put.double.arg(	arg.count, 0.0)
			break
		case DB.STRING:
			put.string.arg(	arg.count, "")
			break
		case DB.MULTIBYTE:
			put.string.arg(	arg.count, "")
			break
		case -1:
			break
		endcase
	endfor
}

function boolean valid.department(
				domain	tcmcs.str10	i.role,
				domain	tccom.bpid	i.business.partner,
				domain	tccwoc		i.department)
{
	domain	tccwoc	department

	static	boolean	s.valid

	static	domain	tcmcs.str10	s.role
	static	domain	tccom.bpid	s.business.partner
	static	domain	tccwoc		s.department

	if trim$(i.role) = trim$(s.role)			 and
	   trim$(i.business.partner) = trim$(s.business.partner) and
	   trim$(i.department) = trim$(s.department)		 then
		return(s.valid)
	else
		s.role			= i.role
		s.business.partner	= i.business.partner
		s.department		= i.department
	endif

	s.valid = false

	on case i.role
	case INVOICE_TO:
		select	tccom112.cofc:department
		from	tccom112
		where	tccom112._index1 = {:i.business.partner,
					    :i.department}
		as set with 1 rows
		selectdo
			s.valid = true
		endselect

		break
	case PAY_BY:
		select	tccom114.cofc:department
		from	tccom114
		where	tccom114._index1 = {:i.business.partner,
					    :i.department}
		as set with 1 rows
		selectdo
			s.valid = true
		endselect

		break
	case INVOICE_FROM:
		select	tccom122.cofc:department
		from	tccom122
		where	tccom122._index1 = {:i.business.partner,
					    :i.department}
		as set with 1 rows
		selectdo
			s.valid = true
		endselect

		break
	case PAY_TO:
		select	tccom124.cofc:department
		from	tccom124
		where	tccom124._index1 = {:i.business.partner,
					    :i.department}
		as set with 1 rows
		selectdo
			s.valid = true
		endselect

		break
	endcase

	return(s.valid)
}


function long check.logical.ids(
	const		long		i.company.from,
	const		long		i.company.to,
	const	domain	tcbod.uvrb	i.use.verb,
	const		string		i.logical.ids )
{
		long		nr.logical.ids
		long		logical.id.number
		string		b.logical.id.stack(1,1) based
	domain	tcmcs.str215	logical.id

	|* Check if Logical ID(s) is/are specified if Show-verb is selected.
						
								|* ValOP2CE_01.sn
	|* WHILE DOING REPUBLISH OF BODS, USE OF 'SHOW' VERB IS NOT IN THE 
	|* SCENARIOS OF VALMET. HENCE SKIPPING THE VALIDATION OF LOGICAL IDS.
	|* VALIDATION OF LOGICAL IDS NEED FUNCTION 'ESB.ADMIN.GET.LOGICALID.COMPANY' 
	|* WHICH IS NOT TRUSTED.
	
	|* Related to Republishing Session.
								
	if i.use.verb = PD_USE_VERB_SHOW then
		return(0)	
	endif
								|* ValOP2CE_01.en
	
								|* ValOP2CE_01.so
|	if i.use.verb = PD_USE_VERB_SHOW then	
|		if isspace( i.logical.ids ) then
|			dal.set.error.message( "txbods0024" )
|			|* No Logical ID(s) specified.
|
|			return( DALHOOKERROR )
|		endif
|
|		RETIFNOK( get.logical.id.stack.from.string(
|				i.logical.ids,
|				b.logical.id.stack,	|* Ref
|				nr.logical.ids ))	|* Ref
|
|		|* Check if prefix of Logical ID(s) is: lid://
|		for logical.id.number = 1 to nr.logical.ids
|			logical.id = b.logical.id.stack(1,logical.id.number)
|
|			if not str.startswith(
|					logical.id,
|					PD_PREFIX_LOGICAL_ID ) then
|				dal.set.error.message(
|					"txbods0031",
|					|* Logical ID '%1$s' does not start with
|					|* prefix '%2$s'.
|					trim$( logical.id ),
|					PD_PREFIX_LOGICAL_ID )
|				|* Logical ID '%1$s' does not start with
|				|* prefix '%2$s'.
|
|				return( DALHOOKERROR )
|			endif
|
|			if str.equals(	trim$( logical.id ),
|					PD_PREFIX_LOGICAL_ID ) then
|				dal.set.error.message(
|					"txbods0032",
|					|* Only prefix '%1$s' defined for
|					|* logical ID.
|					PD_PREFIX_LOGICAL_ID )
|				|* Only prefix '%1$s' defined for logical ID.
|
|				return( DALHOOKERROR )
|			endif
|		endfor
|
|		|* Check if an own Logical ID within the company range is
|		|* specified.
|		RETIFNOK( check.own.logical.id.is.not.specified(
|				i.company.from,
|				i.company.to,
|				i.logical.ids ))
|	endif
								|* ValOP2CE_01.eo
							
	return( 0 )
}

function long check.own.logical.id.is.not.specified(
	const	long	i.company.from,
	const	long	i.company.to,
	const	string	i.logical.ids )
{
		long		company.number
		long		nr.companies.in.stack
		long		return.value
	domain	tcbod.loid	logical.id
	domain	tcncmp		company
	domain	tcncmp		b.company.stack(1) based

	|* Get the companies within the specified range.
|	RETIFNOK( get.companies(				
	RETIFNOK( txbod.dll9002.get.companies(			
			i.company.from,
			i.company.to,
			b.company.stack,	|* Ref
			nr.companies.in.stack ))|* Ref

	for company.number = 1 to nr.companies.in.stack
		company = b.company.stack( company.number )

|t		STOP.MESSAGES

		return.value = txbod.dll9002.get.logical.id.company(
				company,
				logical.id )	|* Ref

|t		START.MESSAGES

		if return.value = 0 and
		   pos( i.logical.ids, trim$( logical.id )) > 0 then
			|* Logical ID of company is specified
			dal.set.error.message(
				"txbods0202",
				|* txbods0202  ???
				logical.id,
				company )
			|* Logical ID '%1$s' is not allowed. Logical ID is
			|* specified for company %2$d.

			return( DALHOOKERROR )
		endif
	endfor

	return( 0 )
}



function long get.logical.id.stack.from.string(
	const	string	i.logical.ids,
	ref	string	o.logical.id.stack(,),
	ref	long	o.nr.logical.ids )
{
	|* Assumption: Variable 'i.logical.ids' if filled.

	long	length
	long	offset
	long	counter
	long	position.comma
	long	dummy.value

	free.mem( o.logical.id.stack )

	|* Get number of Logical IDs.
	o.nr.logical.ids =
		len( i.logical.ids ) -
		len( str.replace$( i.logical.ids, ",", "" )) + 1

	|* Allocate memory for determined number of Logical IDs and total length
	|* of complete Logical IDs string. That is always enough and prevents
	|* much logic.
	dummy.value = alloc.mem(
			o.logical.id.stack,
			len( trim$( i.logical.ids )),
			o.nr.logical.ids )

	offset = 1
	counter = 0

	repeat
		INC( counter )

		position.comma = pos( i.logical.ids( offset ), ",")

		if position.comma = 0 then
			length = len( i.logical.ids( offset ))
		else
			length = position.comma - 1
		endif

		o.logical.id.stack(1,counter) =
				shiftl$( i.logical.ids( offset;length ))

		offset = offset + position.comma
	until position.comma = 0

	return( 0 )
}

function  boolean check.file.creation.possible.in.path(
	domain	tcclsv		i.location,
	domain	tcmcs.s512	i.directory,
	domain	tcmcs.s512	i.file )
{
	FunctionUsage
	Expl.	: This function tries to create a file in the given directory
		  with the given name or with the name "dummy" is no name is
		  specified.When it is posisble to create a file, it will be
		  removed before return back.
	Pre	: -
	Post	: -
	Input	: i.filename		- The (optional)name of the file to be
					  created with the full path
	          i.path 		- The directory in which the file needs
		  			  to be created.
		  i.location		- Specifies where the file need to be
		  			  created.
	Output	: NA
	Return	: Function returns false if the file creation in the
		  specified directory fails.
		  Function returns true if the file creation is sucessful.
	EndFunctionUsage

	domain	tcmcs.s512	l.file.with.directory
	domain	tcmcs.s512	l.file
	
	l.file.with.directory = ""
	l.file = ""
	
	if not isspace( i.file ) then
		l.file = l.file
	else
		l.file = "dummy" & str$( utc.num() )
	endif

	l.file.with.directory =
		trim$( i.directory ) &
		get.path.separator( i.location ) &
		trim$( l.file )

	on case i.location
	case PD_SERVER:
		return( check.file.creation.server.possible(
				l.file.with.directory ) )
	case PD_CLIENT:
		return( check.file.creation.client.possible(
				l.file.with.directory ) )
	default:
		ASSERT(	false,
			"Location '" & str$( i.location) & "' not supported." )

		break
	endcase

	return( false )
}

function string get.path.separator(
	domain	tcclsv	i.location )
{
	FunctionUsage
	Expl.	: This function returns the separator to be used depending on
		  the OS of the server.
	Pre	: -
	Post	: -
	Input	: -
	Output	: NA
	Return	: The path separator
	EndFunctionUsage

	on case i.location
	case PD_CLIENT:
		return( "\" )
	case PD_SERVER:
		|* Related to Republishing  Session
|t		return( path.dir.separator( ostype() ) )
	endcase

	return( "" )
}

function boolean check.file.creation.client.possible(
	const	string	i.file )
{
|t	if create.local.file( i.file ) = 0 then
|		|* File created sucessfully. This can be removed now.
|		remove.local.file( i.file )
|
|		return( true )
|t	endif

	return(false )
}

function boolean check.file.creation.server.possible(
	const	string	i.file )
{
	long	l.file.pointer
	long	l.dummy.value
	string	error.message(132) mb

	l.file.pointer = 0
	l.dummy.value = 0
	
	if open.file(
			i.file,
			"w",
			l.file.pointer ) = 0 then	|* Ref
		if close.file( i.file, l.file.pointer ) <> 0 then
			l.dummy.value = dal.get.error.message( error.message )

			ASSERT(	false, error.message )
		endif

		if delete.file( i.file ) <> 0 then
			l.dummy.value = dal.get.error.message( error.message )

			ASSERT( false, error.message )
		endif

		return( true )
	else
		l.dummy.value = dal.get.error.message( error.message )

		ASSERT( false, error.message )
	endif

	return( false )
}


function long delete.file(
	const	string	i.file )
{
	FunctionUsage
	Expl:	The purpose of this function is to delete a specified file.
	Pre:	N.a.
	Post:	N.a.
	Input:	i.file
	Output:	N.a.
	Return:	0/DALHOOKERROR
	EndFunctionUsage

	long	return.value

	return.value = seq.unlink( i.file )

	if return.value < 0 then
		dal.set.error.message( "txbods0138", trim$( i.file ), e )
		|* txbods0138  ???

		return( DALHOOKERROR )
	endif

	return( 0 )
}

function handle.hold.called.from.publish.data.session(
		long	i.method,
	ref	boolean	io.called.from.publish.data.session )
{
	static	boolean	s.called.from.publish.data.session

	on case i.method
	case SET_VALUE:
		s.called.from.publish.data.session =
					io.called.from.publish.data.session
		break
	case GET_VALUE:
		io.called.from.publish.data.session =
					s.called.from.publish.data.session
		break
	endcase
}

function boolean get.show.progress.indicator()
{
	boolean	show.progress.indicator

	handle.show.progress.indicator(
		GET_VALUE,
		show.progress.indicator )	|* Ref i/o

	return( show.progress.indicator )
}


function boolean get.logging.supported(
	const	domain	tcbod.mode	i.mode,
	const	domain	tcyesno		i.logging )
{
	if logging.is.supported.by.mode( i.mode ) and
	   i.logging = tcyesno.yes then
		return( true )
	else
		return( false )
	endif
}
function boolean logging.is.supported.by.mode(
	const	domain	tcbod.mode	i.mode )
{
	if i.mode = PD_MODE_SIMULATE or
	   i.mode = PD_MODE_PUBLISH then
		return( true )
	else
		return( false )
	endif
}
function get.directory(
	ref	domain	tcpath2	o.directory.name )
{
	domain	tcpath2	 directory.name

	o.directory.name = ""

	
|t	if client.upload.file( directory.name ) = 1 then
|		o.directory.name = directory.name
|t	endif
}

function  domain tcncmp start.companies(
	ref	domain	tcncmp		o.company,
			boolean		i.hide.archive.companies)
{
	FUNCTIONUSAGE
	EXPL:	Starts the departments session.
		Example:

		tcint.dlltcemm.start.companies(result.company,
						false,
						tcemm.ctyp.logistic,
						tcemm.ctyp.financial)

		Show all companies, including the archive. But the company
		types must be of logistic or finacial.
		So the 'both' companies are skipped.
	PRE:
	POST:
	INPUT:	i.hide.archive.companies, hide archive companies (true/false)
		... , list of company types (logistic, financial, both)
	OUTPUT:	o.company
	RETURN:	selected company number
	ENDFUNCTIONUSAGE

		domain	tcmcs.str10	l.company.string
		domain	tcncmp		l.new.company

			long		i

	l.company.string = ""
	l.new.company = 0

	zoom.company = o.company

	if get.argc() > 2 then
		zoom.start.method = "by.company.type"
		zoom.start.filter = "by.company.type"

		zoom.nr.company.types.in.stack = 0
		if alloc.mem(zoom.company.type.stack,
			      get.argc() - 2) = 0 then

			set.mem(zoom.company.type.stack, empty)

			for i = 3 to get.argc()
				zoom.nr.company.types.in.stack =
				zoom.nr.company.types.in.stack + 1
				zoom.company.type.stack(
					zoom.nr.company.types.in.stack) =
						ltoe(get.long.arg(i))
			endfor
		endif
	endif

	zoom.hide.archive.companies = i.hide.archive.companies
	l.company.string = start.session(MODAL, "tcemm1170m000",
	|* Companies
					"integration", "tcemm170.comp")
	l.new.company = lval(l.company.string)

	o.company = (l.new.company = 0 ? o.company : l.new.company)

	return(o.company)
}

function boolean use.client.download.for.zipped.log.file()
{
	boolean	use.client.download

	handle.hold.use.client.download.for.zipped.log.file(
		GET_VALUE,
		use.client.download )	|* Ref

	return( use.client.download )
}
function set.use.client.download.for.zipped.log.file(
	const	domain	tcclsv	i.log.location )
{
	boolean	use.client.download

	|if tc.is.html.ui() and
	if i.log.location = PD_CLIENT then
		use.client.download = true
	else
		use.client.download = false
	endif

	handle.hold.use.client.download.for.zipped.log.file(
		SET_VALUE,
		use.client.download )
}

function set.enum.values.for.log.subject(
	const	domain	tcbod.mode	i.mode,
	const		string		i.field.name )
{
	|* Possible options for subject to be logged are:
	|* - DocumentID
	|* - BOD
	|*
	|* In simulate mode make both options available.
	|* In all other cases, make option 'DocumentID' available only.

	on case i.mode
	case PD_MODE_SIMULATE:
		set.enum.values.for.field( i.field.name )
		|* Support all options. No action needed.
		break
	default:
		|* In all other cases, do not support logging of BODs.
		set.enum.values.for.field(
			i.field.name,
			ALL_ENUMS_EXCEPT,
			LOG_BOD )

		break
	endcase
}

function set.field.log.directory(
	const	string	i.log.directory.field.name )
{
	|* If field 'Location' is 'Client', field 'Directory' must not be
	|* visible in HTML UI. The field must be visible in all other cases.

	if CLIENT_DOWNLOAD_ZIP_FILE then
		inputfield.invisible( i.log.directory.field.name )
	else
		inputfield.visible( i.log.directory.field.name )
	endif
}

function handle.hold.use.client.download.for.zipped.log.file(
		long	i.method,
	ref	boolean	io.use.client.download )
{
	static boolean	s.use.client.download

	on case i.method
	case SET_VALUE:
		s.use.client.download = io.use.client.download

		break
	case GET_VALUE:
		io.use.client.download = s.use.client.download

		break
	endcase
}

function long get.number.of.logical.ids(
	const	string	i.logical.ids )
{
	long	l.position
	long	l.offset
	long	l.nr.logical.ids 

	l.position = 0
	l.offset = 1
	l.nr.logical.ids = 0

	while l.offset > 0
		l.position = pos(	i.logical.ids, PD_PREFIX_LOGICAL_ID, l.offset )

		l.offset = l.position

		if l.position > 0 then
			INC( l.nr.logical.ids )
			|* Set start position in string for next Logical ID.
			INC( l.offset )
		endif
	endwhile

	return( l.nr.logical.ids )
}

function  long alloc.name(
	const	long	i.node,
	ref	string	o.tag() )
{
	FunctionUsage
	Expl:	This function gets the tag name of a specified node.
	Pre:	Variable 'o.tag' is declared as a based string.
	Post:	Deallocate memory of variable 'o.tag'.
	Input:	i.node
	Output:	o.tag
	Return:	0/DALHOOKERROR
	EndFunctionUsage

	free.mem( o.tag )

	if xmlAllocName( o.tag, i.node ) = -1 then
		dal.set.error.message( "@No based string used." )

		return( DALHOOKERROR )
	endif

	return( 0 )
}

function boolean publish.project.master.allowed(
			domain	tcmcs.long	i.mode,
			domain	tccprj		i.project,
			domain	tppdm.psts	i.status)
{

	if i.mode = DAL_NEW then
		|* Newly created projects should be published to have a
		|* reference for masterdata bods.
		return(true)
	endif
	if i.mode = DAL_DESTROY then
		|* Deleted project should always be published.
		return(true)
	endif

	if i.status = tppdm.psts.free then
		return(false)
	endif

	if txbod.dll9002.get.status.updated() then
		|* If project status gets updated, also activities and/or
		|* elements get updated which leads to BOD triggering.
		return(false)
	endif

	if project.activities.exist(i.project) then
		return(true)
	endif

	if project.elements.exist(i.project) then
		return(true)
	endif

	return(false)
}

function boolean project.activities.exist(
		domain	tccprj		i.project)
{
	domain	tppss.cpla	l.plan

	txpdm.dll9001.project.get.active.plan(
					i.project,
					l.plan)	|* ref

 	return(txpss.dll9001.activity.structure.exists(
					i.project,
 					l.plan))

	return(true) 	|* Remove after resolving the error.
}

function boolean project.elements.exist(
			domain	tccprj		i.project)
{
	if txptc.dll9001.elements.exist.for.project(
					i.project) then
		return( true )
	endif

	return( false )
}

|function extern long txbod.dll9002.unit.in.unitset(
|			domain	tcuset     	i.unit.set	fixed,
|			domain	tccuni     	i.unit		fixed,
|			domain	tcmcs.str4 	i.type,
|			long			i.update.status,
|			domain	tcbool  	i.mess,
|								|#202742.n
|		[	string			i.field(13),
|			string			i.table(8),
|			domain	tcitem		i.item,
|		ref	domain	tcmcs.str256m	o.message])	|#202742.n
|{
|	DllUsage
|	Expl.	: For a given unit set this routine checks if the given unit is
|        	  present. If not present or this unit is not allowed an error
|        	  will be returned.				     |#202742.sn
|        	  if i.mess and optional argument i.field is filled, |#202742.en
|        	  then message string will be returned
|	Pre	: -
|	Post	: -
|	Input	: i.unit.set		- Unit Set (mandatory).
|		  i.unit 		- Unit (mandatory).
|        	  i.type	 	- Type (mandatory: "trad", "prod",
|					  "pric", "stor", or "inve";
|					  if empty no check on the type will be
|                        	 	  done)
|        	  i.update.status	- The unit is being used during
|					  'ADD.SET' or 'MODIFY.SET'. Variable
|					  'update.status' can be used.
|		  i.mess		- put a message on dal error stack, when
|		  			  error occurs and if i.field is
|		  			  filled.
|		  i.field		- field (optionial). This is needed
|		  			  to fill the error message.
|		  i.item		- needed to fill the error message
|	Output	: -
|	Return	: -1	 => unit can not be used for purpose defined
|		  ENOREC => unit is not present in unitset
|		  0	 => no error found
|	EndDllUsage
|
|	domain	tcpeun	hold.trad		|* Distribution
|	domain	tcpeun	hold.prod		|* Manufacturing
|	domain	tcpeun	hold.pric		|* Price
|	domain	tcpeun	hold.stor		|* Storage
|	domain	tcpeun	hold.inve		|* Inventory
|	domain	tcbool	error.occur		|* Error Occurred?
|
|	static	domain	tcuset	s.unit.set
|	static	domain	tccuni	s.unit
|	static	domain	tcncmp	s.ncmp
|	static	domain	tcpeun	s.trad
|	static	domain	tcpeun	s.prod
|	static	domain	tcpeun	s.pric
|	static	domain	tcpeun	s.stor
|	static	domain	tcpeun	s.inve
|								|#202742.sn
|	domain	tcmcs.st60m	field.desc
|	domain	tcmcs.st60m	table.desc
|	domain	tcmcs.str256m 	l.message
|	long			ret.val
|
|	if get.argc() > 5 then
|		i.field 	= get.string.arg(6)
|		i.table		= get.string.arg(7)
|		i.item		= get.string.arg(8)
|	endif
|								|#202742.en
|	error.occur = false
|	if s.unit.set = i.unit.set and
|	   s.unit = i.unit and
|	   s.ncmp = get.compnr() then
|		hold.trad = s.trad
|		hold.prod = s.prod
|		hold.pric = s.pric
|		hold.stor = s.stor
|		hold.inve = s.inve
|	else
|		select	tcmcs012.trad:hold.trad,
|			tcmcs012.prod:hold.prod,
|			tcmcs012.pric:hold.pric,
|			tcmcs012.stor:hold.stor,
|			tcmcs012.inve:hold.inve
|		from	tcmcs012
|		where	tcmcs012._index1 = {:i.unit.set, :i.unit}
|		as set with 1 rows
|		selectdo
|			s.unit.set = i.unit.set
|			s.unit = i.unit
|			s.ncmp = get.compnr()
|			s.trad = hold.trad
|			s.prod = hold.prod
|			s.pric = hold.pric
|			s.stor = hold.stor
|			s.inve = hold.inve
|		selectempty
|			s.unit.set = ""
|			s.unit = ""
|			s.ncmp = 0
|			s.trad = empty
|			s.prod = empty
|			s.pric = empty
|			s.stor = empty
|			s.inve = empty
|								|#202742.sn
|			if i.mess and not isspace(i.field) then
|				field.desc = tt.field.desc(i.field)
|				table.desc = tt.table.desc(i.table)
|				l.message = form.text$("tcibds00121")
|				|* %5$s: %1$s (%2$s) of item %4$s does not exist
|				|* in Unit Set %3$s
|				l.message = sprintf$(l.message,
|						trim$(field.desc),
|						trim$(i.unit),
|						trim$(i.unit.set),
|						trim$(i.item),
|						trim$(table.desc)
|					)
|				ret.val = put.string.arg(9, l.message)
|			endif					|#202742.en
|			return(ENOREC)
|		endselect
|	endif
|
|	on case i.type
|		UNIT_CASE(trad)
|		UNIT_CASE(prod)
|		UNIT_CASE(pric)
|		UNIT_CASE(stor)
|		UNIT_CASE(inve)
|	endcase
|
|	if error.occur then
|								|#202742.sn
|		field.desc = ""
|		if i.mess and not isspace(i.field) then
|			field.desc = tt.field.desc(i.field)
|			table.desc = tt.table.desc(i.field)
|			l.message = form.text$("tcibds00122")
|			|* %6$s: %1$s (%2$s) of Item %4$s can not be used for
|			|* %5$s , as defined by Unit Set %3$s
|			l.message = sprintf$(l.message,
|					trim$(field.desc),
|					trim$(i.unit),
|					trim$(i.unit.set),
|					trim$(i.item),
|					trim$(tt.field.desc("tcmcs012." &
|								i.type)),
|					trim$(table.desc)
|				)
|			ret.val = put.string.arg(9, l.message)
|		endif						|#202742.en
|
|		return(LOGIC_ERR)
|	endif
|	return(0)
|}

|function extern txbod.dll9002.handle.pb.field(
|			long	i.method,
|	const		string	i.select.field,
|	ref	domain	tcyesno	io.selected )
|{
|	DllUsage
|	Expl:	The purpose of this function is to set or read a publish select
|		field.
|	Pre:	N.a.
|	Post:	N.a.
|	Input:	i.method	- SET_VALUE / GET_VALUE
|		i.select.field
|	In/out:	io.selected	- Yes/ No
|	Output:	N.a.
|	Return:	N.a.
|	OLD DLL :tcbod.dll0006.handle.pb.field
|	EndDllusage
|
|	long	expression.id
|	long	dummy.return
|
|	on case i.method
|	case GET_VALUE:
|		expression.id = expr.compile(
|				"e.pb.field := " & trim$( i.select.field ))
|
|		io.selected = ltoe( l.expr( expression.id ))
|
|		break
|	case SET_VALUE:
|		expression.id = expr.compile(
|				trim$( i.select.field ) & " := " &
|				str$( io.selected ))
|
|		dummy.return = l.expr( expression.id )
|
|		break
|	endcase
|
|	free.mem( expression.id )
|}
|function extern long txbod.dll9002.check.conversion.factor(	|#215034-FP4.sn
|		domain tcitem i.item,
|		domain tccitg i.item.group,
|		domain tccuni i.unit,
|		domain tccuni i.main.unit)
|{
|	DllUsage
|	Explanation: to check if a valid Conversion Factor exists, and
|		to set a message if not.
|
|		To be used in DAL-2 is.valid()-hooks.
|
|	Pre: N.A.
|	Post: N.A.
|	Input: item, item.group, unit, main unit.
|	Output: N.A.
|	Pre: N.A.
|	Post: message set in buffer for return value DALHOOKERROR, either
|		.Conversion Factor not yet approved. or
|		.Conversion Factor not yet present.
|	Return: 0:		approved Conversion Factor found
|		DALHOOKERROR:	else.
|			(no Approved Conversion Factor found.
|			 either found an Unapproved factor or no factor at all).
|	EndDllUsage
|
|	domain	tcconv		l.approved.cf
|	domain	tcconv		l.unapproved.cf
|
|	l.approved.cf = tcibd.dll0003.conv.factor(
|				i.item, i.item.group, i.unit, i.main.unit,
|				false,		|* reverse factor
|				true,		|* zero allowed
|				false)		|* find.unapproved.cf
|
|	l.unapproved.cf = tcibd.dll0003.conv.factor(
|				i.item, i.item.group, i.unit, i.main.unit,
|				false,		|* reverse factor
|				true,		|* zero allowed
|				true)		|* find.unapproved.cf
|
|
|	if EQUAL.TO(l.approved.cf, 0.0) then
|		|* Approved NOT FOUND
|
|		if isspace(i.unit) then
|			i.unit = hold.base.unit
|		endif
|
|		if EQUAL.TO(l.unapproved.cf, 0.0) then
|			|* UNapproved NOT FOUND
|			dal.set.error.message("tcibds1215",
|			|* No Conversion Factor present yet for Unit %1$s and
|			|* Base Unit %2$s.
|			trim$(i.main.unit), trim$(i.unit))
|		else
|								|#244901.sn
|			if g.allow.unapproved.conversion.factor then
|				|* unapproved factor is allowed
|				return(0)
|			endif
|								|#244901.en
|			dal.set.error.message("tcibds1216",
|			|* Conversion Factor for Unit %1$s and Base Unit %2$s is
|			|* not yet approved.
|			trim$(i.main.unit), trim$(i.unit))
|		endif
|		return(DALHOOKERROR)
|	endif
|
|	return(0)	|* OK: an Approved CF exists.
|}

|********* 
